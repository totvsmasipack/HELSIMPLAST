#INCLUDE "LOJA701C.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "CRDDEF.CH"
#INCLUDE "AUTODEF.CH"

#DEFINE _MOEORIPGT					2				//Moeda origem da venda
#DEFINE _FORMAPGTO					3				//Posicao do campo Forma de Pgto no array aPgtos(Localizacoes)
#DEFINE _MOEDA						6				//Posicao do campo Moeda no array aPgtos(Localizacoes)
#DEFINE TEF_NAO_USADO				"1"				//Nao Utiliza TEF
#DEFINE TEF_SEMCLIENT_DEDICADO  	"2"				//Utiliza TEF Dedicado Troca de Arquivos
#DEFINE TEF_COMCLIENT_DEDICADO  	"3"				//Utiliza TEF Dedicado com o Client
#DEFINE TEF_DISCADO             	"4"				//Utiliza TEF Discado
#DEFINE TEF_LOTE                	"5"				//Utiliza TEF em Lote
#DEFINE TEF_CLISITEF				"6"				//Utiliza a DLL CLISITEF
#DEFINE TEF_CENTROPAG				"7"				//Utiliza a DLL CENTRO DE PAGOS
#DEFINE _FORMATEF					"CC;CD"			//Formas de pagamento que utilizam operação TEF para validação
#DEFINE _SERNFE						"SPED;RPS"		//Tipo de especie de nota eletronica
#DEFINE CTRL 						Chr(10)+Chr(13)	//Pula linha
#DEFINE CFD_SEPARA					"----------------------------------------"
#DEFINE REG_DELETED					"DELETED"		//Sinaliza registro SL2 deletado
#DEFINE GDP_NO						"0" 			//Nao sera gerada guia de despacho.Quando a venda não tem item reservado com entrega do tipo 3 - Release 11.5 -  Chile - F2CHI
#DEFINE GDP_PARCIAL    				"1"				//Sera gerada guia de despacho parcial.Quando a venda possui pelo menos um item reservado com entrega do tipo 3 - Release 11.5 -  Chile - F2CHI
#DEFINE GDP_TOTAL					"2"				//Sera gerada guia de despacho total.Quando todos os itens da venda estao reservados e com entrega do tipo 3 - Release 11.5 -  Chile - F2CHI
#DEFINE _CONTAHTL					12				//Conta Hotelaria
#DEFINE _TEFINTEG					13				//Informacoes Tef Integracao

Static cGetCliDir														// Guarda o caminho do rootPath
Static cProfStr1														// Guarda o Retorno da Funcao GetPvProfString
Static cprofStr2														// Guarda o Retorno da Funcao GetPvProfString
Static lHomTEF      := ExistFunc("LJHOMTEF") .AND. LJMSSM0(SM0->M0_CGC)
Static lAmbOff	 	:= SuperGetMv("MV_LJOFFLN", Nil, .F.)				// Verifica se o ambiente esta em off-line
Static lMVLJPDVPA 	:= LjxBGetPaf()[2]									// Indica se é pdv
Static aSaveDecLj	:= Array(10,2) 										// Array utilizado na função Lj7Arred(), para calculo de arredondamento
Static lCenVenda	:= SuperGetMv("MV_LJCNVDA",,.F.)					// Indica se a integracao com o cenario de vendas esta ativa
Static cSenha		:= "******"											// Variavel apagada pelo Framework
Static lUsaIntFS	:= SuperGetMV("MV_LJINTFS",,.F.) .And. LjUpd90Ok()  // Verifica se a integracao com o financial services esta habilitada
Static aRetAdmTef	:= {}												// Guarda a Adm. Financeira selecionada para cada cartao utilizado na venda
Static aParceiros	:= {}												// Armazena envio de e-mail de itens vendidos com comissao para parceros que indicam a loja

/*Release 11.5 - Controle de Formularios
Paises:Chile/Colombia - F1CHI		  */
Static lCFolLocR5	:= SuperGetMv("MV_CTRLFOL",,.F.) .AND. cPaisLoc$"CHI|COL" .AND.	!lFiscal
Static lMostraCtb
Static lAglutCtb
Static lCtbOnLine
Static lCtbCusto
Static lReajuste
Static LAtuSA7lECF
Static lSFinanc		:= ExistFunc("LJVldCliSf") .AND. AliasIndic("MG8") .AND. SuperGetMV("MV_LJCSF",,.F.) // Valida se habilita o controle de servicos financeiros
Static aPafNotaCF	:= {} //Guarda a nota que é usada quando o PAF imprime NOTA e CUPOM - ERPAFECF 02.03
Static lIsPafNfce	:= STBPafNfce()					//Usa NFC-e com PAF ?
static aOrcFilDel	:= {} //Guarda Orcamentos Filhos que devem ser excluidos 
Static aIdPgtoMfe	:= {}													//Array com o retorno dos pagamentos enviados ao VFPe
Static lMFE			:= IIF( ExistFunc("LjUsaMfe"), LjUsaMfe(), .F. )		//Se utiliza MFE
Static lLjRspFisc	:= ExistFunc("LjRspFisc")
Static lLjEnvPgto	:= ExistFunc("LjEnvPgto")
Static cSiglaSat	:= IIF( ExistFunc("LjSiglaSat"),LjSiglaSat(), "SAT" )	//Retorna sigla do equipamento que esta sendo utilizado
Static lMsgChkNFS	:= .F.

//Este DEFINE deve ser obrigatoriamente o ultimo a ser declarado pois se for declarado
//antes dos outros os demais nao sao identIficados. ***VerIficar com a Tecnologia***
//Este Log é um recurso a ser habilitado pelo departamento de desenvolvimento para averiguação 
//de possíveis problemas de transações TEF.
#DEFINE LOG_TEF  Lj7GetLog()

//Defines para tratamento do Array aItens utilizado pela funcao LJ7RecTrib.
#DEFINE __RECNO		01
#DEFINE __ITEM		02
#DEFINE __QUANT		03
#DEFINE __VRUNIT	04
#DEFINE __VLRITEM	05
#DEFINE __DESCPRO	06
#DEFINE __DESCFIN	07
#DEFINE __ACRSFIN	08
#DEFINE __LIVRE		09 // POSICAO LIVRE PARA USO
#DEFINE __PREMIO	10
#DEFINE __PRCTAB	11
#DEFINE __TES		12
#DEFINE __PRODUTO	13
#DEFINE __DESCITEM	14
#DEFINE __VALIPI	15
#DEFINE __ENTREGA	16
#DEFINE __TOTIMP	17 // Valor de Imposto NCM / NBS
#DEFINE __NLOTE		18 // L2_NLOTE
#DEFINE __LOTECTL	19 // L2_NLOTE
#DEFINE __TOTIMPFED	20 // Valor de Imposto Federal
#DEFINE __TOTIMPEST	21 // Valor de Imposto Estadual
#DEFINE __TOTIMPMUN	22 // Valor de Imposto Municipal
#DEFINE __ARRED		23 // Posicao logica para saber se teve ou nao arredondamento
#DEFINE __FRETE		24 // Posicao Valor de Frete

Static aCrdCliente 	:= {"",""}				//Informacao do cliente p/Private Label [1]-CNPJ/CPF [2]-Numero do Cartao Private Label
Static aRecCrd     	:= {}                   //Array com as parcelas do financiamento impressas no comprovante de financiamento
Static cContrato                           	//Numero do contrato de financiamento
Static aContratos  	:= {}          			// Numero de contrato gerado pela venda. Utilizado nos casos em que deve cancelar o contrato pendente
Static lAvalBotao  	:= .F.                 	//Controla se a avaliacao de credito ja foi acionada pelo botao da toolbar
Static aContraTmp  	:= {}                  	//Array com os numeros do contrato de financiamento(temporario), utilizado para cancelar
											//um contrato caso este nao seja associado a um orcamento ou venda
Static aInfMA7  	:= {}	                //Array com dados do MA7 para controle de "backup" caso o usuario nao confirme a operacao
Static aInfMAH  	:= {}                   //Array com dados do MAH para controle de "backup" caso o usuario nao confirme a operacao
Static aInfMAL  	:= {}                   //Array com dados do MAL para controle de "backup" caso o usuario nao confirme a operacao

//Variaveis utilizada no SELF-LIQUIDATE
Static aPremio		:= {}  					// Array com os premios resgatados pelo cliente
Static nTotPremio  	:= 0					// Total a pagar de Self-Liquidate
Static aLibera      := {}					// Array com os dados do responsavel pela liberacao do premio.
Static lCupFiscal	:= .F. 					// Controla se o cupom foi impresso
Static cTextoErro   := ""					// Armazena o texto contido no objeto do error.log para ser mostrado ao usuário
Static lTelaTefPed	:= .F.					// Controla se o retorno falso da função Lj7Pedido é da tela do TEF, e assim não será mostrado ao usuário nenhum erro
Static lTefCanc 	:= .F.					// Controla se o comando de desfazimento do Tef foi feito
Static lImpTefIpdv 	:= .F. 	    	        // Controla se a impressão do Cupom Tef foi feita para a modalidade IPDV
Static lFisLivro    := (SuperGetMV("MV_LJLVFIS",,1) == 2)	// Utiliza novo conceito para geracao do SF3
Static nValSubTot   := 0    	   	        // Controla o valor do subtotal se o tef ocorreu erro.


/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³Lj7GravacaoºAutor  ³Vendas Clientes    º Data ³  09/23/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Chama das funcoes de gravacao.                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³voi Lj7Gravacao( ExpN1, ExpN2, ExpN3 )                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpN1 - Incica se a funcao foi chamada via                  º±±
±±º          ³      1 - Salvar como orcamento                             º±±
±±º          ³      2 - Salvar como venda                                 º±±
±±º          ³      3 - Salvar como pedido                                º±±
±±º          ³ExpN2 - Indica a opcao escolhida na rotina (aRotina)        º±±
±±º          ³ExpN3 - Controle do semaforo (SX8)                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Rotina do aFuncoes via Loja701                              º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Lj7Gravacao(	nTipo	, nOpc		, nSaveSx8	, lSair			,;
						nHandle	, aDocDev   , lAtuData	, lTemTefPend	,;
						aTefBKP , lDefPagto , cLQFrete	, nVlrAcrsFi	,;
						cEspDoc	, cDocFo	, aDadosCNeg, lErroNFCe		,;
						lErroNFe )

Local lAutoExC 		:= IsBlind() 	// Verifica se a rotina sera executada via execauto ou nao
Local bProcGrv 		:= { || Nil }	// Bloco de execucao do processamento de gravacao

bProcGrv := {|| LJ7RunGrv(	nTipo		, nOpc		, nSaveSx8	, @lSair		,;
							nHandle		, aDocDev   , lAtuData	, @lTemTefPend	,;
							@aTefBKP	, lDefPagto	, cLQFrete	, nVlrAcrsFi	,;
							cEspDoc		, cDocFo	, aDadosCNeg, @lErroNFCe	,;
							@lErroNFe ) }

If !lAutoExC
	FWMsgRun( Nil , bProcGrv, "Processando..." , "Aguarde...Processando orcamento " + M->LQ_NUM )
Else
	Eval(bProcGrv)
EndIf

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ LJ7RunGrv ºAutor  ³Vendas Clientes    º Data ³  09/23/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Chama das funcoes de gravacao.                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³voi LJ7RunGrv( ExpN1, ExpN2, ExpN3 )                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpN1 - Incica se a funcao foi chamada via                  º±±
±±º          ³      1 - Salvar como orcamento                             º±±
±±º          ³      2 - Salvar como venda                                 º±±
±±º          ³      3 - Salvar como pedido                                º±±
±±º          ³ExpN2 - Indica a opcao escolhida na rotina (aRotina)        º±±
±±º          ³ExpN3 - Controle do semaforo (SX8)                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Rotina do aFuncoes via Loja701                              º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LJ7RunGrv(	nTipo	, nOpc		, nSaveSx8	, lSair			,;
						nHandle	, aDocDev   , lAtuData	, lTemTefPend	,;
						aTefBKP , lDefPagto , cLQFrete	, nVlrAcrsFi	,;
						cEspDoc	, cDocFo	, aDadosCNeg, lErroNFCe		,;
						lErroNFe )

Local lReserva 		:= .F.																		// Controla se eh uma venda com reserva
Local lFinalizou 	:= .F.																		// Controle para ver ser a venda foi ou nao finalizada.
Local lRet			:= .T.																		// Retorno do ponto de entrada LJ7001
Local lFinanceiro 	:= .T.																		// Indica se gera movimentacao financeira
Local nPosProd		:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_PRODUTO"})][2]	// Posicao da codigo do produto
Local nPosDesc		:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_DESCRI"})][2]		// Posicao da Descricao do produto
Local nPosQuant		:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_QUANT"})][2]		// Posicao da Quantidade
Local nPosVlrItem   := aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_VLRITEM"})][2]	// Posicao do Valor Total do Item
Local nPosDtReserva	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_RESERVA"})				// Posicao do codigo da reserva
Local nPosEntrega   := aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_ENTREGA"})][2]
Local nPosDtLocal  	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_LOCAL"})				// Posicao do local (armazem)
Local nPosTes		:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_TES"})					// Posicao da TES
Local nPosQtd	  	:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_QUANT"})][2]		// Posicao da Quantidade
Local cCondPad      := SuperGetMV( "MV_CONDPAD" )												// Condicao de pagamento padrao
Local cConfCli      := SuperGetMV( "MV_CONFCLI" ) 												// Utiliza configuracoes do cliente
Local cCond         := ""                      													// Condicao de pagamento DEFAULT utilizada
Local nX 			:= 0																		// Variavel auxiliar
Local lEstNeg		:= (SuperGetMv("MV_ESTNEG") == "S")											// Indica se permite ou nao estoque negativo
Local cMsg			:= ""																		// Mensagem com o codigo e o produto
Local lTrocoLoc     := .F.																		// Valida se tem troco
Local nDecsTroco    := 0																		// Decimais do troco
Local aAreaMAD      := {}																		// Salva area do MAD
Local cMay          := ""																		// Codigo que sera utilizado para a gravacao do endereco do Consumidor Final
Local nTent			:= 0																		// Numero de tentativas, para gerar numero sequencial
Local nTotGeral     := 0																		// Soma total geral
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local lFisNota      := (SuperGetMV("MV_FISNOTA",,.F.) .OR. lFtvdVer12)		 					// Parametro que habilita (.T.) a emissao de NF na venda
Local lEmiteNF      := .F.   																	// Flag para emissao de NF na venda
Local nDocSai       := 1     																	// Variavel para controle do documento emitido: 1=Cupom;2=Nota;3=Retorna a venda
Local nI			:= 0     																	// Variavel auxiliar
Local cEstCob 		:= SM0->M0_ESTCOB															// Estado de cobranca do SIGAMAT.EMP porque e o estado onde o cliente Microsiga sera tributado.
Local lUsafd      	:= SuperGetMV("MV_LJUSAFD",,.F.) 											// Utiliza Fidelizacao de cliente ??
Local cGrupoProd	:= ""																		// Grupo de produto
Local aProdCri		:= {}																		// Array com os produtos para analise de criterio de pontos
Local nPosVlItem    := aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_VLRITEM"})][2]	// Posicao do Valor Total do Item
Local lPagVale 		:= .F. 																		// VerIfica se utilizou vale compra para pagamento de contas
Local lLog1       	:= SubStr(LJGetProfile("LOGERRO"),1,1) == "S" 								// Tem Log de Erro
Local lLog4         := SubStr(LJGetProfile("LOGERRO"),4,1) == "S" 								// Log de Recuperacao, grava as parcelas
Local nTroco		:= 0																		// Valor do troco
Local nTotPgtos		:= 0																		// Soma o total do array a Pgtos
Local lLJ7042		:= .T.																		// Retorno do ponto de entrada LJ7042()
Local lFTVD7042		:= .T.																		// Retorno do ponto de entrada FTVD7042()
Local cMvCrdForm	:= SuperGetMV("MV_CRDFORM",,"VA") 											// Forma de pagamento nao considerada na pontuacao do CRD
Local cMvSimb		:= SuperGetMV("MV_SIMB"+Alltrim(STR(nMoedaCor)))							// Variavel que recebe o parametro MV_SIMB1
Local lAutoExC 		:= IsBlind()																// Verifica se a rotina sera executada via execauto ou na
//Array para tratamento de Consumidor Final - Loc. Argentina
Local aDadosCF    	:= {}      																	//Dados do Cupom Fiscal
Local nUsado	  	:= 0																		//Pontos usados no resgate de premios
Local nTotPontos  	:= 0
Local cMV_CLIPAD	:= PadR(SuperGetMV("MV_CLIPAD"),TAMSX3("LQ_CLIENTE")[1])					// Cliente padrao
Local cMV_LOJAPAD	:= PadR(SuperGetMV("MV_LOJAPAD"),TAMSX3("LQ_LOJA")[1])   					// Loja do cliente padrao
Local cPgVc 		:= ""																		// Informa que houve pagamento com vale-compra
Local nPag			:= 0																		// Total de pagamento dIferente de vale-compra
Local nParamTipo    := 0                                                                        // Parametro do PE LJ7001
Local lRetPedido	:= .F.																		// IdentIfica se o pedido foi gravado corretamente
Local cDoc			:= Space(TamSx3("L1_DOC")[1])												// Numero do cupom fiscal
Local cPdv			:= Space(TamSx3("L1_PDV")[1])												// Numero do equipamento
Local cSerie 		:= ""																		// Serie do documento
Local lTefOk	    := .F.																		// Valida se o TEF foi OK
Local aReb     		:= {}
Local aParcTef 		:= {}
Local lMsgTEF		:= .F.																		// Identifica se deve mostrar a mensagem de tef para cancelamento
Local lLibEmiteNF   := .F.                                                                  	// Controla se esta liberado para emitir apenas NF
Local nAcrescimo	:= 0																		// Acrescimo da venda
Local nSubTotal		:= 0																		// Sub-Total da venda
Local nVlrParcelas	:= 0 																		// Total das parcelas
Local lPrepOrc		:= .F. 																		// Verifica se o orcamento foi gravado com sucesso
Local nTotParcs		:= 0																		// Total de parcelas convertida para a moeda corrente
Local nDIf          := 0                                                                    	// Diferenca entre o valor da venda e de parcelas
Local nTPCompNCC    := SuperGetMV("MV_LJCPNCC",,1)												// Tratamento para compensacao de NCC 1-Compensacao atual 2 - Nova Compensacao
Local lEmisNF		:= (LjEmiteNF(SM0->M0_CGC,lLibEmiteNF) .OR. lFtvdVer12) 					// Verifica se a empresa se enquadra na LjEmiteNF
Local cNumSerie 	:= Space(TamSx3("LG_SERPDV")[1])											// Numero de serie do PDV
Local nRet			:= 1																		// Retorno da funcao da dll
Local lImpNfArg		:= .F.																		// Valida se pode ser imprimir NF (Localizado Argentina)
Local cTipoCli		:= ""                                                                       // Tipo do Cliente
Local cCondSA1		:= ""                                                                       // Condicao de pagamento do Cliente
Local lUsafdOff		:= SuperGetMV("MV_FRTCRD",,.F.)                                             // Verifica se crd é off Line
Local oSWB			:= Nil																		// Faz baixa crd
Local nPontos 		:= 0 																		// Numero de pontos CRD
Local cCGCCli		:= ""																		// CGC do cliente selecionado
Local cNomeCli		:= ""																		// Nome do cliente slecionado
Local lNfManual		:= .F.																		// Nota fiscal manual
Local lImpReserva	:= .F.																		// Se irá emitir cupum de itens de reserva quando orçamento filho
Local nFatorRes		:=	1 																		// Fator reserva
Local nFatorVen		:=	1																		// Fator venda
Local nTotalCF		:= 0																		// Valor total do Cupom Fiscal (diferente da NF)
Local nFlagLegSP	:= 0																		// Flag que indica qual tipo de aviso sera dado no controle da legislacao paulista que bloqueia CF em 10.000,00
Local lExLegSP10	:= ExistFunc("Lj950SP10OK")											   		// Verifica a existencia da funcao que valida a legislacao paulista que limita o cupom fiscal em 10.000,00
Local lExTotalCF	:= ExistFunc("LJXTotalCF")								   			  		// Verifica a existencia da funcao que calcula o total do cupom fiscal
Local lTefManuPed	:= .T.																		// Verifica se utiliza TEF Manual e se será executado o cancelamento da venda qdo pedido.
Local nDescontFi    :=  0																		// Valor do Desconto Finaceiro (Configurado na condicao de pagamento)
Local lDscCupTef	:= .F.																		// Indica se o Cupom TEF Discado ja foi impresso
Local lVerEmpres    := Lj950Acres(SM0->M0_CGC)													// Verifica as filiais da trabalharam com acrescimento separado
Local lAtivaMn		:= SuperGetMV("MV_LJMULTN", , .F.)											// Ativa Multi Negociacao
Local lLjIcmJr		:= SuperGetMv("MV_LJICMJR", , .F.)											// Não incide ICMS sobre Juros
Local lRetaPaf		:= LjNfPafEcf(SM0->M0_CGC) .And. !lMvljpdvpa 								// Sinaliza Retaguarda PAF-ECF
Local cNumOrc		:= M->LQ_NUM																// Numero do orcamento
Local aParcEnviar	:= {}																		// Itens para enviar para parceiros
Local lLJ7083		:= ExistBlock("LJ7083")														// Indica se o PE LJ7083 esta compilado
Local nAux			:= 0																		// Variável numérica auxiliar

//Release 11.5 - Localizacao Chile - F1CHI
Local cDescEspFo	:= ""																		//Descricao da especie de documento fiscal selecionada no inicio da venda
Local cSigEspFo		:= ""																		//Sigla da especie de documento fiscal selecionada no inicio da venda

//Lista de Presentes
Local lLstPresAt    := SuperGetMV("MV_LJLSPRE",.F.,.F.) .AND. IIf(ExistFunc("LjUpd78Ok"),LjUpd78Ok(),.F.)
Local nOpcProc		:= 0																		// Numero da Operacao
Local cDocPed		:= ""
Local cSeriePed		:= ""
Local lAlteraPrc    := .F.                                                                      // Controle de alteração das parcelas para nTipo == 4
Local lIntGC 		:= .T.
Local nTotICM		:= 0

//Instituto Arredondar	- Doação
Local nArredondar	:= 0																		// Valor para doação
Local lArredondar	:= SuperGetMv("MV_LJINSAR",,.F.)											// Parâmetro para ativar o Instituto Arredondar

//Tratamento para eCommerce
Local lECommerce 	:= SuperGetMV("MV_LJECOMM",,.F.) .And. ExistFunc("LJ862ECAuto") .And. LJ862ECAuto()
Local lGE		 	:= ExistFunc("LjUP104OK") .AND. LjUP104OK() 						// Validação do Conceito Garantia Estendida
Local lMvLjIPEn	 	:= SuperGetMV("MV_LJIPENP",, .F.)
Local nPosDtVLIPI	:= 0  //Valor do IPI Calculado pelo sistema
Local nValIPI	 	:= 0  //Valor Residual do IPI  = Valor do IPI Calculado pelo sistema - valor do IPi descontado da tabela
Local nPrecoTab	 	:= 0  //Preço do Item
Local nIPIDesc  	:= 0   //Valor Total do IPI Descontado
Local cRet			:= " " //Texto retornado pelo ECF
Local lIntegDef		:= If(Type("lAutoExec") == "L", lAutoExec, .F.) .And. FWHasEAI("LOJA701",, .T., .T.) .AND. IIF( ExistFunc("Lj701GtInD") , Lj701GtInD(), IsInCallStack("LOJI701"))  //Integracao via Mensagem Unica
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local lEmitNFCe		:= (!lFtvdVer12 .Or. lIntegDef) .AND. LjEmitNFCe()			// Sinaliza se utiliza NFC-e
Local aBkpTable	 	:= {}
Local lIntSynt 	 	:= SuperGetMV("MV_LJSYNT",,"0") == "1"	 // Informa se a integracao Synthesis esta ativa
Local lECiaIPI		:= ExistFunc("LJ901AIPI") .And. LJ901AIPI() //Venda e-commerce CiaShop com IPI
Local lMVLJLBNT 	:= SuperGetMv("MV_LJLBNT",,0) > 0//Habilita Finalizar Venda - Vide doc:http://tdn.totvs.com.br/display/PROT/TUXK67_DT_Disponibilizar_Emissao_Nota_Fiscal_Interestadual_Venda_Assistida
Local cLJRESER 		:= SuperGetMV("MV_LJRESER ",,"1") //Controla como será realizada a reserva de produtos da venda. 1=Ao pressionar o botão F11; 2=Na gravação do orçamento; 3=Na gravação da venda.
Local lTemItemRes	:= .F. //Indica se tem item que necessita de reserva
Local aNotaCanc  	:= {}
Local cDocCanc 		:= ""
Local cSerieCanc 	:= ""
Local cModDoc 	 	:= ""
Local cOperador  	:= ""
Local aLJRESERV  	:= {}
Local cBkpFilAnt 	:= cFilAnt //Faz Backup da Filial Atual, caso ocorrer algum erro durante a transacao, retorna para a filial corrente
Local nRecnoSM0  	:= SM0->(RecNo())  // Guarda a posicao do SM0
Local bProcessa 	:= Nil
Local cTxtNFis	 	:= ""
Local cLOGTEFBKP 	:= ""
Local nMNCC      	:= 0    // Posicao do Cartao de Credito no aPgtos para Mult-Negociacao
Local lMultNeg  	:= SuperGetMV("MV_LJMULTN", , .F.)		// Ativa Multi Negociacao
Local aRetInfDocCli := {}
Local lFretAlt		:= .F.
Local cMsgLock		:= STR0206 //"Usúario nao definido"
Local lLOJRREC		:= ExistFunc("LOJRREC")				// Relatorio de impressao de Recibo (OBSOLETO)
Local lULOJRREC		:= ExistFunc("U_LOJRRecibo")			// Relatorio de impressao de Recibo (RDMAKE)
Local lIMPLJRE		:= SuperGetMV("MV_IMPLJRE",,.F.)		// Ativa impressão de recibo de pagamento, requer UPDLO166
Local aTitBx		:= {}	//Array contendo o título incluido para impressao do Recibo de Pagamento
Local aFormPg		:= {}	//Array contendo a forma de pagamento RA para impressao do Recibo
Local lIMPLJRE		:= SuperGetMV( "MV_IMPLJRE" , .F. /*lHelp*/, .F. /*cPadrao*/)	//Ativa impressão de recibo de pagamento, requer UPDLO166
Local cMvLjPref		:= SuperGetMV("MV_LJPREF")  			//Regra para gravacao do SF2->F2_PREFIXO
Local cNumDoc 		:= ""	//Numero do documento no financeiro
Local cPrefixo		:= "" 	//Prefixo do documento no financeiro
Local lUseSAT 		:= IIF(ExistFunc("LjUseSat"), LjUseSat(), .F.)
Local cMsgErro		:= ""	//Mensagem de Erro vinda do Lj7GrvVenda()
Local xMvLjTxNFe 	:= 0	//Verifica se a funcionalidade de transmissao da NF-e está habilitada
Local lPergNFCup	:= .F.	//indica se já fez a pergunta "Nota ou Cupom"
Local aDocSaida		:= {}	//[1] Tipo do Doc de Saida 1/2/3 [2] permite emissao de NF
Local aDocReti		:= {}	//Guarda informacoes do orcamento retira finalizado.
Local aRetPbm		:= {}   //Retorno dos dados retornados do PBM Funcional Card
Local lMaFisSave	:= .F.  //Indica se gerou backup dos arrays da MatxFis, para posteriormente restaurar o backup para poder esvaziar o array de backup da MatxFis

//Tratamento para efetuar o fechamento da tela
Default lSair	  	:= .F.
Default aDocDev   	:= {}
Default lDefPagto   := .F.   		// Se .T. passou pela tela de definição de pagamento
Default cLQFrete    := ""			// Recebe valor do campo LQ_TPFRET 0- Sem Frete 1- CIf 2- FOB
Default cEspDoc		:= ""			//Especie do documento
Default cDocFo		:= ""
Default aDadosCNeg	:= {}
Default lErroNFCe 	:= .F.
Default lErroNFe 	:= .F.


//Validação para não gravar orçamento quando utilizar PBM Funcional Card, pois depende de informações reservadas pelo TEF.
If nTipo == 1 .And. ExistFunc("LJGDadosVL")
	aRetPbm := LJGDadosVL()
	If Len(aRetPbm) > 2 .And. aRetPbm[3] == 2 
		MsgStop(STR0211) //"A venda possui itens do PBM Funcional Card, não será possível salvar como orçamento."
		Return Nil
	EndIf
EndIf

If !lAutoExC
	SL1->(DbSetOrder(1)) //L1_FILIAL+L1_NUM
	SL1->(DbSeek(xFilial("SL1")+M->LQ_NUM))
EndIf

/*
- Conversao do valor do parametro MV_LJTXNFE -
A principio, esse parametro foi criado com o tipo Logico,
porem foi transformado em numerico para aumentar o numero de opcoes.
*/
xMvLjTxNFe := SuperGetMV("MV_LJTXNFE",,0)
If ValType(xMvLjTxNFe) == "L"
	If xMvLjTxNFe
		xMvLjTxNFe := 1	//Somente realiza a transmissao da NF-e
	Else
		xMvLjTxNFe := 0
	EndIf
	LjGrvLog( SL1->L1_NUM, "Houve a conversao do parametro MV_LJTXNFE", xMvLjTxNFe )
EndIf



// Quando chamado com nTipo == 4 será lAlteraPrc setada true, pois todo o tratamento será igual ao tratamento de inclusão e
// apenas na gravação será tratado de maneira diferente.
If nTipo == 4 .AND. lFtvdVer12
	nTipo := 1
	lAlteraPrc := .T.
EndIf

LjGrvLog(cNumOrc,"PRESSIONOU F5")
LjGrvLog(cNumOrc,"INICIO DE FINALIZACAO DA VENDA",nTipo)
lCupFiscal	:= .F.

//Rotinas especificas para ECF, Nfc-e trabalha com Impressora Nao Fiscal
If !lEmitNFCe .Or. lIsPafNfce
	If lFiscal .AND. cPaisLoc == "BRA"

		// Verifica se o status da impressora esta ok
		nRet := IFStatus(nHdlECF, "9", @cRet)
		If nRet <> 0
			MsgStop(STR0115)	// "Erro de comunicação com a impressora fiscal."
			Return NIL
		EndIf

		// Retorna numero de serie da impressora
		nRet := IFPegSerie(nHdlECF, @cNumSerie)

		If !AllTrim(UPPER(cNumSerie)) == AllTrim(UPPER(LJGetStation("LG_SERPDV")))
			MsgStop(STR0116)	// "O número de Série do equipamento é diferente do cadastrado na estação."
			Return NIL
		EndIf
	EndIf

	If !LjEcfXData()
		Return NIL
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o cliente esta alocado para outro usuario , caso esteja   	³
//³ nao da procedencia a finalizacao da venda .								³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nTipo == 2
	SA1->(DbSetOrder(1))
	If ( M->LQ_CLIENTE + M->LQ_LOJA <> cMV_CLIPAD + cMV_LOJAPAD ) .AND. SA1->( DbSeek( xFilial("SA1") + M->LQ_CLIENTE+M->LQ_LOJA ) )
		If !Empty(M->LQ_CLIENTE)
			cTipoCli := M->LQ_TIPOCLI
		Else
			cTipoCli := SA1->A1_TIPO
		EndIf
		cCondSA1 := SA1->A1_COND
		cNomeCli := SA1->A1_NOME
		cCGCCli	 := SA1->A1_CGC
		If SA1->A1_COD+SA1->A1_LOJA <> cMV_CLIPAD+cMV_LOJAPAD
			If SA1->(Rlock())
				SA1->(SoftLock('SA1'))
			Else

			  	If TCGetConn() >= 0
			    	cMsgLock := TCInternal(53)
			    	IF !Empty(cMsgLock)
			      		cMsgLock := Chr(13)+Chr(10) + StrTran(STR0181+cMsgLock,"|",Chr(13)+Chr(10)+STR0182)   //"Usuário:"  ## | //" Função:"
			    	Endif
				EndIf

				If !lAutoExC
					Aviso(STR0007+", "+STR0129, STR0130+M->LQ_CLIENTE+STR0131+M->LQ_LOJA+STR0132+":"+cMsgLock, {STR0005}) 					//"Atencao"##"Impossível Finalizar"#"O Registro do Cliente: "#" está alocado por outro usuario do sistema."#"Ok"
					Return Nil //Nao permite gravar venda
				Else
					//Quando execAuto permite
					ConOut(STR0130+M->LQ_CLIENTE+STR0131+M->LQ_LOJA+STR0132+":"+cMsgLock) // O Registro do Cliente: está alocado por outro usuario do sistema.
					Help( " ", 1, "Help",, STR0130+M->LQ_CLIENTE+STR0131+M->LQ_LOJA+STR0132+":"+cMsgLock, 1, 0 )
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

If lSFinanc
    For nI:= 1 To  Len(aCols)
		MG8->(DbSetOrder(2))//MG8_FILIAL+MG8_PRDSB1
		If MG8->(DbSeek(xFilial('MG8')+aCols[nI][nPosProd] ))
			If nTipo == 1
				If LJVldCliSf()
					Return Nil
				EndIf
			Else
				Aviso(STR0007,STR0183,{STR0005}) //#"Atenção" ##"A venda de Serviços Financeiros não esta habilitada para interface Venda Assistida apenas para o Novo PDV." ###"Ok"
				Return NIL
			EndIf
		EndIf
    Next nI
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Quando DAV eh obrigatorio informar o CPF/CNPJ do cliente ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
// Se vier de lAutoexec, não é necessário checar DAV por causa da importação do uMov.me para o Sigaloja
If !lMvljpdvpa .AND. LjNfPafEcf(SM0->M0_CGC) .AND. !SuperGetMV("MV_LJPRVEN",,.F.) .AND.;
   Empty(SA1->A1_CGC) .And. !(AllTrim(SA1->A1_EST) == "EX") .AND.  !lFtvdVer12 .AND. (Type("lAutoExec") <> "L" .OR. !lAutoExec)

	If !lAutoExC
		MsgStop( STR0165 + Chr(13) + STR0166)	//"Conforme previsto no Resquisito VI(ATO COTEPE/ICMS 0608):"  //"Para realizar um DAV é necessário informar cliente com CPF/CNPJ"
	Else
		ConOut( STR0165 + STR0166)	//"Conforme previsto no Resquisito VI(ATO COTEPE/ICMS 0608):"  //"Para realizar um DAV é necessário informar cliente com CPF/CNPJ"
		Help( " ", 1, "Help",, STR0165 + STR0166, 1, 0 )
	EndIf

	Return NIL
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Valida Condicao de Pagto, necessario validar nesse momento caso pressione F5 durante o preenchimento da condicao ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !LJ7VldCond(M->LQ_CONDPG, @cDescCondPg, @oDescCondPg, @oPgtos, Nil, nOpc, @nVlrAcrsFi)
	Return NIL
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Release 11.5 - Controle de Formularios				 ³
//³Se for cliente padrao e a especie do formulario		 ³
//³for igual a FCT-FACTURA ou FCX-FACTURA EXENTA         ³
//³a venda sera abortada.                                ³
//³Paises:Chile/Colombia - F1CHI		  				 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lCFolLocR5
	nRecnoSFP := LjGRecFo()
	LjxDadosFo(nRecnoSFP,NIL,@cSigEspFo,@cDescEspFo)//Obter dados do controle/lote de formulario selecionado
	If (M->LQ_CLIENTE + M->LQ_LOJA == cMV_CLIPAD + cMV_LOJAPAD) .AND. (cSigEspFo=="FCT" .OR. cSigEspFo=="FCX") .AND. cPaisLoc == "CHI"
		If !lAutoExC
			MsgStop(STR0158 + cDescEspFo)//"Cliente padrao não permitido para documento fiscal do tipo "
		Else
			Conout(STR0158 + cDescEspFo)//"Cliente padrao não permitido para documento fiscal do tipo "
			Help( " ", 1, "Help",, STR0158 + cDescEspFo, 1, 0 )
		Endif
		Return NIL
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Desabilita SetKeys      									 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Lj7SetKeys(.F.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ VerIfica se eh finalizacao da venda. Se afirmativo, grava o ³
//³ status ORCMOK no arquivo de log.                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lLog1 .AND. lLog4 .AND. nHandle >= 0 .AND. nOpc == 4
	nSize    := FSeek( nHandle, 0, 2 )
	cRBuffer := Space( nSize )

	FSeek( nHandle, 0, 0 )
	FRead( nHandle, @cRBuffer, nSize )

	cRBuffer := Encript( cRBuffer, 1 )
	If !("#ORCMOK#" $ cRBuffer)
		cRBuffer := cRBuffer + "#ORCMOK#"
	EndIf

	FSeek( nHandle, 0, 0 )
	FWrite( nHandle, Encript( cRBuffer, 0 ) )
EndIf

//Caso for salvar como orçamento e tiver alterado o frete sem passar pela tela de pagamentos , atualiza o SL4
If nOpc == 4 .AND. nTipo == 1 .AND. GetFretAlt() .AND. !lDefPagto
	lFretAlt := .T.
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Caso a venda seja paga com NCC cria uma linha no aPgtos soh com a  ³
//³condicao de pagamento e data (o valor fica zerado)                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lFretAlt .OR. ( Len(aPgtos) == 1 .AND. IIF(Valtype(aPgtos[1][1]) == "D", aPgtos[1][1] == CtoD(Space(8)), aPgtos[1][1] == Space(8)) .AND. aPgtos[1][2] == 0 .AND. ;
Empty(aPgtos[1][3]) .AND. (nTipo == 1 .OR. nNccUsada > 0) )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Utiliza a condicao de pagamento DEFAULT do cliente, caso esteja habilitado para usa-lo³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cConfCli == "S"
		cCond := cCondSA1
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se a condicao estiver vazia, utilizar a condicao DEFAULT do parametro³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Empty( cCond ) .OR. nNCCUsada > 0
		cCond := cCondPad
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualizo campo de codigo de condicao de pagamento³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	M->LQ_CONDPG := cCond

	If nTipo == 1 //Gravar como Orcamento
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza a variavel do tipo STATIC no LOJA701B.prw³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Lj7lAtuCond( .T. )
	EndIf
	Lj7CondPg( 2, cCond,, ( ! nNCCUsada > 0 ))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ajusta a variavel na tela do Troco                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Lj7AjustaTroco()
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ VerIfica se foi efetuada alguma reserva, não realiza quando possui orçamento origem ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(SL1->L1_ORCRES)
	For nX := 1 to Len(aCols)
		If !Empty( aCols[nX][nPosEntrega]) .AND. aCols[nx][nPosEntrega] <> "2"
			lTemItemRes := .T.
			If !Empty(aColsDet[nX][nPosDtReserva])
				lReserva := .T.
				//se existe um item reservado entres os itens m abandona para não invalidar a regra de entrega
				Exit
			EndIf
		EndIf
	Next
Else
	lImpReserva := .T.
EndIf

LjGrvLog(cNumOrc,"Conteudo da variavel lTemItemRes",lTemItemRes)
LjGrvLog(cNumOrc,"Conteudo da variavel lReserva - Ponto 1",lReserva)

If lTemItemRes .And. !lReserva //Verifica se tem item que necessita de reserva e nao tenha sido ainda feito a reserva
	If (nTipo == 1 .And. cLJRESER == "2") .Or. (nTipo == 2 .And. cLJRESER == "3")
		LjGrvLog(cNumOrc,"Vai efetuar a reserva dos produtos",cLJRESER)
		If !LJ7BtnRes( 1 ) //Efetua a reserva dos produtos
			/* MICHAEL - add lReserva, pois em situações onde há uma rejeição de NFC-e, o controle de transação desarma ela, deixando o orçamento a ser finalizado novamente,
			nesse caso, o item já foi reservado na primeira tentativa (existe na SC0), entao o ponto de entrada nao vai realizar uma nova reserva */
			If ExistBlock("LJRESERV") //Se existir o Ponto de Entrada compilado, eh pq a reserva  deve ser feita pelo PE. Desta forma nao permite finalizar a venda.
				aLJRESERV := ExecBlock("LJRESERV",.F.,.F., {"3", Nil, Nil, Nil} )
				LjGrvLog(cNumOrc,"Retorno do PE LJRESERV",aLJRESERV)
				If aLJRESERV[1]
					lReserva := .T.
				Else
					MsgStop("A reserva dos produtos não foi realizada.")
					Return NIL
				EndIf
			EndIf
		Else
			lReserva := .T.
		EndIf
	EndIf
EndIf

LjGrvLog(cNumOrc,"Conteudo da variavel lReserva - Ponto 2",lReserva)

If cPaisLoc == "BRA"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Doação para Instituto Arredondar								³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lArredondar .AND. (LJ7T_Troco(2) > 0)
		nArredondar := LjxDDoeArredondar( LJ7T_Troco(2) )
	Elseif lArredondar .AND. aPgtos[1][3] $ "CC.CD"
		nAux		:= aPgtos[1][2]-NoRound(aPgtos[1][2],0)
		nArredondar := LjxDDoeArredondar( iif(nAux>0,1-nAux,nAux) )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento para emissao de NF na venda                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nTipo == 2
		If !lRecebe
			If lIntegDef //Tratamento Integracao para NFCe
				If lEmitNFCe
					lEmiteNF := .F.
				EndIf
			ElseIf !lFtvdVer12
				lEmiteNF :=	(LjNFFimVd() .OR.	;
							(nModulo == 5) .OR. ;
							(LjNfNoPaf(SM0->M0_CGC)) .OR.	;
							(LjNfPafEcf(SM0->M0_CGC) .AND. lMVLJLBNT .AND. LjNFFimVd()))
			ElseIf lFtvdVer12
				lEmiteNF := .T.
			EndIf

			//==============================================
			// Limitacao de 10.000,00 - Legislacao Paulista
			//==============================================
			If lExLegSP10 .And. lExTotalCF
				nTotalCF := LJXTotalCF(Nil, .T.)	 			// Recebe valor total do cupom fiscal considerando os descontos e acrescimos
				If !LjNFFimVd() .And. !Lj950SP10OK(nTotalCF, 0)
					If Lj950RegraNF(SM0->M0_CGC) .And. LjCanUseNF(SM0->M0_CGC)
						nFlagLegSP := 3							// Questiona se pode finalizar em NF
					Else
						nFlagLegSP := 1							// Bloqueia e exibe detalhes da legislacao
					EndIf
					If Lj950SP10OK(nTotalCF, nFlagLegSP)		// Pergunta se deseja prosseguir imprimindo na Nota Fiscal
						lEmiteNF := .T.			 				// Alterna variavel de controle para emitir a NF
						lEmisNF  := .T.			 				// Alterna variavel de controle para emitir a NF
					Else
						Lj7SetKeys(.T.)			  				// Retorna ao sistema
				    	Return Nil
					EndIf
				EndIf
			EndIf

			aPAFNotaCF := {}

			// Nota com Cupom Somente em Homologacao - e se a venda não for concomitante
			If LjNFPAFECF(SM0->M0_CGC) .And. STBHomolPaf() .And. !lEmiteNF .And. !(SM0->M0_ESTCOB $ "ES|BA|PB")
				
				// marca para fazer a pergunta de Nota ou Cupom
				lPergNFCup := .T.
			
				nDocSai := LjDocSaida()[1]
				If nDocSai == 2
				
					nDocSai := 1
					Aadd( aPAFNotaCF, {"S",.T.} )

					LjxDNota(	SuperGetMV("MV_LJSNCFP",,"61")	, 1							, .T.	, 1		,;
								@aPafNotaCF						, Space(TamSx3("D2_DOC")[1]), nil	, 1		,;
								999								, .F.						, ""	, Nil	,;
								TamSx3("D2_DOC")[1]				, .F.						)
			
					If Len(aPAFNotaCF) > 0
						cDoc := aPAFNotaCF[2][2]
					EndIf
				EndIf				
			
			ElseIf !lEmiteNF
					
				If !IsBlind() .AND. lMVLJLBNT .And. LjNfPafEcf(SM0->M0_CGC) .And. (!lMVLJPDVPA .Or. LjConcNota())

					If nDocSai <> 2 .And. (nDocSai := Aviso(STR0053,STR0054,{STR0055, STR0056, STR0058})) == 1 //"Documento Fiscal de Saida"##"Qual Documento Fiscal de Saida sera impresso na venda?"##"Cupom"##"Nota"##"Cancela"
						Aviso(STR0007,STR0202,{STR0005})//"Atencao"##"Em Ambiente Retaguarda PAF, concomitante ou não, a gravação de Venda via Cupom Fiscal, não será permitida."##"Ok"
						Lj7SetKeys(.T.)
						Return Nil
					ElseIf nDocSai == 3 .OR. !(lEmiteNF := LjNFFimVd(.T.,.F.,.T.,,,,,nDocSai)) //Altera para emissao de Nota Fiscal
			       		Lj7SetKeys(.T.)
						Return Nil
					EndIf
					
				EndIf					
			
				/* Se o usuario caixa nao tiver a permissao "Usuario é Fiscal", é necessário que a empresa tenha permissao de Emissao de NF) */
				If IIF( !lFISCAL, (lEmisNF .AND. !LjNFFimVd()), !LjNFFimVd() )
					
					//SIGAFAT OU
					//Permite NF no PAF-ECF OU					
					// Legislacao da UF de GO que verifica se todos os produtos sao do tipo Vacina, se SIM, permite emitir NF
					If nModulo == 5 .OR. ;
						LjNFNoPAF(SM0->M0_CGC) .OR. ;					
						lFisNota .AND. Lj950CliEmis(SM0->M0_ESTCOB, .T.) .And. !lEmitNFCe .And. !lIsPafNfce .And. !lRetaPaf

						//marca pra perguntar
						lPergNFCup := .T.
							
						//usuario faz a selecao do Documento de Saida
						aDocSaida := LjDocSaida()
		
						nDocSai := aDocSaida[1]
						lEmiteNF := aDocSaida[2]
						
						//se nao atendeu as permissoes para emissao de NF, retorna nulo
						If (nDocSai = 2 .AND. !lEmiteNF) .OR. nDocSai = 3
							Lj7SetKeys(.T.)	// Libera o uso dos botões que estao na coluna da direita
							Return Nil
						EndIf
					EndIf

				EndIf
			EndIf

			//³Emite NF³
			If lEmiteNF
				//³Nota fiscal³
				nDocSai := 2
			//³ Emite Cupom³
			Else
				//³Cupom Fiscal³
				nDocSai := 1
				If !lFiscal .AND. !lAutoExec   								// nao eh usuario fiscal
					Aviso(STR0007, STR0043, {STR0005})	//"Atencao"##"Para finalizar uma venda, e necessario que o usuario tenha permissäo para usar impressora fiscal."##"Ok"
	       			Lj7SetKeys(.T.)
	    			Return NIL
				EndIf
			EndIf
		Else
			If !lFiscal
				If !lEmisNF
					Aviso(STR0007, STR0043, {STR0005})	//"Atencao"##"Para finalizar uma venda, e necessario que o usuario tenha permissäo para usar impressora fiscal."##"Ok"
					//³ Habilita as teclas de atalho                                             ³
					Lj7SetKeys(.T.)
					Return NIL
				EndIf
			EndIf
		EndIf
	EndIf
Else
   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   //³ Estrutura do array aDadosCF     ³
   //³ 1-Numero do Doc. Cons. Final    ³
   //³ 2-Tipo do Doc. Cons. Final      ³
   //³ 3-Codigo da Provincia do Doc.   ³
   //³ Carteira de Identidade(CI)      ³
   //³ 4-Nome do cliente Cons. Final   ³
   //³ 5-Codigo do endereco            ³
   //³ 6-Endereco                      ³
   //³ 7-Venda Consumidor Final(logico)³
   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc == "ARG"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Caso o usuario nao seja fiscal, emite mensagem e nao³
		//³deixa finalizar a venda                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lFiscal .AND. nTipo == 2 .AND. !Lj7ImpNf(@lImpNfArg)
			Aviso(STR0007, STR0043, {STR0005})	//"Atencao"##"Para finalizar uma venda, e necessario que o usuario tenha permissäo para usar impressora fiscal."##"Ok"
			Lj7SetKeys(.T.)
			Return NIL
		EndIf

		aDadosCF  :={	Space(TamSX3("LS_DOCCF")[1]),"",Space(TamSX3("LS_TIPOCI")[1]),;
						Space(TamSX3("LS_CLIECF")[1]),GetSxeNum("MAD","MAD_CODEND"),;
						Space(TamSX3("MAD_END")[1]),.F.}

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Tela para indicar tipo e numero de documento quando consumidor ³
		//³final e venda maior que o determinado no parametro MV_LIMCFIS  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If	nTipo == 2 .AND. cTipoCli == "F" .AND.;
			Lj7T_Total(2) >= SuperGetMV("MV_LIMCFIS")

			//Exibe a tela para indicar o tipo e numero de documento quando consumidor final e
			//venda maior que o determinado no parametro MV_LIMCFIS.
	     	If !LjGetDocCF(@aDadosCF,nSaveSx8)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Habilita as teclas de atalho                                             ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Lj7SetKeys(.T.)
				Return Nil
	     	EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Gera o codigo que sera utilizado para a gravacao do endereco do consumidor final³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cMay := Alltrim( xFilial("MAD") ) + aDadosCF[5]
			FreeUsedCode()

			DbSelectArea("MAD")
			aAreaMAD := GetArea()
			DbSetOrder(1)

			While DbSeek( xFilial("MAD") + aDadosCF[5] ) .OR. !MayIUseCode( cMay )
				If ++nTent > 20
					MsgStop(STR0035)                 //"Nao foi possivel gerar numero sequencial de endereco corretamente."
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Habilita as teclas de atalho                                             ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					Lj7SetKeys(.T.)
					Return Nil
				EndIf

				While (GetSX8Len() > nSaveSx8)
					ConfirmSx8()
				End
				aDadosCF[5] := GetSxeNum("MAD","MAD_CODEND")
				FreeUsedCode()
				cMay := Alltrim( xFilial("MAD") ) + aDadosCF[5]
			End
			RestArea(aAreaMAD)
			aDadosCF[7] := .T.
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Valida se foi utilizado o troco localizado. Caso tenha sido utilizado verIfica se o troco ³
	//³foi atribuido na sua totalidade, caso contrario não permite que a venda seja encerrada    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SuperGetMV("MV_LJTRLOC")
		For nX := 1 To Len( aMoedas )
			nDecsTroco := MsDecimais(aMoedas[nX][06])

			If (aMoedas[nX][02] <> 0) .AND. (Round(aMoedas[nX][02],nDecsTroco) <> Round(aMoedas[nX][05],nDecsTroco))
				MsgAlert(STR0027)  //"Para que o orcamento/venda seja concluido e necessario que o troco seja totalmente informado ou que os valores ja atribuidos sejam zerados."
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Habilita as teclas de atalho                                             ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Lj7SetKeys(.T.)
				Return Nil
			Else

				If aMoedas[nX][02] <> 0 .AND. Lj7T_Troco(2) > 0
					MsgAlert(STR0027)  //"Para que o orcamento/venda seja concluido e necessario que o troco seja totalmente informado ou que os valores ja atribuidos sejam zerados."
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Habilita as teclas de atalho                                             ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					Lj7SetKeys(.T.)
					Return Nil
				EndIf

				If Lj7T_Troco(2) <> 0 .AND. (aMoedas[nX][03] <> 0)
					lTrocoLoc := .T.
				EndIf
			EndIf
		Next nX

		If !lTrocoLoc
			For nX := 1 To Len( aPgtos )

			    If Empty(aPgtos[nX][_FORMAPGTO])
			       Loop
			    EndIf

				If aPgtos[nX][_MOEDA] <> nMoedaCor .AND. Lj7T_Troco(2) > 0
					MsgAlert(STR0028) //"Existe uma ou mais parcelas com moeda dIferente da moeda corrente da venda. Por favor informe o valor a ser dado como troco, para que o orcamento/venda possa ser encerrado."
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Habilita as teclas de atalho                                             ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					Lj7SetKeys(.T.)
					Return Nil
				EndIf

				If !IsMoney(aPgtos[nX][_FORMAPGTO]) .AND. Lj7T_Troco(2) > 0
					MsgAlert(STR0029) //"Existe uma ou mais parcelas com forma de pagamento dIferente de dinheiro. Por favor informe o valor a ser dado como troco, para que o orcamento/venda possa ser encerrado."
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Habilita as teclas de atalho                                             ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					Lj7SetKeys(.T.)
					Return Nil
				EndIf
			Next nX
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Analise de credito do cliente selecionado                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nTipo == 2 .AND. !LJ7AvalCred(nTipo)[1]
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Habilita as teclas de atalho                                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Lj7SetKeys(.T.)
	Return Nil
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Faz as consistencias no aCols  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lRecebe .AND. !Lj7TudOk( nTipo )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Habilita as teclas de atalho                                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Lj7SetKeys(.T.)
	Return Nil
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ VerIfica se o caixa esta aberto, senao nao deixa finalizar a venda ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( nTipo == 2 ) .AND. !IsBlind() .AND. ( !ljCxAberto(.T.,xNumCaixa()) )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Habilita as teclas de atalho                                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Lj7SetKeys(.T.)
	Return Nil
EndIf

//Recalcula as parcelas
/*
 Multi Negociacao - Tratamento necessário para que não seja incidido o valor de juros da
 multinegociacao na venda (não seja impresso no cupom fiscal como acréscimo ). Porem este
 valor deve ser considerado no rodapé do Total da venda mas gravado separadamente no campo L4_ACRSFIN.
*/
If lRetaPaf .And. lAtivaMn .And. ( lVerEmpres .Or. (lLjIcmJr .And. cPaisLoc == "BRA" ) ).and. SL1->(Fieldpos("L1_CODMNEG")) > 0 .And. !Empty(SL1->L1_CODMNEG)
	For nX := 1 To Len(aPgtos)
		nVlrParcelas += aPgtos[nX][2]
		If Alltrim(Upper(aPgtos[nX][3])) == "FI"
			aPgtos[nX][2] := ( aPgtos[nX][2] - iIf(ValType(aPgtos[nX][9])=="N", aPgtos[nX][9], 0) )
		EndIf
	Next
	nMNCC := aScan(aPgtos,{|x| AllTrim(Upper(x[3])) == "CC"})
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//|Caso tenha MultNegociação e existir diferenca entre o Sub-total e o Total da venda   |
	//|essa diferenca eh o acrescimo do catao de credito que deve ser apresentado no cupom. |
	//|sub-Total     - Total da Venda                                                       |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nMNCC > 0
		nVlrAcrsFi += nVlrParcelas - aTotais[1][2]
	EndIf
	If nNCCUsada <= Lj7T_Total( 2) 
		Lj7T_Total( 2, nVlrParcelas + nNCCUsada)
	EndIf		
Else
	aEval( aPgtos, {|x| nVlrParcelas+=x[2] })
EndIf

nPosDtVLIPI := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_VALIPI"})
nValIPI := 0

If lEcommerce  .AND. lMvLjIPEn .AND. nPosDtVLIPI  > 0
	//Caso seja uma venda e-ecommerce com o valor do ipi embutido, somo o valor do IPI
	For nX := 1 to Len(aColsDet)

        	LjxeValPre(@nPrecoTab, 	aCols[nX][nPosProd], M->LQ_CLIENTE , M->LQ_LOJA,;
					nMoedaCor   , aCols[nX][nPosQtd] , , @nIPIDesc,;
					.T. )
			nIPIDesc  :=  ( nIPIDesc *  aCols[nX][nPosQtd])

	     //	Apura a diferença entre o valor do IPI calculado pelo Loja e o Valor do IPI descontado
		nValIPI += (aColsDet[nX][nPosDtVLIPI] - nIPIDesc)
	Next nX
	If nValIPI <> 0
		//ajusto o valor residual do IPI para não dar diferença entre o valor total e o total das parcelas
		Lj7T_Total( 2, Lj7T_Total( 2) -  nValIPI)
	EndIf
EndIf

Lj7T_TotPar(2, nVlrParcelas + nNCCUsada)
nDIf   := Lj7T_Total( 2 ) - Lj7T_TotPar( 2 )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Converte os valores do aPgtos para a moeda corrente da          ³
//³venda. Necessario isso para posteriormente realizar a comparacao³
//³entre o total da venda com o total das parcelas                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc <> "BRA"
	nTotParcs := Lj701CvPgt() + nNCCUsada
	nDIf      :=  Lj7T_Total(2) - nTotParcs
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Na Integração da Gestão de Concessionarias com o Venda Direta   ³
//³não é necessaria a validação de parcela                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (SuperGetMV("MV_VEICULO",,"N")) == "S" .AND. SL1->(FieldPos("L1_ORIGEM")) > 0 //esta integrado com GC
	If FindFunction("FGX_VLDATE")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//A funcao retornara .F. quando se tratar de um orçamento gerado	³
		// pelo atendimento de veiculos. Caso contrario, retornara .T.		³
		// Função FGX_VLDATE é originaria do modulo de veiculos				³
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		lIntGC := FGX_VLDATE( SL1->L1_NUM )
	EndIf
EndIf

If lIntGC .AND. !lIntegDef
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Critica se nao foi informado pagamento (qdo nao for orcamento) /   ³
	//³valida tbem as notas de credito                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (cPaisLoc == "BRA" .AND. Lj7T_TotPar(2) < Lj7T_Total(2) .AND. !lECiaIPI) .OR.;
	   (cPaisLoc <> "BRA" .AND. (nDIf > 0) .AND. ;
	   nDIf > (1 / (10 ^ MsDecimais(nMoedaCor)))) .AND. !lIntSynt

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ VerIfica se o cliente possui abatimento de ISS na venda - pois caso possua o valor³
		//³ total sera dIferente do pago													  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !LJ220AbISS(Nil, Nil, MaFisRet(,'NF_VALISS'))
			If lAutoExC
				Conout(STR0001)		//"O total de parcelas para pagamento é menor que o valor total da venda."
				Help( " ", 1, "Help",, STR0001, 1, 0 )  //"O total de parcelas para pagamento é menor que o valor total da venda."
				LjGrvLog(  SL1->L1_NUM,  "Troco " + cValTochar(SuperGetMV( "MV_LJTROCO", ,.F. ))  + ;
				" Valor do Troco  " + AllTrim( Transform( ( Lj7T_Troco(2) ), PesqPict( "SL1", "L1_VLRTOT",, nMoedaCor ) ) ))


				LjGrvLog(  SL1->L1_NUM,  STR0001 + " valor das parcelas " + ;
						 AllTrim( Transform( ( Lj7T_TotPar(2) ), PesqPict( "SL1", "L1_VLRTOT",, nMoedaCor ) ) ) + ;
						 " Valor da venda " +  AllTrim( Transform( ( Lj7T_Total(2) ), PesqPict( "SL1", "L1_VLRTOT",, nMoedaCor ) ) ))
			Else
				//"O total de parcelas para pagamento é menor que o valor total da venda.","Total das Parcelas - Total da Venda: "
				MsgStop( 	STR0001 + Chr( 13 ) + ;
							STR0104 + cMvSimb + " " + AllTrim( Transform( ( nDIf ), PesqPict( "SL1", "L1_VLRTOT",, nMoedaCor ) ) ) )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Habilita as teclas de atalho                                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   			Endif
			Lj7SetKeys(.T.)
			Return Nil
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³LOG TEF                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lAutoExC
	If !Empty(LOG_TEF)
		LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'LOJ701C'+Replicate('-',40))
	EndIf
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verfica se nao permite vender com o estoque negativo quando nao for orcamento³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lRecebe .AND. !lEstNeg .AND. nTipo <> 1 .AND. !lMVLJPDVPA
	cMsg := ""

	For nX := 1 to Len( aCols )
		If !aCols[nX][Len(aCols[nX])]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Somente verIfica o estoque caso nao tenha sido feita a reserva do produto ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Empty(aColsDet[nX][nPosDtReserva])

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de Entrada antes da verificacao de estoque no final da venda³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lLJ7083
					ExecBlock("LJ7083",.F., .F., {aCols[nX][nPosProd], aColsDet[nX][nPosDtLocal], aCols[nX][nPosQuant]} )
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Devo passar a quantidade de cada item e nao o total do produto, pois, na            ³
				//³funcao Lj7VerEst ja estou varrendo o acols e totalizando  a quantidade do produto   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !(Lj7VerEst( aCols[nX][nPosProd]	, aColsDet[nX][nPosDtLocal]	, aCols[nX][nPosQuant]	, .F.	,;
								nX					, aColsDet[nX][nPosTes] ))
					cMsg := cMsg + Alltrim(aCols[nX][nPosProd]) + "-" + Alltrim(aCols[nX][nPosDesc]) + " | "
				EndIf
			EndIf
		EndIf
	Next nX

	If !Empty(LOG_TEF)
		LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'VerIfica Estoque - N / N / ' + AllTrim(Str(nTipo)) + ' / ' + cMsg)
	EndIf

	If !Empty(cMsg)
		MsgStop(STR0002 + Chr(10) +; //"Não será permitido finalizar a venda pois os produtos abaixo não possuem saldo em estoque."
				Subst(cMsg,1,Len(cMsg)-3) )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Habilita as teclas de atalho                                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Lj7SetKeys(.T.)
		Return Nil
	EndIf
EndIf

nTroco := Lj7T_Troco(2)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Checagem do valor de credito ao cliente                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nNCCUsada > 0

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Soma os valores colocados na condição de pagamento.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    nTotGeral := 0
	aEval(aPgtos, { |x| nTotGeral += x[2] })
	nTotPgtos	:= nTotGeral
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Desconta o valor total da venda e os impostos (PIS/COFINS/CSLL).³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If LJ220AbISS()
		nTotGeral  := ( LJ7T_Total(2) - nTotGeral - ( LJPCCRet() + MaFisRet(,'NF_VALISS') ) )
	Else
		nTotGeral  := ( LJ7T_Total(2) - nTotGeral - ( LJPCCRet() ) )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Valida se existe troco e conteudo no aPgtos, signIfica que teve pagamento em dinheiro ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ao realizar o cálculo para saber o valor da nova NCC a gerar, ³
	//³considera o desconto além do troco maior que zero,            ³
	//³devido ao exemplo abaixo:                                     ³
	//³                                                              ³
	//³Primeira tela (produtos) da Venda Assistida                   ³
	//³Total de produtos 100,00                                      ³
	//³Desconto no Total 30,00                                       ³
	//³Total da venda 70,00                                          ³
	//³                                                              ³
	//³Com a alteração realizada, verIfica se o Troco é maior que    ³
	//³zero OU Desconto realizado maior que zero                     ³
	//³E total de parcelas igual a zero.                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( nTroco > 0 .OR. Lj7T_DescV(2) > 0 ) .AND. nTotPgtos == 0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Calcula a nova NCC a ser gerada. Substraindo o que ja foi usado de NCC com o que sobrou no nTotGeral.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nNCCGerada := Abs( nNCCUsada - nTotGeral )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Somente mostra a msg que ira restar um credito de NCC quando for     ³
	//³ finalizacao da venda (nTipo == 2). Quando for finalizacao do orcamen-³
	//³ to (nTipo ==1), faz o calculo para que o campo L1_CREDITO seja       ³
	//³ gravado apenas com o valor da NCC que sera utilizada (para o caso de ³
	//³ utilizacao parcial da NCC)                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( nNCCGerada > 0 .AND. nTipo == 2 ) .AND. ( ( nTPCompNCC <> 3 ) .AND. ( nTPCompNCC <> 4 ) ) .AND. !lMVLJPDVPA
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³VerIfica se pode gerar uma NCC  com o valor do saldo restante³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Substr(SuperGetMV("MV_USACRED"),1,1) == "S"
			If !lAutoExC
				Aviso(STR0003, STR0004 + SuperGetMV("MV_SIMB1") + " " + ;
				AllTrim(Transform(nNccGerada,PesqPict("SE1","E1_VALOR"))), {STR0005}) //"Nota de Crédito ao Cliente"###"Irá restar um crédito no valor de: "###"Ok"
			Else
				ConOut(STR0004 + SuperGetMV("MV_SIMB1") + " " + AllTrim(Transform(nNccGerada,PesqPict("SE1","E1_VALOR"))))
			EndIf
		Else
			If !lAutoExC
				MsgAlert(STR0105+STR0106)    //Não é possivel gerar uma Nota de Crédito com o valor restante ## VerIficar o parâmetro MV_USACRED
			Else
				ConOut(STR0105+STR0106)
				Help( " ", 1, "Help",, STR0105+STR0106, 1, 0 )
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Habilita as teclas de atalho         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Lj7SetKeys(.T.)
			Return Nil
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de entrada para validacao no final da venda (antes das gravacoes)  ³
//³ Envia como parametro o nTipo (1-orcamento  2-venda  3-pedido)            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inclusao de chamada de Ponto de Entrada - especIfico Template            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nTipo == 2 .AND. lReserva
   nParamTipo  := 3
Else
   nParamTipo  := nTipo
EndIf
If ExistTemplate("LJ7001") .AND. !lFtvdVer12
	lRet := ExecTemplate( "LJ7001", .F., .F., {nParamTipo, aDocDev, nDocSai,nOpc} )

	If !Empty(LOG_TEF)
		LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'P.E. LJ7001 - ' + If( lRet, 'S', 'N' ))
	EndIf

	If !lRet
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Habilita as teclas de atalho                                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Lj7SetKeys(.T.)
		Return Nil
	EndIf
EndIf
If ExistBlock("LJ7001") .AND. !lFtvdVer12
	lRet := ExecBlock( "LJ7001", .F., .F., {nParamTipo, aDocDev, nDocSai} )

	If !Empty(LOG_TEF)
		LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'P.E. LJ7001 - ' + If( lRet, 'S', 'N' ))
	EndIf

	If !lRet
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Habilita as teclas de atalho                                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Lj7SetKeys(.T.)
		Return Nil
	EndIf
EndIf

If ExistTemplate("FTVD7001") .AND. lFtvdVer12
	lRet := ExecTemplate( "FTVD7001", .F., .F., {nParamTipo, aDocDev, nDocSai,nOpc} )

	If !Empty(LOG_TEF)
		LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'P.E. FTVD7001 - ' + If( lRet, 'S', 'N' ))
	EndIf

	If !lRet
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Habilita as teclas de atalho                                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Lj7SetKeys(.T.)
		Return Nil
	EndIf
EndIf
If ExistBlock("FTVD7001") .AND. lFtvdVer12
	lRet := ExecBlock( "FTVD7001", .F., .F., {nParamTipo, aDocDev, nDocSai} )

	If !Empty(LOG_TEF)
		LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'P.E. FTVD7001 - ' + If( lRet, 'S', 'N' ))
	EndIf

	If !lRet
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Habilita as teclas de atalho                                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Lj7SetKeys(.T.)
		Return Nil
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ VerIfica se eh finalizacao da venda e se eh um orcamento feito por       ³
//³ outra loja. Se afirmativo fecha a venda sem gerar financeiro.            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nOpc == 4
	If !Empty(SL1->L1_ORCRES) .AND. !Empty(SL1->L1_FILRES)
		lFinanceiro := .F.
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se usa reserva sem estoque                   ³
//³ Para eCommerce deve gerar SC se nao houver estoque    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lMVLJPDVPA .AND. ((AllTrim(Str(SuperGetMv("MV_LJGERSC",,1))) $ "2|3") .OR. lECommerce)
	If ExistFunc("LA590GerSC")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Faz solicitacao de compras para itens da reserva sem estoque     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		LA590GerSC()
	Endif
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ VerIfica qual o tipo de gravacao devera ser feito                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If HasTemplate("OTC") .AND. nOpc == 4
	lReserva := .F.
EndIf

If nOpc == 4 .And. FindFunction("LjRecupTef")
	LjRecupTef(M->LQ_NUM,@lTemTefPend,@aTefBKP)
EndIf

If nTipo == 2 .AND. lReserva .AND. lFinanceiro

	If !Empty(LOG_TEF)
		LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Inicio Gravação - 2 / S / S')
	EndIf

	MaFisSave() //Salva os dados da venda atual

	LjGrvLog(cNumOrc,"VENDA COM ITEM DE ENTREGA")
	LjGrvLog(cNumOrc,"TEFs PENDENTES",aTefBKP)
	LjGrvLog(cNumOrc,"POSSUI TEF PENDENTE",lTemTefPend)
	LjGrvLog(cNumOrc,"FATOR DE RESERVA",nFatorRes)

	If Lj7PrepOrc( nOpc  	, nTipo		, nHandle	, lReserva	,;
			   	   lAtuData	)

		//Quando NFC-e com item de Reserva, existe controle de transacao, o CNPJ deve ser confirmado antes
		If (lEmitNFCe .OR. lIsPafNfce) .AND. !lAutoExec .And. !lEmiteNF
		 	aRetInfDocCli := {}
		 	aRetInfDocCli := LjxDCGC(Nil,Nil, , ,Lj7T_Total(2))
		EndIf

		bOldError := ErrorBlock( {|x| LjVerIfErro(x) } ) // muda code-block de erro

		Begin Sequence
			//Transforma o orcamento para pedido
			bProcessa := {|| Lj7Pedido(	aDadosCF	, nTipo		, nHandle		, @lTemTefPend	,;
									 	@aTefBKP	, NIL		, @nFatorRes	, @nFatorVen	,;
									 	NIL			, NIL		, cEspDoc		, cDocFo		,;
									 	nOpc		, @cDocPed	, @cSeriePed	, @lTefManuPed	,;
										@lDscCupTef , @aBkpTable, lEmiteNF 		, @cTxtNFis 	,;
										@aDocReti	, nVlrAcrsFi )}

			CursorWait()
			lRetPedido := Eval(bProcessa)
			CursorArrow()

			LjGrvLog(cNumOrc,"Retorno da Lj7Pedido",lRetPedido)

			If lRetPedido
				//MOTIVO DE DESCONTO
				Lj7GrvMotDesc("", "", M->LQ_NUM , "")

				//Tratamento de LISTA DE PRESENTES
				If ExistFunc("Lj843GrvMv") .AND. lLstPresAt .AND. lRetPedido
					nOpcProc := Lj843GrvMv(SL1->L1_NUM,cDocPed,cSeriePed)
				Endif
			Else

				//Volta o backup da Filial corrente.
				//No caso de ter gerado pedido em outra filial e ocorrer algum erro no meio da transacao a variaveil "cFilAnt" pode estar
				//com o seu conteudo trocado e ai o sistema retornaria com a filial diferente da filial que estava "logado" no sistema
				cFilAnt := cBkpFilAnt
				SM0->( dbGoTo(nRecnoSM0) )

				//Como não há Controle de Transação em DBF, utilizamos a função LJRLBCKDBF para que os registros sejam restaurados
				If lMVLJPDVPA
					LjRlBckDBF(aBkpTable)
					aBkpTable := {}
				Else
					// Resgata Informacoes antes de executar o "DisarmTransaction"
					If Len(aDocReti) >= 5
						cDocCanc 	:= aDocReti[1] 	//Resgata o numero da Nota
						cSerieCanc 	:= aDocReti[2] 	//Resgata o numero de serie da Nota
						cPDV 		:= aDocReti[3]
						cOperador 	:= aDocReti[4]
						cLOGTEFBKP 	:= aDocReti[5]  //Faz BackUp da informacao do campo LG_LOGTEF antes de efetuar o RollBack
					EndIf
					
					RecLock("SLG",.F.)
					SLG->LG_LOGTEF := cLOGTEFBKP //Grava o campo LG_LOGTEF
					SLG->(MSUNLOCK())
				EndIf

				If (lEmitNFCe .Or. lIsPafNfce) .And. !Empty(cDocCanc) .And. !Empty(cSerieCanc)
					//Pega o numero da NOTA para ser cancelada
					LjxDNota(cSerieCanc,3,.F.,1,@aNotaCanc)
					cDocCanc := aNotaCanc[1][2]

					If !lEmiteNF
						cModDoc := "65"
					Else
						cModDoc := "55"
					EndIf

					//Inclui na SLX a nota que ser enviada para cancelamento
					If ExistFunc("Lj7SLXDocE") .And. SLX->(ColumnPos("LX_MODDOC")) > 0
						Lj7SLXDocE(cModDoc, cDocCanc, cSerieCanc, cPDV, cOperador, Nil)
					EndIf
				EndIf
			EndIf

		Recover

			CursorArrow()
			SL1->(DbSkip(0)) //Executa o DbSkip(0) apenas para atualizar os dados carregados na tabela SL1, evitando assim a "leitura suja"

		End Sequence

		ErrorBlock( bOldError ) // Restaura rotina de erro anterior

		If !lRetPedido
		    If !lEmiteNF .AND. !lEmitNFCe .And. !lIsPafNfce
			    nRet := IfPegPDV( nHdlECF, @cPdv )
				If cPaisLoc <> "ARG"
					nRet := IfPegCupom( nHdlECF, @cDoc )
					cSerie 	:= LjGetStation("LG_SERIE")
				Else
					nRet :=	Lj7PegCupArg(nHdlECF, @cDoc )
				   cSerie   := Lj7SerArg()
				EndIf

			//Nota - A numeracao da Nota/Serie sera atribuida pela funcao LJGRVTUDO()
			Else
			    cPdv    := ""
			    cDoc    := ""
				cSerie  := ""
			EndIf

			lmsgTEF := .F.

			If cTipTef == TEF_CLISITEF
				For nI := 1 To Len( aPgtosSint )
					If AllTrim( aPgtosSint[nI][1] ) $ _FORMATEF
						lmsgTEF := .T.
					EndIf
				Next nI
			Else
				For nI := 1 to Len( aPgtos )
					If Alltrim( aPgtos[nI][3] ) $ _FORMATEF
						lmsgTEF := .T.
					EndIf
				Next nI
			EndIf

			If lTefManuPed
				Lj7CancVenda(STR0082, 	cDoc, 	cSerie, 	cPdv, .F., .F., Nil, cTextoErro, Nil, Nil, Nil, @aTefBKP, @lTemTEFPend)//"Erro na Gravação da Venda!"
			EndIf

		Else

			LjReAbreVA(nTipo, nOpc)
			If nOpc == 3
				While (GetSX8Len() > nSaveSx8)
					ConfirmSx8()
				End
			EndIf

			//Ajusta a variavel para indicar que finalizou a venda e chamar o ponto de entrada abaixo
			lSair	   := .T.
			lFinalizou := .T.
			nValSubTot := 0

			// Imprime
			If !Empty(cTxtNFis)
				nRet := 1
				While nRet <> 0
					nRet := INFTexto(cTxtNFis)

					If nRet <> 0
						If !MsgYesNo("Não foi possível imprimir o comprovante, tentar novamente?")
							nRet := 0
						EndIf
					EndIf
				End
			EndIf
		EndIf
	EndIf

	If !lRetPedido
		MaFisRestore() //Restaura os dados da venda atual, devido erro no processamento de gravacao. Para assim, permitir que a venda possa ser finalizada novamente.
	EndIf


ElseIf nTipo == 1

	If !Empty(LOG_TEF)
		LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Inicio Gravação - 1')
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se nao informou midia e for obrigatorio chama funcao para informar   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SuperGetMv("MV_LJRGMID",,0) == 2 .AND. ExistFunc("LjxValMid") .AND. LjxValMid()
		While Empty(M->LQ_MIDIA)
			M->LQ_MIDIA:= LjxGetMid(M->LQ_MIDIA)  // Midia
		End
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Salvar como orcamento                                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Lj7PrepOrc( nOpc		, nTipo		, Nil		, Nil		,;
				   lAtuData , @lDefPagto,,,,,, lAlteraPrc )
		If ExistFunc("LjTemGeraNOrc") .AND. !lAutoExC
    		lTemGeraNOrc := LjTemGeraNOrc()
 		Else
    		lTemGeraNOrc := .F.
    	EndIf

    	//Apresenta mensagem com numero de orcamento gerado quando utiliza rotina diferenciada para geracao do numero
    	If LjNfPafEcf(SM0->M0_CGC)
			If cPaisLoc == "BRA" .AND. lTemGeraNOrc
				If lAutoExC
					Conout(STR0109 + M->LQ_NUMORC)
				Else
     				LjMsgRun( STR0109 + M->LQ_NUMORC ,, { || Sleep(2000)} ) //"Gerado Orcamento "
				EndIf
			EndIf
		Else
			If LJAnalisaLeg(37)[1] .AND. lTemGeraNOrc .AND. !lAutoExC
				If lAutoExC
					Conout(STR0109 + M->LQ_NUMORC)
				Else
	   				LjMsgRun( STR0109 + M->LQ_NUM ,, { || Sleep(2000)} ) //"Gerado Orcamento "
				Endif
			EndIf
		EndIf
		LjReAbreVA(nTipo, nOpc)
		If nOpc == 3
			While (GetSX8Len() > nSaveSx8)
				ConfirmSx8()
			End
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ajusta a variavel para indicar que finalizou a venda e chamar o ponto de entrada abaixo³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lSair	   := .T.
		lFinalizou := .T.
		nValSubTot := 0
	EndIf
ElseIf nTipo == 2

	If !Empty(LOG_TEF)
		LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Inicio Gravação - 2')
	EndIf

	LjGrvLog(cNumOrc,"VENDA DE ITENS RETIRA")
	LjGrvLog(cNumOrc,"TEFs PENDENTES",aTefBKP)
	LjGrvLog(cNumOrc,"POSSUI TEF PENDENTE",lTemTefPend)
	LjGrvLog(cNumOrc,"FATOR DE RESERVA",nFatorRes)

	If !lFtvdVer12 .OR. (LJ7VldCond(M->LQ_CONDPG, @cDescCondPg, @oDescCondPg, @oPgtos, Nil, nOpc, @nVlrAcrsFi) .AND. lFtvdVer12)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Salvar como venda                                                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lFtvdVer12
			nTotICM := 0
		EndIf

		If (lEmitNFCe .Or. lIsPafNfce) .AND. !lAutoExec .And. !lEmiteNF .And. !lRecebe
		 	aRetInfDocCli:= {}
			aRetInfDocCli:= LjxDCGC(Nil,Nil, , ,Lj7T_Total(2))
			cCNPJ		:= aRetInfDocCli[1]
		EndIf
		
		//Caso seja obrigatorio informar o CGC e o usuario pressione em cancelar, desta forma a finalização da venda sera encerrada
		If ExistFunc("LjGetlCanc")
			//Pego o retorno da variavel statica lCgcCancel que esta presente no lojxfund
			lRet := !LjGetlCanc()

			//Restauro o conteudo da variavel Statica lCgcCancel que esta presente no lojxfund
			LjReslCanc()
		EndIf

		If lRet

			If MaFisFound("NF")
				//Guarda estado atual dos valores da MatxFis, caso ocrra algum erro na gravacao da venda, os valores da MaxFis precisam ser restaurados pela funcao MaFisRestore
				MaFisSave()
				lMaFisSave := .T.
			EndIf

			lRet := Lj7PrepOrc( nOpc  	, nTipo	, Nil			, Nil		,;
							lAtuData	, Nil	, @cNomeCli		, @cCGCCli	,;
							@lNfManual	,cEspDoc, @nDescontFi	, Nil		,;
							@nTotICM)	;
							.AND.;
					Lj7GrvVenda(lFinanceiro , NIL		, aDadosCF	, nHandle 		,;
							lEmiteNF    , nOpc		, nTipo		, @lTemTefPend	,;
							@aTefBKP 	, Nil    	, cLQFrete	, lAutoExC		,;
							nVlrAcrsFi	, cCgcCli	, cNomeCli	, lNfManual		,;
							lImpReserva , nFatorRes	, nFatorVen	, Nil			,;
							cEspDoc		, cDocFo 	, Nil 		, nDescontFi	,;
							@lDscCupTef	, nTotICM 	, aDadosCNeg, nArredondar 	,;
							@lErroNFCe	, Nil		, cTipoCli  , nSaveSx8		,;
							Nil			, @lErroNFe	, @cMsgErro )
		EndIf
		
		If lRet
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Tratamento de lista de presentes  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistFunc("Lj843GrvMv") .AND. lLstPresAt .And. SuperGetMv("MV_LJGRVON",,.F.)
				nOpcProc := Lj843GrvMv(SL1->L1_NUM)
			Endif

			If FindFunction("LjTemGeraNOrc")
				lTemGeraNOrc := LjTemGeraNOrc()
			Else
				lTemGeraNOrc := .F.
			EndIf

			If LjNfPafEcf(SM0->M0_CGC)
				If nOpc == 2 .AND. cPaisLoc == "BRA" .AND. lTemGeraNOrc
					If lAutoExC
						Conout(STR0109 + M->LQ_NUMORC)
					Else
						LjMsgRun( STR0109 + M->LQ_NUMORC ,, { || Sleep(2000)} ) //"Gerado Orcamento "
					EndIf
				EndIf
			Else
				If nOpc == 2 .AND. LJAnalisaLeg(37)[1] .AND. lTemGeraNOrc
					If lAutoExC
						Conout(STR0109 + M->LQ_NUM)
					Else
						LjMsgRun( STR0109 + M->LQ_NUM ,, { || Sleep(2000)} ) //"Gerado Orcamento "
					Endif
				EndIf
			EndIf
			LjReAbreVA(nTipo, nOpc)
			If nOpc == 3 .OR. (nOpc == 4 .AND. lFtvdVer12)
				While (GetSX8Len() > nSaveSx8)
					ConfirmSx8()
				End
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Ajusta a variavel para indicar que finalizou a venda e chamar o ponto de entrada abaixo³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			lSair	   := .T.
			lFinalizou := .T.
			nValSubTot := 0
		Else
			//------------------------------------------------------
			// Tratamento quando ocorrer algum problema na gravacao
			//------------------------------------------------------
			If (lEmitNFCe .AND. !lUseSAT) .Or. lIsPafNfce //Se utiliza NFC-e
				//-------------------------------------------------------------------------------
				// Resgata Informacoes do DOC e SERIE a ser cancelado devido ocorrencia de erro
				//-------------------------------------------------------------------------------
				cDocCanc 	:= SL1->L1_DOC 		//Resgata o numero do Documento a ser cancelado
				cSerieCanc 	:= SL1->L1_SERIE 	//Resgata o numero de Serie do Documento a ser cancelado
				cPDV 		:= SL1->L1_PDV
				cOperador 	:= SL1->L1_OPERADO

				//Inclui o DOCUMENTO na SLX para ser cancelado
				If !Empty(cDocCanc) .And. !Empty(cSerieCanc)
					If lErroNFCe .Or. !lEmiteNF
						cModDoc := "65"
					ElseIf lErroNFe .Or. lEmiteNF
						cModDoc := "55"
					EndIf

					//Inclui na SLX a nota que ser enviada para Inutilização
					If ExistFunc("Lj7SLXDocE") .And. SLX->(ColumnPos("LX_MODDOC")) > 0
						Lj7SLXDocE(cModDoc, cDocCanc, cSerieCanc, cPDV, cOperador, Nil, cMsgErro)

						//Limpa o DOC e Serie para que fique com status de orcamento em aberto e assim permita finalizar a venda novamente
						If RecLock("SL1",.F.)
							Replace SL1->L1_DOC with ""
							Replace SL1->L1_SERIE with ""
							Replace SL1->L1_KEYNFCE with ""
							Replace SL1->L1_SITUA with ""

							SL1->( MsUnLock() )
						Else
							LjGrvLog( cNumOrc, "Falha ao alocar o registro R_E_C_N_O_", SL1->(Recno()) )
						EndIf
						
						//"Devido problema na finalização da venda, o Documento/Série: " ### " foi enviado para cancelamento." + CTRL +CTRL + "Favor, reter o comprovante caso ele tenha sido impresso e, em seguida tente finalizar a venda novamente."
						MsgAlert(STR0203 + cDocCanc + " / " + cSerieCanc + STR0204 + CTRL +CTRL + STR0205)

					EndIf
				EndIf

			EndIf
		EndIf
	EndIf
EndIf

LjGrvLog(cNumOrc,"Finalizando a funcao LJ7RunGrv - Sair",lSair)

//
// Transmissão de NF-e pelo SIGALOJA
// Se for Nota Fiscal(L1_IMPNF = .T.), verifica se eh NF-e e esta apta para transmissao
//
If lFinalizou .AND. SL1->L1_IMPNF .AND. xMvLjTxNFe > 0 .AND. ExistFunc("LJAutoNFe")
	LjAutoNFe( SL1->L1_DOC, SL1->L1_SERIE, SL1->L1_CLIENTE, SL1->L1_LOJA )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Chamada da Funcao LJ7002 para Pontuacao no processo de Fidelizacao       ³
//³ Envia como parametro o nTipo (1-orcamento  2-venda  3-pedido)            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lFinalizou .AND. ExistFunc( "LJ7002()" ) .AND. !lFtvdVer12
	If (nTipo == 2) .AND.(lReserva)
		LJ7002(3)
	Else
		LJ7002(nTipo)
	EndIf
	LjGrvLog(cNumOrc,"Executou o P.E LJ7002")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Chamada da Funcao FTVD7002 para Pontuacao no processo de Fidelizacao       ³
//³ Envia como parametro o nTipo (1-orcamento  2-venda  3-pedido)            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lFinalizou .AND. ExistFunc( "FTVD7002()" ) .AND. lFtvdVer12
	If (nTipo == 2) .AND.(lReserva)
		FTVD7002(3)
	Else
		FTVD7002(nTipo)
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³VALE COMPRA - Se o sistema estiver configurado para trabalhar com Vale Compra,         ³
//³faz a chamada das rotinas  para somar pontos e também verIfica se o cliente tem direito³
//³a resgate de Vale.                                                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lFinalizou .AND. nTipo == 2

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de entrada para validar o cliente, se deve ou nao pontuar³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock("LJ7042") .AND. !lFtvdVer12
		lLJ7042	:=	ExecBlock( "LJ7042", .F., .F., { M->LQ_CLIENTE,M->LQ_LOJA } )
		If ValType( lLJ7042 ) <> "L"
			lLJ7042 := .T.
		EndIf
	EndIf

	If ExistBlock("FTVD7042") .AND. lFtvdVer12
		lFTVD7042	:=	ExecBlock( "FTVD7042", .F., .F., { M->LQ_CLIENTE,M->LQ_LOJA } )
		If ValType( lFTVD7042 ) <> "L"
			lFTVD7042 := .T.
		EndIf
	EndIf

	If CrdxInt() .AND. lUsaFd .AND. (M->LQ_CLIENTE+M->LQ_LOJA <> cMV_CLIPAD+cMV_LOJAPAD )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se o retorno do ponto de entrada LJ7042 for true, soma os pontos ³
		//³da venda para o cliente.                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If	(lLJ7042 .AND. !lFtvdVer12) .OR. (lFTVD7042 .OR. !lFtvdVer12)
			For nX := 1 to Len(aCols)
				If !aCols[nX][Len(aCols[nX])]
					cGrupoProd :=  Posicione("SB1",1,xFilial("SB1") + aCols[nX][nPosProd],"SB1->B1_GRUPO")
					AADD ( aProdCri, { aCols[nX][nPosProd], cGrupoProd , aCols[nX][nPosVlItem] , aCols[nX][nPosQtd]} )
				EndIf
			Next nX

			For nX := 1 to Len( aPremio )
				If aPremio[nX][2] == "3" .AND. aPremio[nX][5] > 0
					cGrupoProd :=  Posicione("SB1",1,xFilial("SB1") + aPremio[nX][3],"SB1->B1_GRUPO")
					AADD ( aProdCri, { aPremio[nX][3], cGrupoProd , aPremio[nX][5] } )
				EndIf
	     	Next nX

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Para pagamento com vale-compra deve ser calcula pontos    ³
			//³somente sobre a dIferença. se o pagamento for integral com³
			//³vale compra nao deve pontuar.                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nX := 1 to Len( aPgtos )
				If Alltrim( aPgtos[nX][3] ) $ cMvCrdForm
					cPgVc := "1"
				Else
					nPag	+= aPgtos[nX][2]
				EndIf
			Next nX

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Faz a chamada da funcao para calcular os pontos referente a venda.³
			//³A regra de pontuacao esta na tabela MAT.                          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lUsafdOff

				If Len(aPremio) > 0
					oSWB := WSFRTCRDBX():New()
					oSWB :_URL := "http://"+AllTrim(LJGetStation("WSSRV"))+"/FRTCRDBX.apw"

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Cria o array dentro do metodo ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					oSWB:oWSACRDVALEC:oWSVERARRBX 						:= FRTCRDBX_ARRAYOFWSCRDVABX():New()
					oSWB:oWSACRDVALEC:OWSVerArrBX:oWSWSCRDVABX 			:= Array( Len(aPremio) )

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Antes de chamar o metodo, atribui os valores ³
					//³as propriedades (passagem de parametros)     ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					For nX := 1 To Len(aPremio)

						oSWB:oWSACRDVALEC:OWSVerArrBX:OWSWSCRDVABX[nX] := FRTCRDBX_WSCRDVABX():New()

						oSWB:oWSACRDVALEC:OWSVerArrBX:OWSWSCRDVABX[nX]:NCRDPRE1			:=	aPremio[nX][1]
						oSWB:oWSACRDVALEC:OWSVerArrBX:OWSWSCRDVABX[nX]:cCRDPRE2			:=	aPremio[nX][2]
						oSWB:oWSACRDVALEC:OWSVerArrBX:OWSWSCRDVABX[nX]:cCRDPRE3			:=	aPremio[nX][3]
						oSWB:oWSACRDVALEC:OWSVerArrBX:OWSWSCRDVABX[nX]:cCRDPRE4			:=	aPremio[nX][4]
						oSWB:oWSACRDVALEC:OWSVerArrBX:OWSWSCRDVABX[nX]:nCRDPRE5			:=	aPremio[nX][5]
						oSWB:oWSACRDVALEC:OWSVerArrBX:OWSWSCRDVABX[nX]:nCRDPRE6			:=	aPremio[nX][6]
						oSWB:oWSACRDVALEC:OWSVerArrBX:OWSWSCRDVABX[nX]:nCRDPRE7			:=	aPremio[nX][7]
						nPontos += aPremio[nX][1]
					Next nX

					If len(aLibera) > 0
						cMotivo := aLibera[nX][3]
					EndIf

					oSWB:FRTCRD02( , M->LQ_CLIENTE, M->LQ_LOJA , nPontos, cDoc, "", /*cMotivo*/ "")
				EndIf

			Else
				If	Crd240_002(	"1"				,;	//01 Tipo da operacao 1 = Venda
								M->LQ_CLIENTE	,; 	//02 Codigo do cliente
								M->LQ_LOJA		,;	//03 Loja
								aProdCri		,;	//04 Produtos da venda
							    nPag			,;	//05 Valor pago
							    SL1->L1_DOC		,;	//06 Numero do documento
							    SL1->L1_SERIE	,;	//06 Serie
							    NIL				,; 	//07 Numero da nota original (Troca/Exclusao)
								NIL				,; 	//08 Serie da nota original  (Troca/Exclusao)
								NIL				,; 	//09 Origem (Se LOJA =NULL OU TMK)
								.T.				,; 	//10 Grava pontos no MAX
								nTotPontos		,;	//11 Total de pontos
								cPgVc			,; 	//12 Indica se e pagamento com vale compra
								.F.				,; 	//13 Exclui os pontos gerados pela Troca / Devolucao
								aPremio)			//14 Indica se foi resgatado




					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Grava na tabela MAZ quem liberou o resgate.³
					//³Status = 1 -> Liberacao no resgate         ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If Len( aLibera ) > 0
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³PARAMETROS:                         ³
						//³Supervisor, Nro Vale, Motivo, Status³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						For nX := 1 To Len( aLibera )
							Crd240GrvMaz( aLibera[nX][1], aLibera[nX][2], aLibera[nX][3], "1" )
						Next nX
					EndIf

					If Len( aPremio ) > 0

						For nX := 1 to Len( aPremio )
							nUsado += aPremio[nX][1]
		           		Next nX

						If	Crd240FinRes(	M->LQ_CLIENTE	,;	//01 Codigo do cliente
					 						M->LQ_LOJA		,;	//02 Loja do cliente
					 						aPremio			,;	//03 Array com os premios (altera o status do vale-compra e grava may)
					 						nUsado			,;	//04 Pontos utilizados para resgatar os premios
					 						SL1->L1_DOC		,; 	//05 Nro do documento
					 						SL1->L1_SERIE)		//06 Serie do documento
					 	EndIf
					EndIf
				EndIf
			EndIf
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Altera o status do vale-compra para resgatado e grava os produtos³
			//³resgatados na tabela MAY                                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Len( aPremio ) > 0
				CRD240BxPr( M->LQ_CLIENTE	,;	//01 Codigo do cliente
							M->LQ_LOJA		,;	//02 Loja do cliente
							aPremio			,;	//03 Array com os premios (altera o status do vale-compra e grava may)
							SL1->L1_DOC		,;	//04 Nro do documento
							SL1->L1_SERIE)  	//05 Serie do documento
			EndIf
		EndIf
		Lj7AtuPremio(.T.)
	EndIf

		//³Atualiza a ultima compra no cadastro do cliente³
		SA1->(dbSetOrder(1))

		//So atualiza se nao for cliente padrão para evitar concorrencia do SA1
		If AllTrim(M->LQ_CLIENTE) + AllTrim(M->LQ_LOJA) <> AllTrim(SuperGetMv("MV_CLIPAD",,"")) + AllTrim(SuperGetMv("MV_LOJAPAD",,""))

			If SA1->(dbSeek(xFilial("SA1")+M->LQ_CLIENTE+M->LQ_LOJA))
				RecLock("SA1", .F.)
				SA1->A1_ULTCOM := Iif(!Empty(SL1->L1_EMISNF), SL1->L1_EMISNF, SA1->A1_ULTCOM)
				SA1->A1_PRICOM := Iif(!Empty(SA1->A1_PRICOM), SA1->A1_PRICOM, SL1->L1_EMISNF)
				SA1->A1_MCOMPRA := Iif(SL1->L1_VLRTOT > SA1->A1_MCOMPRA, SL1->L1_VLRTOT, SA1->A1_MCOMPRA)
				SA1->(MsUnlock())
			EndIf

		EndIf

EndIf

// Chamada envio de e-mail para parceiros
If lFinalizou .AND. nTipo == 2 // Venda
	If ExistBlock("EmailParceiro")
		aParcEnviar	:= Lj7GetParceiros()
		ExecBlock( "EmailParceiro", .F., .F., { cNumorc , aParcEnviar } )
	EndIf
EndIf

LjGrvLog(cNumOrc,"VENDA FOI FINALIZADA ? ",lFinalizou)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de entrada para validacao no final da venda (apos as gravacoes)    ³
//³ Envia como parametro o nTipo (1-orcamento  2-venda  3-pedido)            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inclusao de chamada de Ponto de Entrada - especIfico Template            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lFinalizou .AND. ExistTemplate("LJ7002") .AND. !lFtvdVer12
	ExecTemplate( "LJ7002", .F., .F., { nParamTipo, aDocDev } )
EndIf
If lFinalizou .AND. ExistBlock("LJ7002") .AND. !lFtvdVer12
	ExecBlock( "LJ7002", .F., .F., { nParamTipo, aDocDev, 1 } )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de entrada para validacao no final da venda (apos as gravacoes)    ³
//³ Envia como parametro o nTipo (1-orcamento  2-venda  3-pedido)            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inclusao de chamada de Ponto de Entrada - especIfico Template            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lFinalizou .AND. ExistTemplate("FTVD7002") .AND. lFtvdVer12
	ExecTemplate( "FTVD7002", .F., .F., { nParamTipo, aDocDev } )
EndIf
If lFinalizou .AND. ExistBlock("FTVD7002") .AND. lFtvdVer12
	ExecBlock( "FTVD7002", .F., .F., { nParamTipo, aDocDev } )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Se usar os modulos de gestao de concessionarias chama a funcao que grava os relacionamentos.  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SuperGetMV("MV_VEICULO") == "S" .AND. !Empty(SL1->L1_VEICTIP) .AND. !Empty(SL1->L1_VEIPESQ)
    FG_DEVLOJA(SL1->L1_VEICTIP,SL1->L1_VEIPESQ, SL1->L1_DOC, SL1->L1_SERIE)
Endif

If lFinalizou .AND. nTipo == 2 .AND. !lRecebe .AND. !lReserva
	//Envia os dados da venda para integração
	If ExistFunc("Lj7AtuInte") .AND. lAmbOff
		Lj7AtuInte()
	EndIf
	If ExistFunc("LjProIntVe")
		LjProIntVe()
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Gravacao do Status TUDOOK, apos passar pelo PE, para gravacao de campos especIficos do cliente³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lLog1 .AND. lLog4 .AND. nHandle >= 0
	nSize    := FSeek( nHandle, 0, 2 )
	cRBuffer := Space( nSize )

	FSeek( nHandle, 0, 0 )
	FRead( nHandle, @cRBuffer, nSize )

	cRBuffer := Encript( cRBuffer, 1 )
	If !("#TUDOOK#" $ cRBuffer)
		cRBuffer := cRBuffer + "#TUDOOK#"
	EndIf

	FSeek( nHandle, 0, 0 )
	FWrite( nHandle, Encript( cRBuffer, 0 ) )
EndIf

If !Empty(LOG_TEF)
	LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'LOJ701C'+Replicate('-',40))
	LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Final Gravação - ' + If( lFinalizou, 'S', 'N' ))
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Chama a funcao fiscal de finalização de Calculo              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If MaFisFound("NF")
	If lMaFisSave
		//Restaura o estado anterior da MatxFis, para esvaziar o array de backup da MatxFis
		MaFisRestore()
	EndIf

	If lFinalizou
		MaFisEnd()
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Libera o Registro do SE1   						             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRecebe .AND. !(nModulo == 12 .AND. lMVLJPDVPA)   //Quando Recebimento de titulo via WebService(VA-PDV), nao realiza o Lock do registro
	If Len(aTitulo) > 0
		For nI := 1 To Len(aTitulo)
			UnLockByName(aTitulo[nI][21],.T.,.F.,.T. )
		Next nI
	EndIf
EndIf

// Habilita as teclas de atalho
Lj7SetKeys(.T.)

LjGrvLog(cNumOrc,"Fim da funcao LJ7RunGrv - Sair",lSair)

//Imprime o Relatorio de Impressao de Recibo
If lIMPLJRE .And. lFtvdVer12 .And. !lRecebe .AND. lFinalizou .And. (lLOJRREC .Or. lULOJRREC)
	//Verifica se eh pedido (Tem reserva)
	If AllTrim(SL1->L1_TIPO) == "P" .AND. Empty(AllTrim(SL1->L1_FILRES)) .AND. Empty(AllTrim(SL1->L1_ORCRES))
		cNumDoc 	:= SL1->L1_DOCPED
		cSerie  	:= SL1->L1_SERPED

		If Alltrim(Upper(cMvLjPref)) == "SF2->F2_SERIE"
			cPrefixo	:= If(Empty(SL1->L1_SERIE), SL1->L1_SERPED, SL1->L1_SERIE)
		Else
			cPrefixo	:= &(cMvLjPref)
		Endif

		If ExistFunc("LJ7NumTit")
			cNumE1 := LJ7NumTit()
		Else
			cNumE1  := cNumDoc
		EndIf
	Else
		cNumDoc 	:= SL1->L1_DOC
		cSerie  	:= SL1->L1_SERIE
		cPrefixo	:= &(cMvLjPref)
		If ExistFunc("LJ7NumTit")
			cNumE1 := LJ7NumTit()
		Else
			cNumE1  := cNumDoc
		EndIf
	EndIf

	DbSelectArea("SE1")
	DbSetOrder(1)

	If DbSeek(xFilial("SE1") + cPrefixo +  cNumDoc )

		While SE1->(!EOF()) 						.AND.;
				SE1->E1_FILIAL 	== 	xFilial("SE1")	.AND.;
				SE1->E1_PREFIXO	== 	cPrefixo 		.AND.;
				SE1->E1_NUM		== 	cNumDoc

				aadd(aTitBx, {	SE1->E1_NUM				,;	//01-Nro do Titulo
								SE1->E1_PREFIXO			,;	//02-Prefixo
				       			SE1->E1_PARCELA			,;	//03-Parcela
				       			SE1->E1_TIPO			,;	//04-Tipo
				       			M->LQ_CLIENTE			,;	//5-Cliente
				       			M->LQ_LOJA				,;	//6-Loja
				       			Dtos(SE1->E1_EMISSAO)	,;	//7-Emissao
				       			Dtos(SE1->E1_VENCTO)	,;	//8-Vencimento
				       			SE1->E1_VLCRUZ			,;	//9-Valor Original
						       	SE1->E1_SALDO			,;	//10-Saldo
						       	SE1->E1_MULTA			,;	//11-Multa
						       	SE1->E1_JUROS			,;	//12-Juros
						       	SE1->E1_DESCONT			,;	//13-Desconto
						       	SE1->E1_VALLIQ			})	//14-Valor Recebido
			SE1->(DbSkip())
		End

		For nI:=1 to Len(aPgtos)

			If Alltrim(aPgtos[nI][3]) ==  "CH"
				aadd(aFormPg	,{	aPgtos[nI][3]		,;	//Forma de Pagamento
									aPgtos[nI][2]		,;	//Valor
									Dtos(aPgtos[nI][1])	,;	//Data do Pagamento
									aPgtos[nI][4][7]	,;	//Numero do Cheque
									aPgtos[nI][4][4]	,;	//Banco
									aPgtos[nI][4][5]	,;	//Agencia
									aPgtos[nI][4][6]	,;	//Conta Corrente
									""					})	//Nome do Terceiro
			Else
				aadd(aFormPg	,{	aPgtos[nI][3]		,;	//Forma de Pagamento
									aPgtos[nI][2]		,;	//Valor
									Dtos(aPgtos[nI][1])	,;	//Data do Pagamento
									""					,;	//Numero do Cheque
									""					,;	//Banco
									""					,;	//Agencia
									""					,;	//Conta Corrente
									""					})	//Nome do Terceiro
			Endif
		Next

		If lULOJRREC
			//Fonte não será mais padrao mas sim um RDMake padrão.
			U_LOJRRecibo(SE1->E1_CLIENTE, SE1->E1_LOJA, aTitBx, aFormPg)
		Else
			LOJRREC(SE1->E1_CLIENTE, SE1->E1_LOJA, aTitBx, aFormPg)
		EndIf

	Else
		ConOut(STR0207 + cPrefixo + "/" + cNumDoc + STR0208)	//"Documento "###" não encontrado na tabela SE1."
	Endif
Endif

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LJ7GrvOrc ºAutor  ³Vendas Clientes     º Data ³  17/08/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Faz a gravacao do 'pacote' de arquivos para a rotina de     º±±
±±º          ³venda assistida                                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ExpA1 := Lj7GrvOrc( ExpA2, ExpA3 [, ExpA4, ExpL1, ExpL2,    º±±
±±º          ³                    ExpC1 ] )                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpA2 - Array com as informacoes do SL1 no formato          º±±
±±º          ³        [1] - Nome do campo                                 º±±
±±º          ³        [2] - Valor a ser gravado                           º±±
±±º          ³                                                            º±±
±±º          ³ExpA3 - Array com as informacoes do SL2 no formato          º±±
±±º          ³        [1] - Nome do campo                                 º±±
±±º          ³        [2] - Valor a ser gravado                           º±±
±±º          ³                                                            º±±
±±º          ³ExpA4 - Array com as informacoes do SL4 no formato          º±±
±±º          ³        [1] - Nome do campo                                 º±±
±±º          ³        [2] - Valor a ser gravado                           º±±
±±º          ³                                                            º±±
±±º          ³ExpL1 - Variavel que indica se a rotina ira ter tratamento  º±±
±±º          ³        de tela, isto e, se nao sera uma rotina automatica  º±±
±±º          ³        .T. - Mostra as mesnagens na tela                   º±±
±±º          ³        .F. - Nao mostra mensagens na tela                  º±±
±±º          ³                                                            º±±
±±º          ³ExpL2 - Indica se eh para gerar um numero de orcamento ou   º±±
±±º          ³        nao. (valor DEFAULT .F.). Se esse parametro for .F. º±±
±±º          ³        o campo L1_NUM devera ser informado                 º±±
±±º          ³                                                            º±±
±±º          ³ExpC1 - Codigo da filial onde sera gravado o orcamento. Se  º±±
±±º          ³        nao for informado sera grava na filial local        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ExpA1 - Array contendo:                                     º±±
±±º          ³        [1] - T / F. Indica se fez ou nao a gravacao        º±±
±±º          ³        [2] - Numero do orcamento gerado                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LJ7GrvOrc( aSL1		, aSL2		,	aSL4,	lTela,;
					lGeraNumOrc	, cFilOrc	, 	lJob,   lAlteraPrc )

Local aRet 			:= { .F., Space(TamSx3("L1_NUM")[1]) }		// Array com retorno da funcao, se gerou o SL e num do orcamento
Local nX			:= 0										// Variavel auxiliar do for
Local nPos 			:= 0										// Posicao dos campos no array aSL
Local nCont 		:= 0										// Contador dos itens do SL4
Local cNumOrc		:= Space(TamSX3("L1_NUM")[1])				// Numero do orcamento L1_NUM
Local cFilAux		:= ""										// Grava a filial anterior, utiliza como auxiliar
Local lOperacao		:= .T.										// Variavel que indicara se eh uma inclusao ou exclusao de um orcamento
Local lContinua		:= .T.										// Valida se continua a gravacao do SL
Local lRet 			:= .F.										// Variavel logica de retorno da funcao utilizada no array aRet
Local lAlteraFil 	:= (cFilOrc<>Nil)							// VerIfica se tem filial dIferente para gravacao o orcamento
Local nTent 		:= 0										// Tentativas para gravacao do SL1 com a numeracao do orcamento
Local cMay			:= ""										// Conteudo da filial e orcamento para nao haver duplicacao
Local nSaveSx8 		:= GetSx8Len()								// Numeracao do SX8
Local nRestDiv      := 0										// Calcula dIferenca do resto da divisao
Local lVendaPerdida	:= SuperGetMV ("MV_LJMVPE",,.F.)			// Habilita gravacao de movimento de venda perdida
Local oMoviVp 	   												// Objeto do movimento de venda perdida
Local lNfPafEcf	  	:= LjNfPafEcf(SM0->M0_CGC)					//Se habilitado CNPJ PAF-ECF
Local nPosPafMd5	:= 0										// Posicao do PAFMD5, somente possui conteudo quando armazenado no BD
Local lGrvLogDAV	:= lNfPafEcf .And. !SuperGetMv("MV_LJPRVEN",,.T.)
Local aAreaSM0		:= SM0->(GetArea()) 						//Guarda a area da SM0
Local lIntegDef		:= If(Type("lAutoExec") == "L", lAutoExec, .F.) .And. FWHasEAI("LOJA701",, .T., .T.) .AND. IIF( ExistFunc("Lj701GtInD") , Lj701GtInD(), IsInCallStack("LOJI701"))  //Integracao via Mensagem Unica
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local cPdv          := ""										// Numero do Pdv
Local cOperador     := ""										// Operador do caixa

Default aSL4 		:= {}										// Array do SL4
Default lTela		:= .T.										// Valida se existe tela na transacao
Default lGeraNumOrc	:= .F.										// VerIfica se eh para gerar numero do orcamento
Default cFilOrc		:= xFilial("SL1")							// Filial do orcamento
Default lJob		:= .F.
Default lAlteraPrc 	:= .F.                                     // Será true quando for utilizada para alterar apenas as parcelas aSL4


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se for informada a filial para gravacao do orcamento troca o ³
//³ valor de cFilAnt para que os semaforos possam pegar as       ³
//³ informacoes da filial correta                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lAlteraFil
	cFilAux := cFilAnt
	cFilAnt := cFilOrc
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Acerta o campo filial dos arrays                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nPos 	:= aScan( aSL1, {|x| Alltrim( Upper( x[1] ) ) == "L1_FILIAL" } )

If nPos == 0
	aAdd( aSL1, { "L1_FILIAL", cFilOrc } )
Else
	aSL1[nPos][2] := cFilOrc
EndIf

For nX := 1 to Len( aSL2 )
	nPos 	:= aScan( aSL2[nX], {|x| Alltrim( Upper( x[1] ) ) == "L2_FILIAL" } )
	If nPos == 0
		aAdd( aSL2[nX], { "L2_FILIAL", cFilOrc } )
	Else
		aSL2[nX][nPos][2] := cFilOrc
	EndIf
Next nX

For nX := 1 to Len( aSL4 )
	nPos 	:= aScan( aSL4[nX], {|x| Alltrim( Upper( x[1] ) ) == "L4_FILIAL" } )
	If nPos == 0
		aAdd( aSL4[nX], { "L4_FILIAL", cFilOrc } )
	Else
		aSL4[nX][nPos][2] := cFilOrc
	EndIf

Next nX

// preciso dessa informações pois em queda do sistema nao esta gravando essa informação.
If Empty(M->LQ_PDV) 
	cPdv := LjGetStation("LG_PDV")
Else
	cPdv := M->LQ_PDV
EndIf
If !lJob
	cOperador := xNumCaixa()
Else
	cOperador := M->LQ_OPERADO
EndIf		 

If !ExistFunc("LjGetKeyPs") .OR. ( ExistFunc("LjGetKeyPs") .AND. LjGetKeyPs() == "F5" ) 
	If !Ascan(aSL1, {|x| AllTrim(upper(x[1])) == "L1_PDV"}) > 0
		aAdd( aSL1, { "L1_PDV", cPdv } )
	EndIf
	If !Ascan(aSL1, {|x| AllTrim(upper(x[1])) == "L1_OPERADO"}) > 0
		aAdd( aSL1, { "L1_OPERADO", cOperador } )
	EndIf
End 	
//
//Integracao Mensagem Unica adiciona informacoes da integracao
If lIntegDef
	aAdd( aSL1, { "L1_ORIGEM", "N" } )
	
	//Armazena informacoes Tef - Integracao Mensagem Unica
	aAdd( aSL1, { "L1_VENDTEF", M->LQ_VENDTEF } )
	aAdd( aSL1, { "L1_DATATEF", M->LQ_DATATEF } )
	aAdd( aSL1, { "L1_HORATEF", M->LQ_HORATEF } )
	aAdd( aSL1, { "L1_DOCTEF",  M->LQ_DOCTEF 	} )
	aAdd( aSL1, { "L1_AUTORIZ", M->LQ_AUTORIZ } )
	aAdd( aSL1, { "L1_DOCCANC", M->LQ_DOCCANC } )
	aAdd( aSL1, { "L1_DATCANC", M->LQ_DATCANC } )
	aAdd( aSL1, { "L1_HORCANC", M->LQ_HORCANC } )
	aAdd( aSL1, { "L1_INSTITU", M->LQ_INSTITU } )
	aAdd( aSL1, { "L1_NSUTEF",  M->LQ_NSUTEF 	} )
	aAdd( aSL1, { "L1_CGCCLI",  M->LQ_CGCCLI 	} )
	
	//Lei de Transparencia 
	aAdd( aSL1, { "L1_TOTFED",  M->LQ_TOTFED 	} )
	aAdd( aSL1, { "L1_TOTEST",  M->LQ_TOTEST 	} )	
	aAdd( aSL1, { "L1_TOTMUN",  M->LQ_TOTMUN 	} )
	aAdd( aSL1, { "L1_LTRAN",   M->LQ_LTRAN 	} )		
	aAdd( aSL1, { "L1_VALMERC", M->LQ_VALMERC } )	
	
	
	//Armazena informacao de Comissao do Vendedor
	aAdd( aSL1, { "L1_VALCOMI", M->LQ_VALCOMI } )	
	
	//Armazena Documento Fiscal
	If !Empty(M->LQ_NUMCFIS)
		aAdd( aSL1, { "L1_NUMCFIS", M->LQ_NUMCFIS } )
	EndIf
Else
	//Acerta SL1 para rotina automatica quando for integração com gestão de concessionarias
	If Type("lAutoExec") == "L" .AND. lAutoExec .AND. SuperGetMV("MV_VEICULO") == "S"
		nPos 	:= aScan( aSL1, {|x| Alltrim( Upper( x[1] ) ) == "L1_ORIGEM" } )	 // Execucao Automatica
		If nPos == 0
			aAdd( aSL1, { "L1_ORIGEM", "V" } )
		Else
			aSL1[nPos][2] := "V"
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Checar se eh para gerar um numero de orcamento               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lGeraNumOrc

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³CriaVar do L1_NUM ira chamar a GetSxeNum()³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If !LJTemGeraNOrc()
    	cNumOrc := CriaVar( "L1_NUM" )
    Else
    	cNumOrc := GetSxENum("SL1","L1_NUM")
    EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Caso o SXE e o SXF estejam corrompidos o numero do orcamento estava se repetindo ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cMay := Alltrim( xFilial( "SL1" ) ) + cNumOrc
	FreeUsedCode()
	SL1->( DbSetOrder( 1 ) )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se dois orcamentos iniciam ao mesmo tempo a MayIUseCode impede que ambos utilizem o mesmo numero.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nTent := 0
	While SL1->( DbSeek( xFilial( "SL1" ) + cNumOrc ) ) .OR. !MayIUseCode( cMay )
		If ++nTent > 20
			MsgStop(STR0006) //"Impossivel gerar número sequencial de orçamento correto. Informe ao administrador do sistema."
			Return aRet
		EndIf
		While ( GetSX8Len() > nSaveSx8 )
			ConfirmSx8()
		End
		If !LJTemGeraNOrc()
			cNumOrc := CriaVar( "L1_NUM" )
		Else
			cNumOrc := GetSxENum("SL1","L1_NUM")
		EndIf
		FreeUsedCode()
		cMay := Alltrim( xFilial( "SL1" ) ) + cNumOrc
	End

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Acerta o array aSL1³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nPos 	:= aScan( aSL1, {|x| Alltrim( Upper( x[1] ) ) == "L1_NUM" } )
	If nPos == 0
		aAdd( aSL1, { "L1_NUM", cNumOrc } )
	Else
		aSL1[nPos][2] := cNumOrc
	EndIf

	If lJob
		nPos 	:= aScan( aSL1, {|x| Alltrim( Upper( x[1] ) ) == "L1_RESERVA" } )
		If nPos == 0
			aAdd( aSL1, { "L1_RESERVA", "S" } )
		Else
			aSL1[nPos][2] := "S"
		EndIf

		nPos 	:= aScan( aSL1, {|x| Alltrim( Upper( x[1] ) ) == "L1_SERPED" } )
		If nPos == 0
			aAdd( aSL1, { "L1_SERPED", "" } )
		Else
			aSL1[nPos][2] := ""
		EndIf
		nPos 	:= aScan( aSL1, {|x| Alltrim( Upper( x[1] ) ) == "L1_SITUA" } )
		If nPos == 0
			aAdd( aSL1, { "L1_SITUA", "" } )
		Else
			aSL1[nPos][2] := ""
		EndIf

	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Acerta o array aSL2³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX := 1 to Len( aSL2 )
		nPos 	:= aScan( aSL2[nX], {|x| Alltrim( Upper( x[1] ) ) == "L2_NUM" } )
		If nPos == 0
			aAdd( aSL2[nX], { "L2_NUM", cNumOrc } )
		Else
			aSL2[nX][nPos][2] := cNumOrc
		EndIf
	Next nX

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Acerta o array aSL4³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    For nX := 1 to Len( aSL4 )
		nPos 	:= aScan( aSL4[nX], {|x| Alltrim( Upper( x[1] ) ) == "L4_NUM" } )
		If nPos == 0
			aAdd( aSL4[nX], { "L4_NUM", cNumOrc } )
		Else
			aSL4[nX][nPos][2] := cNumOrc
		EndIf
	Next nX

EndIf
If SL1->(ColumnPos("L1_VLRJUR")) > 0 .AND. Type("aAcrescimo") == "A"
	//Inclui Valor do Juros no Array aSL1
	nPos := aScan( aSL1, {|x| Alltrim( Upper( x[1] ) ) == "L1_VLRJUR" } )
	If nPos == 0
		aAdd( aSL1, { "L1_VLRJUR",A410Arred(aAcrescimo[1],"L1_VLRJUR")  } )
	Else	
		aSL1[nPos][2] := A410Arred(aAcrescimo[1],"L1_VLRJUR")
	EndIf	
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ VerIfica se o numero informado jah existe na base            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty( cNumOrc )
	nPos 	:= aScan( aSL1, {|x| Alltrim( Upper( x[1] ) ) == "L1_NUM" } )

	If nPos > 0 .AND. !Empty( aSL1[nPos][2] )
		cNumOrc	:= aSL1[nPos][2]
	EndIf
EndIf

DbSelectArea( "SL1" )
DbSetOrder( 1 )

If DbSeek( xFilial( "SL1" ) + cNumOrc )

	If Empty( SL1->L1_DOC )
		lOperacao := .F.
	Else
		If lTela
			Aviso( STR0007, STR0008 + cNumOrc + STR0009, {"Ok"} ) //"Atenção"###"O orçamento informado ("###") já está vinculado a um documento fiscal."
		Else
			Conout( STR0008 + cNumOrc + STR0009, {STR0005} ) //"O orçamento informado ("###") já está vinculado a um documento fiscal."###"Ok"
			Help( " ", 1, "Help",, STR0008 + cNumOrc + STR0009, 1, 0 )
		EndIf
		lContinua := .F.

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se foi pedido para gerar o numero de orcamento. Tenta ateh encontrar um numero valido.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lGeraNumOrc
			While SL1->( DbSeek( xFilial( "SL1" ) + cNumOrc ) ) .AND. !Empty( SL1->L1_DOC )
				While ( GetSX8Len() > nSaveSx8 )
					ConfirmSx8()
				End
				If !LJTemGeraNOrc()
					cNumOrc := CriaVar( "L1_NUM" )
				Else
					cNumOrc := GetSxENum("SL1","L1_NUM")
				EndIf
			End
			lContinua := .T.
		EndIf

	EndIf
Else
	lOperacao := .T.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Faz a gravacao do 'pacote'³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lContinua
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Faz a gravacao do SL1                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea("SL1")
	Lj7GeraSL( "SL1", aSL1, If(lAlteraPrc,.F.,lOperacao), If(lAlteraFil,.T.,.F.) )
	If lOperacao
		While ( GetSX8Len() > nSaveSx8 )
			ConfirmSx8()
		End
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	// Se for apenas alteração das parcelas do SL4 não grava SL1 nem SL2(Somente Venda Direta)	   				 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (lFtvdVer12 .AND. !lAlteraPrc) .OR. !lFtvdVer12
		//³ Faz a gravacao do SL2
		DbSelectArea( "SL2" )
		SL2->(DbSetOrder( 1 ))

		//PAF-ECF: Considera registros excluidos para limpar conteudo L2_PAFMD5
	   	If lNfPafEcf
			SET DELETED OFF
		EndIf

		If SL2->(MsSeek( xFilial( "SL2" ) + SL1->L1_NUM ))
		
			aOrcFilDel := {} //Zera array statico de orcamentos filhos a deletar

			/*Se for alteracao deleta o SL2 antes de fazer a gravacao*/
			While !SL2->(Eof()) .AND. SL2->L2_FILIAL + SL2->L2_NUM == xFilial( "SL2" ) + SL1->L1_NUM
				Begin Transaction

					//Exclui a mensagem no SYP caso exista - Mensagem da Lista de Presentes
					If SL2->(ColumnPos("L2_MSMLPRE")) > 0 .AND. !Empty(SL2->L2_MSMLPRE)
						MSMM(SL2->L2_MSMLPRE,,,,2,,,"SL2","L2_MSMLPRE")
					EndIf

					//Exclui a mensagem no SYP caso exista - Remetente da Lista de Presentes
					If SL2->(ColumnPos("L2_REMLPRE")) > 0 .AND. !Empty(SL2->L2_REMLPRE)
						MSMM(SL2->L2_REMLPRE,,,,2,,,"SL2","L2_REMLPRE")
					EndIf
					RecLock("SL2",.F.)

					//Limpa campo validador do PAF-ECF para sinalizar que registro deletado nao sera utilizado nos relatorios/importacao de orcamento
					If (lNfPafEcf .Or. lFtvdVer12)
						SL2->L2_PAFMD5 := ""
					EndIf
					
					If !Empty(SL2->L2_FILRES) .AND. !Empty(SL2->L2_ORCRES)
						AADD(aOrcFilDel,{ SL2->L2_FILRES , SL2->L2_ORCRES })
					EndIf

					SL2->(DbDelete())
					SL2->(MsUnlock())

				End Transaction
				SL2->(DbSkip())
			End
		EndIf

		//PAF-ECF: Volta valor Set Deleted
	   	If lNfPafEcf
			SET DELETED ON

			//Somente valida registro deletado na Retaguarda PAF-ECF, nao eh necessario no PDV
			If !lMVLJPDVPA .AND. !lJob .And. Type("aposCpoDet") == "A"
				nPosPafMd5	:= aScan(aposCpoDet,{|x| AllTrim(Upper(x[1]))=="LR_PAFMD5" })
			EndIf
		EndIf

		For nX := 1 to Len( aSL2 )
			//PAF-ECF: Quando registro cancelado e ainda não armazenado no BD(Banco de Dados), nao precisa armazenar no BD.
			If !( nPosPafMd5 > 0 .AND. aColsDet[nX][Len(aColsDet[nX])] .AND. aColsDet[nX][nPosPafMd5] == Nil)
				Lj7GeraSL( "SL2", aSL2[nX], .T. )
			EndIf

			//PAF-ECF: Log de alteração da DAV
			If lNfPafEcf .And. lGrvLogDAV
				LjGrLogD( "SL2", aSL2[nX])
			EndIf
		Next nX
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Faz a gravacao do SL4                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nCont := 1
	DbSelectArea( "SL4" )
	SL4->(DbSetOrder( 1 ))
	SL4->(DbSeek( xFilial( "SL4" ) + SL1->L1_NUM ))

	While !SL4->(Eof()) .AND. SL4->L4_FILIAL + SL4->L4_NUM == xFilial( "SL4" ) + SL1->L1_NUM  .AND. Empty( SL4->L4_ORIGEM )
		If !lFtvdVer12
			If nCont <= Len( aSL4 )
		    	Lj7GeraSL( "SL4", aSL4[nCont] )
		 	Else
				Begin Transaction

		 		RecLock("SL4",.F.)
		 		//Efetua marca (**) no campo L4_SITUA p/ identificar como "registro deletado" p/ que este seja desconsiderado quando mandar os dados para retaguarda,
		 		//pois na funcao GravaSL1 do fonte LjGrvWs.PRW considera todos os registros, inclusive os deletados para integrar com a retaguarda e este registro nao podera ser considerado
		 		SL4->L4_SITUA := "**"
		 		DbDelete()
		 		MsUnlock()

		 		End Transaction
		 	EndIf
	    	SL4->( DbSkip() )
			nCont ++
		ElseIf lFtvdVer12
			If lAlteraPrc // Quando lAlteraPrc = .T. apaga todo o SL4 para gerar novamente
				Begin Transaction

		 		RecLock("SL4",.F.)
		 		DbDelete()
		 		MsUnlock()

		 		End Transaction
			Else
				If nCont <= Len( aSL4 )
			    	Lj7GeraSL( "SL4", aSL4[nCont] )
			 	Else
					Begin Transaction

			 		RecLock("SL4",.F.)
			 		DbDelete()
			 		MsUnlock()

			 		End Transaction
			 	EndIf
				nCont++
			EndIf
	    	SL4->( DbSkip() )

		EndIf
	End

	For nX := nCont to Len( aSL4 )
		Lj7GeraSL( "SL4", aSL4[nX], .T. )
	Next nX

    lRet := .T.
    cNumOrc := aSL1[aScan(aSL1,{|x|x[1]=="L1_NUM"})][2]

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Grava movimento de venda perdida durante a gravacao do orcamento ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lMVLJPDVPA .AND. lVendaPerdida .AND. ExistFunc("LA701GetVp")
		oMoviVp	:= LA701GetVp() //OBTER OBJETO DE MOVIMENTO DE VENDA PERDIDA, ATIVO NO LOJA701
		If oMoviVp != NIL
			nPos := aScan( aSL1, {|x|x[1] == "L1_NUMORC"} )
			If nPos > 0
				LA701GrvVp (oMoviVp, aSL1[nPos][2])
			Else	//grava o numero do orcamento atual
				LA701GrvVp (oMoviVp, cNumOrc)
			EndIf
		EndIf
	EndIf
Else

	cNumOrc := Space( TamSX3( "L1_NUM" )[1] )
	If lGeraNumOrc
		RoolBackSx8()
	EndIf

EndIf

aRet := { lRet, cNumOrc }

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Volta o valor original da cFilAnt se necessario              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lAlteraFil
	cFilAnt := cFilAux
	RestArea(aAreaSM0)
EndIf

Return aRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³Lj7PrepOrcºAutor  ³Vendas Clientes     º Data ³  18/08/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Prepara os dados para a gravacao do orcamento               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ExpL1 := Lj7PrepOrc()                                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ExpL1 - .T. se a gravacao foi concluida com exito           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Loja701                                                     º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Lj7PrepOrc( nOpc     	, nTipo     , nHandle		, lReserva		,;
					 lAtuData	, lDefPagto	, cNomeCli		, cCGCCli		,;
					 lNfManual	, cEspDoc	, nDescontFi	, lAlteraPrc	,;
					 nTotICM	)
					 
Local aArea			:= GetArea()				// Guarda a area atual
Local aSL1			:= {}						// Array com os campos do SL1
Local aSL2			:= {}						// Array com os campos do SL2
Local aSL4			:= {}						// Array com os campos do SL4
Local aAux 			:= {}						// Array auxiliar
Local aCamposU		:= {}						// Array com os campos de usuario (custom.)
Local aFormas       := {}             			// Array das formas de pagto
Local aRetCrd       := {}						// Array de retorno com informacoes de credito do cliente(SIGACRD)
Local aCposTroco	:= {}						// Array com os campos de troco controlados pelo sistema

Local nTotalDIfForm := 0						// Total de dIferencas
Local nPosRet       := 0						// Posicao retornada
Local nX	 		:= 0						// Variav. auxiliar em For...Next
Local nY	 		:= 0						// Variav. auxiliar em For...Next
Local nPos 			:= 0						// Posicao dentro de um array
Local nPosProd		:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_PRODUTO"})][2]		// Posicao do Codigo do produto
Local nPosDescri	:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_DESCRI"})][2]			// Posicao da Descricao do produto
Local nPosQuant		:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_QUANT"})][2]			// Posicao da Quantidade
Local nPosVrUnit	:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_VRUNIT"})][2]			// Posicao do Valor unitario do item
Local nPosVlrItem   := aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_VLRITEM"})][2]		// Posicao do Valor Total do Item
Local nPosDesc		:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_DESC"})][2]			// Posicao do percentual de desconto
Local nPosValDesc	:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_VALDESC"})][2]		// Posicao do valor de desconto
Local nPosEntrega   := aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_ENTREGA"})][2]		// Posicao da Entrega
Local nPosProvEnt	:= Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_PROVENT"})					// Posicao da provincia de entrega
Local nPosMostruario:= 0																			// FLAG se eh mostruario/Saldao/Normal
Local nPosObsMostrua:= 0																			// Observacoes do mostruario/Saldao
Local nPosGarant	:= 0																			// Posicao garantia
Local nPosVend		:= 0																			// Posicao do vendedor
Local nPosVlTroca   := 0
Local nPosFILPED     := 0																			// Posicao da Filial do Pedido com VFE
Local nPosCEST      := 0																			// Posicao do CEST
Local nDtEntr		:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_FDTENTR"})
Local nDtMont		:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_FDTMONT"})
Local nPContato 	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_CODCONT"})
Local nPosLista		:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_CODLPRE"})					//Posicao do codigo da lista de presente
Local nPosItLista	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_ITLPRE" })					//posicao do item da lista de presente
Local nPosMsgLPre	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_MSGLPRE"})					//Mensagem do Comprador
Local nPosRevLPre	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_REVLPRE"})					//Mensagem do Remetente
Local nPosMsmLPre	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_MSMLPRE"})					//Codigo da mensagem do Comprador
Local nPosRemLPre	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_REMLPRE"})					//Codigo da mensagem do Remetente
Local nPosVlImpor	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_VLIMPOR"})					//Posicao do Valor de Importação
Local nPosFCICod	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_FCICOD"})						//Posicao do Codigo FCI
Local nPosClasFis	:= IIF(SL2->(ColumnPos("L2_CLASFIS")) > 0 .And. SLR->(ColumnPos("LR_CLASFIS")) > 0, Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_CLASFIS"}), 0)//Classificação Fiscal do Produto
Local nPosPRedIc	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_PREDIC"})					//%Redução da Base do ICMS
Local nPosDtEntr	:= 0					   														// Posicao da Data de Entrega
Local nPosDtMont	:= 0					   														// Posicao da Data de Montagem
Local nPosContato	:= 0																			// Posicao da Contato do Cliente
Local nPosDtTes		:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_TES"})						// Posicao do Codigo do TES
Local nPosDtCF		:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_CF" })						// Posicao do Codigo do CF
Local nPosDtTabela	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_TABELA" })					// Posicao da Tabela de precos
Local nPosDtDProp	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_DESCPRO" })				// Posicao do Desconto proporcional
Local nPosDtPrcTab  := Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_PRCTAB" })					// Posicao do Preco de Tabela
Local nPosDtReserva	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_RESERVA" })				// Posicao do codigo da reserva
Local nPosDtLojaRes	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_LOJARES"	})				// Posicao do codigo da reserva
Local nPosDtFilRes	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_FILRES"	})				// Posicao do codigo da Filial de reserva
Local nPosDtVlFret	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_VALFRE"	})				// Posicao do Valor do Frete do Item     
Local nPosDtVlDesp	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_DESPESA" })				// Posicao do Valor das Despesas Acessorias do Item
Local nPosNumSerie	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_NSERIE"	})				// Posicao do codigo do serial
Local nPosLoteCTL 	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_LOTECTL"	})				// Posicao do codigo do Sub Lote
Local nPosLote   	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_NLOTE"	})				// Posicao do codigo numero do Lote
Local nPosLocaliz	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_LOCALIZ" })				// Posicao do codigo da localizacao
Local nPosDtValid	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_DTVALID"})				// Posicao da validade do lote
Local nPosDtLocal  	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_LOCAL"})					// Posicao do local (armazem)
Local nPosValePre	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_VALEPRE"})				// Posicao do codigo do Vale Presente
Local nPosCodReg	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_CODREG"})  				// Posicao do campo do codigo da Regra de desconto
Local nPosVlDesR	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_VLDESRE"})				// Posicao do campo do valor consedido pela regra de desconto
Local nPosTurno		:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_TURNO"})			     	// Posicao do codigo do Vale Presente
Local nPosCodLan	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_CODLAN"})			     	// Posicao do codigo do Codigo de Lancamento
Local nPosStTrib	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_SITTRIB"})			     	// Posicao do codigo do Situacao Tributaria
Local nPosEnvelo    := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_ENVELO"})			     	// Posicao do codigo do Envelope
Local nPosKit       := Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_KIT"})			     	// Posicao do campo que indica se o item eh kit
Local nPosBrinde    := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_BRINDE"})			     	// Posicao do codigo do "Prod. Brinde
Local nPosCliEnv    := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_CLIENV"})			     	// Posicao do codigo do Cliente do Envelope
Local nPosLojEnv   	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_LOJENV"})			     	// Posicao do codigo da Loja do Envelopre
Local nPosPa2Item   := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_PA2ITEM"})			    // Posicao do codigo do Item do Envelope
Local nPosCodBar	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_CODBAR"})				//Codigo de barras
Local nPosECPresSN	:= IIF(SLR->(ColumnPos("LR_ECPRESN") > 0), Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ECPRESN"}), 0)					//Se Pedido de Presente e-Commerce
Local nPosECSedex	:= IIF(SLR->(ColumnPos("LR_ECSEDEX") > 0), Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ECSEDEX"}), 0)					//Codigo Sedex do e-Commerce
Local nPosECMensPr	:= IIF(SLR->(ColumnPos("LR_ECMSGPR") > 0), Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ECMSGPR"}), 0)					//Mensagem do Item de Presente e-Commerce
Local lIntegDef		:= If(Type("lAutoExec") == "L", lAutoExec, .F.) .And. FWHasEAI("LOJA701",, .T., .T.)  .AND. IIF( ExistFunc("Lj701GtInD") , Lj701GtInD(), IsInCallStack("LOJI701"))  //Integracao via Mensagem Unica
Local lIntegHtl		:= lIntegDef .And. SuperGetMv("MV_INTHTL",, .F.) 
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local lEmitNFCe		:= (!lFtvdVer12 .Or. lIntegDef) .AND. LjEmitNFCe()			// Sinaliza se utiliza NFC-e

Local lL2Origem		:= IIF((lEmitNfce .Or. lIsPafNfce) .AND. SL2->(ColumnPos( "L2_ORIGEM" )) > 0, .T.,.F.)							//Verifica se possui campo para armazenar B1_Origem, utilizado para otimizar processo da NFCe
Local lL2Modbc		:= IIF((lEmitNfce .Or. lIsPafNfce) .AND. SL2->(ColumnPos( "L2_MODBC" )) > 0, .T.,.F.)							//Verifica se possui campo utilizado para otimizar processo da NFCe
Local lL2PosIpi		:= IIF(SL2->(ColumnPos( "L2_POSIPI" )) > 0, .T.,.F.)							//Verifica se possui campo utilizado para otimizar processo da NFCe

//Utilizado quando finalizacao de Pedido
Local nPosOrigem	:= IIF((lEmitNfce .Or. lIsPafNfce) .AND. lL2Origem, Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ORIGEM"}),0)						//Verifica se possui campo para armazenar B1_Origem, utilizado para otimizar processo da NFCe
Local nPosModbc		:= IIF((lEmitNfce .Or. lIsPafNfce) .AND. lL2Modbc,  Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_MODBC"}),0)							//Verifica se possui campo utilizado para otimizar processo da NFCe
Local nPosCodIss	:= Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_CODISS"})															//Verifica se possui campo utilizado para otimizar processo da NFCe
Local nPosPosIpi	:= IIF((lEmitNfce .Or. lIsPafNfce .Or. lIntegDef) .AND. lL2PosIpi, Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_POSIPI"}),0)						//Verifica se possui campo utilizado para otimizar processo da NFCe

Local nPosPedSC5	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_PEDSC5"}) 				//Pedido de venda do SC5 (UPDFAT14)
Local nPosIteSC6	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_ITESC6"}) 				//Iten do Pedido de venda (UPDFAT14)
Local nPosSequen	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_SEQUEN"}) 				//Sequencia do SC9 (UPDFAT14)

Local nDinheiro		:= 0								// Valor em dinheiro
Local nCheque 		:= 0								// Valor em cheque
Local nCartao 		:= 0								// Valor em Cartao de Credito
Local nVlrDebi 		:= 0								// Valor em Cartao de Debito
Local nConveni		:= 0								// Valor em Convenio
Local nVales 		:= 0								// Valor em Vales
Local nFinanc		:= 0								// Valor em Financiamento
Local nOutros 		:= 0								// Valor pago de outras formas
Local nVlrEntrada 	:= 0								// Valor de Entrada
Local nVlrFSD		:= 0								// Valor do frete + seguro + despesas
Local nVlrTroco		:= IIF(!lIntegDef, Lj7T_Troco(2), 0) // Valor do troco
Local nPercProp		:= 0								// Percentual ref. a proporcao do valor do item no total da venda
Local nVlrItens		:= 0								// Valor total dos itens
Local nMoedaParc    := 1								// Moeda corrente
Local nRestDiv      := 0                        		// Resto da divisao
Local nVlrTrcAux    := 0                              	// Troco convertido para moeda da parcela
Local nItensRT      	:= 0								// Valor de rateio de ISS
Local nPRT          	:= 0								// Preco rateado
Local nRet          := 0								// retorna status
Local nVlrParc      := 0                           		// Valor da parcela calculado quando troco desabilitado
Local nTrocoEnt     := 0                          		// Valor que deve ser subtraido da entrada, caso o troco nao esteja habilitado
Local nVlrDescFin	:= 0 								// Valor referente ao desconto financeiro
Local nVlrAcreFin	:= 0 								// Valor referente ao acrescimo financeiro
Local nPerDescFin	:= 0 								// Valor referente ao desconto financeiro
Local nPerAcrsFin	:= 0 								// Valor referente ao acrescimo financeiro
Local nTotAux		:= 0								// Total do nTotPremio
Local nPrcTab											// Valor do Preco de Tabela do Item do SL2
Local nDIf          := 0                                // DIferenca entre o valor da venda e de parcelas
Local nTamOrc		:= 0								// Tamanho do campo de orcamento (LQ_NUMORC)
Local nPosLR_BICO  := 0
Local nPosLR_LEGCOD:= 0

Local cNumOrc		:= Space(TamSx3("L1_NUM")[1])			// Nr. do orcamento
Local cItem			:= StrZero(0,TamSx3("L2_ITEM")[1],0)	// Item
Local cCampo		:= ""									// Guarda o campo do SLQ
Local cCondPgto     := ""									// Condicao de pagto
Local cMV_FormCRD   := SuperGetMV("MV_FORMCRD",,"CH/FI") 	// Formas de pagamento para as quais deve avaliar credito - SIGACRD
Local cMV_CLIPAD	:= PadR(SuperGetMV("MV_CLIPAD"),TAMSX3("LQ_CLIENTE")[1])	// Cliente padrao
Local cMV_LOJAPAD	:= PadR(SuperGetMV("MV_LOJAPAD"),TAMSX3("LQ_LOJA")[1])		// Loja do cliente padrao
Local cMV_CRDAVAL   := SuperGetMV("MV_CRDAVAL",,"13|22|43")	// Parametro que define os modulos e processos que tem analise de credito
Local cMsg          :="" 									// Mensagem a exibir
Local cRetorno      :=Space(10)								// string de retorno da DLL
Local cTabCnVda 	:= ""									// Tabela de preco padrao
Local cTpComiss		:= SuperGetMv("MV_LJTPCOM",,"1")		// Tipo de calculo de comissao utilizado (1-Para toda a venda (padrao),2-Por item)
Local cVend			:= ""									// Vendedor gravado no item

Local dDataOrc		:= Ctod(Space(8))						// Data do orcamento
Local dDataVal		:= Ctod(Space(8))						// Data de validade do orcam.

Local lLog1       	:= SubStr(LJGetProfile("LOGERRO"),1,1) == "S" 		// Tem Log de Erro
Local lLog4         := SubStr(LJGetProfile("LOGERRO"),4,1) == "S" 		// Log de Recuperacao, grava as parcelas
Local lVAssConc		:= LjVassConc()									//Indica se o cliente utiliza a Vda Assistida Concomitante
Local lCondNeg     	:= ( Trim( SL1->L1_CONDPG ) == "CN" )				// VerIfica se eh condicao negociada
Local lRet          := .F. 												// Retorno da funcao
Local lTemParcFI    := .F.												// Controla se tem alguma parcela financiada para avaliacao de credito
Local lHabTroco     := SL1->( ColumnPos( "L1_TROCO1" ) ) > 0 .AND. SuperGetMV( "MV_LJTROCO", ,.F. )   //Determina que o controle de troco esta habilitado
Local lForcada		:= .F.											// Indica se a venda foi off-line ou on-line quando integra com SIGACRD
Local lTemFinanc    := .F.											// Determina se tem alguma parcela financiada para chamar a tela
Local lTplPCL		:= HasTemplate("PCL") .AND. ExistTemplate("TpPclImpLeg")
												   					// de Adm. Financeira na gravacao do orcamento quando SIGACRD integrado
Local lUsafd      	:= SuperGetMV("MV_LJUSAFD",,.F.) 				// Utiliza Fidelizacao de cliente ??
Local nMoedExist    := MoedFin()									// Recebe a Quantidade de moedas cadastradas
Local nTPCompNCC    := SuperGetMV("MV_LJCPNCC",,1)													//Tratamento para compensacao de NCC 1-Compensacao atual 2 - Nova Compensacao
Local lTemGeraNOrc	:= .F.																			//Se tem funcao diferenciada para geracao de numero de orcamento
Local lObrigatorio	:= .F.																			//Se os campos obrigatórios da tela estão preenchidos
Local lLj7052		:= ExistFunc("U_LJ7052")														// VerIfica se existe o Ponto de Entrada
Local cFormVale		:= IIf(SuperGetMV("MV_LJVALEP",,.F.),"VA|VP","VA")								// Utiliza Vale Presente
Local lDelete       := .F.
Local lImpCupFis    := !LjNFFimVd()                                                                 // Indica que eh referente ao cupom fiscal
Local nMVDtlimit    := SuperGetMV("MV_DTLIMIT")                                                     // Variavel auxiliar para receber o conteudo do parametro MV_DTLIMIT
Local cBasImpCam	:= ""																			// contem a descrição dos campos para base de impostos
Local cValImpCam	:= ""																			// contem a descrição dos campos para valor de impostos
Local nPosSolCom    := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_SOLCOM"})			        // Posicao do numero da solicitacao de compra gerado para reserva sem estoque
Local nPosVldProd   := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_VLGAPRO"})			  	// Posicao do numero de dias de validade do produto
Local nPosMesRec    := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_MESREC"})			        // Posicao do numero do recno da tabela MES
Local nCartFid      := 0																			// Valor em Cartao Fidelidade
Local cCampUsr      := ""                                                                           // Campo de usuario
Local nMvLjTpDes	:= SuperGetMv( "MV_LJTPDES", , 0 )												// Indica qual desconto sera' utilizado 0 - Antigo / 1 - Novo (objeto)
Local lCAT83 		:= SL2->(ColumnPos("L2_CODLAN")) > 0 .AND. ExistFunc("FISA023").AND. SuperGetMV("MV_CAT8309",,.F.) // Verifica CAT/83

Local lDescFin      := SL1->(ColumnPos("L1_DESCFIN")) > 0
Local cSitTrib		:= ""												//Situacao Tributaria
Local nAliquota		:= 0												//Aliquota
Local nAliqRed		:= 0											    //Aliquota de reducao da base de calculo do produto
Local cTpSolCf		:= SuperGetMv("MV_TPSOLCF")                  		//Parametro para validacao do tipo de cliente para o calculo do solidario
Local lPreVenda		:= SuperGetMv("MV_LJPRVEN",,.T.)					//Sinaliza forma de gravacao do orcamento(DAV/PV)
Local lNfPafEcf	  	:= LjNfPafEcf(SM0->M0_CGC)							//Se habilitado CNPJ PAF-ECF
Local lGE 			:= ExistFunc("LjUP104OK") .AND. LjUP104OK()	 	//Validação do Conceito Garantia Estendida
Local nPosFilRes    := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_FILRES"})			        // Posicao da filial do numero da solicitacao de compra gerado para reserva sem estoque

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Release 11.5 - Carrtao Fidelidade³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local nPosNumcFi	:= 0																		    // Posicao do numero do cartao fidelidade
Local nPosDtsdFi    := 0																		    // Posicao da data de validade do saldo inserido no cartao fidelidade
Local nPosVlrcFi    := 0			    															// Posicao do valor do saldo inserido no cartao fidelidade
Local aRecSaldo  	:= {}																			// Array com os dados da recarga do cartão fidelidade
Local lLjcFid 		:= SuperGetMv("MV_LJCFID",,.F.) .AND. CrdxInt()									//Indica se a recarga de cartao fidelidade esta ativa
Local lVerEmpres    := Lj950Acres(SM0->M0_CGC)														// Verifica as filiais da trabalharam com acrescimento separado

/*Release 11..5 - Localizacoes³
Paises: Chile/Colombia-F1CHI*/
Local lLocR5        :=  cPaisLoc$"CHI|COL"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Recebe a area ativa antes da execucao da funcao LjNitCli.     ³
//³Pais: Bolivia                                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local aAreaAtiv := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Arrays de NCC Pendente e Itens da NCC. Utilizado na Integracao Protheus x SIAC,³
//³ pois gravaremos as NCCs amarradas ao salvar um orcamento aberto.			  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local aMDJ := {}
Local aMDK := {}
Local aVendDig  	:= {}  // Array com os vendedores digitados na SL2 quando cTpComiss == 2
Local oLjIntFSAn  := nil   //MAN0000604-01 - Integração Protheus x Financial Service classe da analise de credito
Local lAutoExC 		:= IsBlind()
Local cMVCliPad		:= PadR(SuperGetMV("MV_CLIPAD"),TAMSX3("LQ_CLIENTE")[1])					// Cliente padrao
Local cMVLojaPad	:= PadR(SuperGetMV("MV_LOJAPAD"),TAMSX3("LQ_LOJA")[1])                      //Loja do cliente padrao
Local lFSCliPad := .F. //Orcamento com financiamento com o financial services do cliente padrão
Local lRetFci		:= .F. //Tratamento para verificação de alteração da classificação fiscal

Local nDescAcres    	:= 0								// Desconto financeiro
Local lFTVD7052		:= ExistFunc("U_FTVD7052")														// VerIfica se existe o Ponto de Entrada
Local lUsaFecha		:= SuperGetMV("MV_LJCONFF",.T.,.F.) .AND. IIf(ExistFunc("LjUpd70Ok"),LjUpd70Ok(),.F.)		//Utilizar conf. de fechamento
Local cTransNat		:= SuperGetMV("MV_LJTRNAT",.F.,"")																//Natureza financeira da transferencia
Local lUsaTransf	:= SuperGetMV("MV_LJTRANS",.T.,.F.) .AND. !Empty(cTransNat)
Local nL1Credito 	:= 0
Local lAbateISS		:= .F.
Local cFormaPgto    := ""									// Forma de pagto
Local cNumDAVOSOrig := ""									//Guarda número da DAV
Local lMvLjDAVOS 	:= lNfPafEcf .AND. !lPreVenda .AND. SuperGetMV("MV_LJDAVOS",,.F.) //Verifica se utiliza Ordem de Serviço
Local nNFTOTAL 		:= 0
Local cMvDescSai	:= SuperGetMV("MV_DESCSAI",,"1")		// Desconto tratamento localizacoes
Local __ljAcrescFi	:= 9 											// Acréscimo financeiro Multinegociação
Local lL2IGarItem	:= SLR->(ColumnPos("LR_ITEMGAR")) > 0			// Verifica a existencia do campo L2_VLGAPRO dias de garantia
Local nPGarItem		:= iIf(lL2IGarItem, aScan(aHeader,{|x| Upper(Alltrim(x[2])) == "LR_ITEMGAR"}) ,0)
Local cItemGar		:= ""
Local nItemGar		:= 0
Local nItem			:= 0
Local lSomaGar		:= .T.
Local nRetECF		:= 0
Local lIntSiac		:=  SuperGetMV("MV_SCINTEG", .F., .F.)
Local lLjNCCOr		:= SuperGetMv("MV_LJNCCOR", Nil, .F.)	//verifica se a NCC sera mantida no orcamento (F4)
Local nPCLIENTREGA 	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_CLIENT"}) // Cliente de entrega
Local nPLOJCLIENT	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_CLILOJA"})// Filial do cliente de entrega
Local cFciCod		:= ""
Local nVlImp		:= 0
Local aSxFci		:= LjCFciParam()
Local lFciVlImpor	:= nPosVlImpor > 0 .And. aSxFci[5] .And. aSxFci[6]
Local lFciCod		:= nPosFCICod > 0 .And. aSxFci[4] .And. aSxFci[8]
Local lMultNeg		:= SuperGetMV("MV_LJMULTN", , .F.)		// Ativa Multi Negociacao
Local lParceiros	:= .F.				// Define se Habilita comissao para parceiros que indicam a loja
Local cParceiro		:= ""				// Cod Parceiro que indicou a loja (Vendedor tipo "P")
Local aParc	   		:= {}				// armazena informações dos parceiros e itens para envio de e-mail.
Local nPosParc		:= 0				// Posição do campo parceiro
Local nPosItem		:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_ITEM"})][2]		// Posicao do numero do item
Local aNFCeICMST	:= {}				//utilizado na NFC-e (contem o valores de ICMS-ST), logo sera substituido por um objeto
Local cModBc		:= ""
Local aModBc		:= {}
Local lSFinanc		:= AliasIndic("MG8") .AND. SuperGetMV("MV_LJCSF",,.F.)	// Valida implementação do servico financeiro
Local nPosItSer		:= 0													// Posicao do Item do Produto Cobertura - Servico Financeiro
Local nPosPrdCob	:= 0 													// Posicao do codigo do Produto Cobertura - Servico Financeiro
Local lEmiteNF		:= (LjNFFimVd() .OR. (nModulo == 5) .OR. (ExistFunc("LjNfNoPaf") .AND. LjNfNoPaf(SM0->M0_CGC)))
Local aArea2		:= {}
Local aAreaSM0		:= {}
Local aTimeUf		:= {}
Local lHVerao		:= SuperGetMv("MV_HVERAO",.F.,.F.) // Verifica se o local fisico do servidor está em Horário de Verão  .F. Não / .T. Sim
Local cHoraRMT		:= ""
Local lMenNota		:= SuperGetMV("MV_LJMENNO",,.F.)		// Verifica se esta habilitado a apresentacao do campo de observacao da nota fiscal
Local lRetemPCC 	:= .F.
Local cL2Origem		:= ""
Local lUseSAT		:= LjUseSat()
Local lECommerce	:= SuperGetMV("MV_LJECOMM",,.F.) .AND. SL1->L1_ECFLAG == "1" //E-commerce implantado?
Local lECExec 		:= lECommerce .AND. ( ( ExistFunc("Lj901Auto") .and. Lj901Auto() ) ) //Chamada pela rotina e-commerce CiaShop?
Local lL2CEST		:= SL2->(ColumnPos("L2_CEST")) > 0
Local lL2CmpISS		:= SL2->(ColumnPos("L2_BASEISS")) > 0 .AND. SL2->(ColumnPos("L2_ALIQISS")) > 0
Local lL2CNAE		:= SL2->(ColumnPos("L2_CNAE")) > 0		//verifica existencia do campo CNAE [ usado para NFC-e com Serviço(Nota Fácil Manaus) ] 
Local cTpFrete		:= ""
Local cMV_LJPGTRO 	:= AllTrim(SuperGetMV("MV_LJPGTRO",,IIf( cPaisLoc <> "BRA","", "R$")))
Local nTrocoRat 	:= 0 //Troco devido
Local nPerTroco 	:= 0 //percentual do troco
Local nTotParcTroc  := 0 //total de Parcelas do troco
Local nDecs		    := MsDecimais(nMoedaCor) //Decimais do troco
Local nDiffTrc 	    := 0 //Diferença do troco
Local cFormTrc 	    := IIF(ExistFunc("Lj7GetTrcForm") , Lj7GetTrcForm(), "")
Local nPosSL4 	    := 0
Local lMaFisFound	:= .F.
Local nLj7TDescV	:= 0
Local nPosECValor	:= IIF(SLR->(FieldPos("LR_ECVALOR") > 0), Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ECVALOR"}), 0)					//Mensagem do Item de Presente e-Commerce
Local nPosValIcm	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_VALICM"})  //Valor do ICMS
Local nPosBasIcm	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_BASEICM"}) //Base do ICMS
Local nPosAliIcm	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_PICM"})    //Aliquota do ICMS
Local nPosValIss	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_VALISS"})  //Valor do ISS
Local nPosBasIss	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_BASEISS"}) //Base do ISS
Local nPosAliIss	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ALIQISS"}) //Aliquota do ISS
Local nPosBsCSLL	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_BASCSLL"}) //Base do CSLL
Local nPosAlCSLL	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ALQCSLL"}) //Aliquota do CSLL
Local nPosVlCSLL	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_VALCSLL"}) //Valor do CSLL
Local nPosValPS2	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_VALPS2"})  //Valor do PIS - Apuracao
Local nPosAliPS2	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ALIQPS2"}) //Aliquota do PIS - Apuracao
Local nPosBasPS2	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_BASEPS2"}) //Base do PIS - Apuracao
Local nPosValPis	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_VALPIS"})  //Valor do PIS Retencao
Local nPosBasPis	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_BASEPIS"}) //Base do PIS Retencao
Local nPosAliPis	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ALIQPIS"}) //Aliquota do PIS - Retencao
Local nPosValCF2	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_VALCF2"})  //Valor do COFINS Apuracao
Local nPosAliCF2	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ALIQCF2"}) //Aliquota do COFINS - Apuracao
Local nPosBasCF2	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_BASECF2"}) //Base do COFINS - Apuracao
Local nPosValCof	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_VALCOFI"}) //Valor do COFINS - Retencao
Local nPosAliCof	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ALIQCOF"}) //Aliquota do COFINS - Retencao
Local nPosBasCof	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_BASECOF"}) //Base do COFINS - Retencao
Local nPosVlIrrf	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_VALIRRF"}) //Valor do IRRF
Local nPosBasIrrf	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_BASIRRF"}) //Base do IRRF
Local nPosAliIrrf   := aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ALQIRRF"}) //Aliquota do IRRF
Local nPosCCusto	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_CCUSTO"})	//Posicao do campo Centro de Custo
Local nPosItCC	    := aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ITEMCC"})	//Posicao do campo Item CC
Local nPosClvl	    := aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_CLVL"})	//Posicao do campo Classe Valor
Local nPosBasFecp	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_BASFECP"}) //Base FECP
Local nPosValFecp	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_VALFECP"}) //Valor FECP
Local nPosAlqFecp   := aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ALQFECP"}) //Aliquota FECP
Local nPosBasSTFecp	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_BSFCPST"})	//Base FECP
Local nPosValSTFecp := aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_VFECPST"}) //Valor FECP_ST
Local nPosAlqSTFecp := aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ALQFCST"})	//Aliquota FECP_ST
Local lL2FECP		:= SL2->(ColumnPos("L2_ALQFECP") > 0 .AND. ColumnPos("L2_VALFECP") > 0)
Local lL2FECPST     := SL2->(ColumnPos("L2_ALQFCST") > 0 .AND. ColumnPos("L2_VFECPST") > 0)
Local lL2BASFECP	:= SL2->(ColumnPos( "L2_BASFECP" )) > 0			// Verifica se campo existe	 
Local lL2STBASFECP	:= SL2->(ColumnPos( "L2_BSFCPST" )) > 0			// Verifica se campo Base FECP_ST existe 
Local nMVLJTRDIN 	:= SuperGetMv( "MV_LJTRDIN",,0 )		//Define se grava o valor liquido do troco em dinheiro, onde 0-Gera Valor Bruto; 1-Gera Valor Líquido
Local lMVLJGRVON	:= SuperGetMv( "MV_LJGRVON",,.F. )		//Parâmetro que identifica se será utilizado o LJGRVBATCH ou trabalhara de forma síncrona
Local nRecnoSB1		:= 0
Local cMD5Sb1   	:= ""
Local nL2PosVlIpi   := aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_VALIPI"})
Local nL2BASEIPI	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_BASEIPI"})
Local nL2IPI		:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_IPI"})
Local lL2BASEIPI	:= SL2->(ColumnPos("L2_BASEIPI")) > 0
Local lL2IPI		:= SL2->(ColumnPos("L2_IPI")) > 0
Local lL2AliqSOL	:= SL2->(ColumnPos("L2_ALIQSOL")) > 0
Local nL2ICMSRET   	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ICMSRET"})
Local nL2BRICMS   	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_BRICMS"})
Local nL2ALIQSOL   	:= aScan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_ALIQSOL"})
Local nI			:= 0

Default lReserva	:= .F.
Default nHandle		:= -1
Default lAtuData	:= .T.
Default lDefPagto   := .F.			// VerIfica se passou pela tela de definição de Pagamentos
Default cEspDoc		:= .T.
Default nDescontFi  := 0			// Desconto financeiro (configurado na condicao de pagamento) tabela SE4
Default lAlteraPrc  := .F.			// Será passado .T. quando for apenas alteração de SL4
Default nDescontFi  := 0			// Desconto financeiro (configurado na condicao de pagamento) tabela SE4
Default nTotICM		:= 0

//Tratamento Integracao Mensagem Unica - NFCe
If lIntegDef 
	If lEmitNFCe
		lEmiteNF := .F.
	EndIf		
EndIf

cHoraRMT := SuperGetMv("MV_HORARMT",.F.,"2")
If ValType(cHoraRMT) == "L"
	If cHoraRMT
		cHoraRMT := "1"
	Else
		cHoraRMT := "2"
	EndIf
Else
	If cHoraRMT == NIL
		cHoraRMT := "2"
	EndIf
EndIf

// Comissao de Parceiros que indicam a loja
lParceiros := SuperGetMv("MV_LJINDPA",,.F.) 		.AND. 	; // Habilita comissao para Parceiros que indicam a loja
				SL2->(ColumnPos("L2_INDPAR")) > 0 	.AND.	;
				SLR->(ColumnPos("LR_INDPAR")) > 0	.AND.	;
				Val(GetVersao(.F.)) >= 12
If lParceiros
	nPosParc := aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_INDPAR"})][2]
EndIf

If !lMVLJPDVPA .AND. (nOpc == 4) .AND. lMvLjDAVOS
	cNumDAVOSOrig := SL1->L1_NUMORC	//Número da DAV anterior a alteração
	Lj7CanDAVOS()
EndIf

// Cria proteção para campos incluidos no fonte loja701

If lGE
	If Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_GARANT"}) > 0
		nPosGarant	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_GARANT"	})				// Posicao do codigo do serial
	EndIf
EndIf

If lSFinanc
	nPosItSer 	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_ITEMCOB"	})
	nPosPrdCob 	:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_PRDCOBE"	})
EndIf

nPosMostruario:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_VDMOST"})][2]
nPosObsMostrua:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_VDOBS"})][2]

If LjPedVen(.F.)								// VerIfica se esta preparado para pedido de Venda
	nPosDtEntr	:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_FDTENTR"})][2]	// Posicao da Data de Entrega
	nPosDtMont	:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_FDTMONT"})][2]	// Posicao da Data de Entrega
	nPosContato	:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_CODCONT"})][2]	// Posicao da Contato do Cliente
EndIf

If GETVERSAO(.F.) >= "12"
	nPosVlTroca := aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_VLTROCA"})][2]
EndIf
If SLR->(ColumnPos("LR_FILPED")) > 0
	nPosFILPED := aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_FILPED"})][2]
EndIf
If SLR->(ColumnPos("LR_CEST")) > 0
	nI := Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_CEST"})
	nPosCEST := IIF( nI > 0, aPosCpoDet[nI][2], 0)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Release 11.5 - Cartao Fidelidade                                   ³
//³Caso a funcionalidade de recarga de cartao fidelidade estiver ativa³
//³serao acrescentadas as colunas que armazenarao os dados            ³
//³da recarga informados na tela de inclusao de saldo (LOJXFUNH)      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lLjcFid
	If SLR->( ColumnPos( "LR_NUMCFID" ) ) > 0  													// VerIfica existencia do campo
		nPosNumcFi	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_NUMCFID"})			// Posicao do numero do cartao fidelidade
	EndIf

		If SLR->( ColumnPos( "LR_DTSDFID" ) ) > 0  												// VerIfica existencia do campo
		nPosDtsdFi	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_DTSDFID"})			// Posicao da data de validade do saldo inserido no cartao fidelidade
	EndIf

	If SLR->( ColumnPos( "LR_VLRCFID" ) ) > 0  													// VerIfica existencia do campo
		nPosVlrcFi	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_VLRCFID"})			// Posicao do valor do saldo inserido no cartao fidelidade
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³				    Posicao do Vendedor  				     ³
//³Criado cTpComiss = "3" para controle de comissao por Item ³
//³        e integridade de Vendedores/Usuarios              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cTpComiss == "2" .OR. cTpComiss == "3"
	nPosVend := aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_VEND"})][2]
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Permite alteração de Nome e NIT - BOLIVIA³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc == "BOL" .AND. nTipo == 2
	aAreaAtiv := GetArea()	// salva os dados relacionados a area ativa e posicionamento
	DbSelectArea("SF3")
	If SF3->(ColumnPos("F3_NIT")) > 0 .AND. SF3->(ColumnPos("F3_RAZSOC")) > 0
		If M->LQ_CLIENTE+M->LQ_LOJA == cMV_CLIPAD+cMV_LOJAPAD
			cNomeCli 	:= ""
			cCGCCli		:= ""
		EndIf
		LjNitCli(@cNomeCli,@cCGCCli,@lNfManual)
		RestArea(aAreaAtiv)
	EndIf
EndIf

lMaFisFound := MaFisFound("NF")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Na gravacao do orcamento, nao consideramos os valores(base de|
//| calculo, valor do ICMS) calculados pela inclusao do Frete	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nTipo == 1 .AND. (M->LQ_FRETE + M->LQ_SEGURO + M->LQ_DESPESA) > 0 .AND. lMaFisFound
	MaFisAlt("NF_FRETE"		,0)
	MaFisAlt("NF_SEGURO"	,0)
	MaFisAlt("NF_DESPESA"	,0)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tabela utilizara para o cenario de vendas³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lCenVenda
	cTabCnVda 	:= LjXETabPre(M->LQ_CLIENTE,M->LQ_LOJA)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ VerIfica a obrigatoriedade dos campos da enchoice                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lTemGeraNOrc := LjTemGeraNOrc()

If lNfPafEcf

	If !lMVLJPDVPA.AND. (nOpc == 4) .AND. lMvLjDAVOS
		lTemGeraNOrc := .T.
	EndIf

	If cPaisLoc <> "BRA" .OR. !lTemGeraNOrc
		lObrigatorio := lRecebe .OR. Obrigatorio( aGets, aTela )
	Else
		lObrigatorio := .T.
	EndIf
Else
	If !LJAnalisaLeg(37)[1] .OR. !lTemGeraNOrc
		lObrigatorio := lRecebe .OR. Obrigatorio( aGets, aTela )
	Else
		lObrigatorio := .T.
	EndIf
EndIf

If !lRecebe .AND. !lObrigatorio

	If !Empty(LOG_TEF)
		LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'VerIficação de campos obrigatórios - N / N')
	EndIf

	Return .F.
EndIf

If nDtEntr > 0
	nPosDtEntr	:= aPosCpo[nDtEntr][2]			// Posicao da Data de Entrega
EndIf

If nDtMont > 0
	nPosDtMont	:= aPosCpo[nDtMont][2]			// Posicao da Data de Entrega
EndIf
If nPContato > 0
	If !Empty(aPosCpo[nPContato][2])
   		nPosContato	:= aPosCpo[nPContato][2]		// Posicao da Contato do Cliente
 	Endif
EndIf

If nPosProvEnt > 0
	nPosProvEnt	:= aPosCpo[nPosProvEnt][2]		// Posicao da provincia de entrega
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ VerIfica as variaveis do cabecalho do orcamento                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lRecebe

	If !Empty(LOG_TEF)
		LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Geração Orçamento - N')
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta os arrays utilizados na gravacao dos impostos...³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc <> "BRA"
		Lj7PrepGrvImp()
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao considerar os premios quando grava como orcamento                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If CrdXint() .AND. lUsafd .AND. nTipo == 1

		If Len( aPremio ) > 0

			nTotAux := nTotPremio

			nX := 1

			While nTotAux > 0

				nDIf := aPgtos[nX][2] - nTotAux

				If nDIf > 0
					aPgtos[nX][2] := nDIf
					Exit
				ElseIf nDIf == 0
					aDel(aPgtos,nX)
					aSize(aPgtos, Len(aPgtos) - 1)
					Exit
				Else
					nTotAux := ABS( nDIf )
					aDel(aPgtos,nX)
					aSize(aPgtos, Len(aPgtos) - 1)
				EndIf
			End
			Lj7T_TotPar(2, Lj7T_TotPar(2) - Lj7AtuPremio() )
			Lj7T_Subtotal( 2, Lj7T_Subtotal(2) - Lj7AtuPremio() )
			Lj7T_Total(2, Lj7T_Total(2) - Lj7AtuPremio(.T.))
		EndIf
	EndIf

	If (!lAlteraPrc .AND. lFtvdVer12) .OR. !lFtvdVer12
		If lNfPafEcf
		    If cPaisLoc <> "BRA" .OR. !lTemGeraNOrc
				cNumOrc 	:= M->LQ_NUM
			Else
				If nOpc <> 4 .OR. (!lMVLJPDVPA .AND. lMvLjDAVOS) //Deve-se somente gerar um novo de DAV na retaguarda quando lMvLjDAVOS == .T.
					M->LQ_NUM := GetSxENum("SL1","L1_NUM")
					ConfirmSx8()
				EndIf
			EndIf
		Else
		    If !LJAnalisaLeg(37)[1] .OR. !lTemGeraNOrc
				cNumOrc 	:= M->LQ_NUM
			Else
				If nOpc <> 4
					M->LQ_NUM := GetSxENum("SL1","L1_NUM")
					ConfirmSx8()
				EndIf
			EndIf
		EndIf
	EndIf
	cNumOrc 	:= M->LQ_NUM
	dDataOrc	:= If(lAtuData .And. !lIntegDef, dDatabase, M->LQ_EMISSAO)	
	dDataVal 	:= M->LQ_DTLIM
	
	If (M->LQ_FRETE + M->LQ_SEGURO + M->LQ_DESPESA) > 0
		nVlrFSD	:= Lj7CalcFrete()
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³Na gravacao do orcamento, nao consideramos os valores(base de|
        //| calculo, valor do ICMS) calculados pela inclusao do Frete   ³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        If nTipo == 1 .And. lMaFisFound
            MaFisAlt("NF_FRETE"  , 0)
            MaFisAlt("NF_SEGURO" , 0)
            MaFisAlt("NF_DESPESA", 0)
        EndIf
	EndIf
	cCondPgto   := If(!lLayAway,If(Empty(M->LQ_CONDPG),"CN",M->LQ_CONDPG),"LAY")

	If !Empty(LOG_TEF)
		LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Geração Orçamento - N / ' + cNumOrc + ' / ' + DToC(dDataOrc))
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³***                                       se ecf                se nota fiscal                               ³
	//³***cConfVenda :=  SubStr(cConfVenda,1,7)+If(nCheck==1,"S","N")+If(nCheck==2,"S","N")+SubStr(cConfVenda,10,3) ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³Analise de credito integrada com SIGACRD                                 ³
    //³No Finaliza Venda, a analise serah feita na rotina de gravacao da venda  ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If CrdxInt()
       For nX := 1 to Len(aPgtos)
          If AllTrim(aPgtos[nX][3]) $ cMV_FormCRD
             lTemParcFI  := .T.
          EndIf
          If !IsMoney(Alltrim(aPgtos[nX][3])) .AND. AllTrim(aPgtos[nX][3]) <> AllTrim(MVCHEQUE)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³VerIfica se deve analisar credito para a forma de pagamento e para o processo Orcamento do SIGALOJA³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
             If AllTrim(aPgtos[nX][3]) $ cMV_FormCRD .AND. "11" $ cMV_CRDAVAL
                lTemFinanc  := .T.
                Exit
             EndIf
          EndIf
       Next nX
       //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
       //³Chama a tela para selecionar a Adm. Financeira quando grava orcamento,   ³
       //³tiver ao menos uma parcela em que avalia o credito e SIGACRD integrado   ³
       //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
       If lTemFinanc
	      Lj7InfPgtos(nTipo)
       EndIf
       //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
       //³Se for finalizacao de venda, verIfica se ja ha algum contrato pendente.  ³
       //³Se tiver, utiliza este mesmo contrato para o cliente e atualiza os dados ³
       //³Busca os dados do cliente se tiver parcela financiada 					  ³
       //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
       If nOpc == 4 .AND. lTemParcFI
          If Empty(aCrdCliente[1]+aCrdCliente[2]) .AND. M->LQ_CLIENTE+M->LQ_LOJA <> cMV_CLIPAD+cMV_LOJAPAD

             Conout("1.LOJA701C - Lj7PrepOrc - Tem Parcela Financiada - " +;
             		" Orcamento: " +  M->LQ_NUM +;
             		" Cliente+LOJA : " + M->LQ_CLIENTE + M->LQ_LOJA + ;
             		"  Chama a funcao CrdInfClie(M->LQ_CLIENTE, M->LQ_LOJA) ")

             aCrdCliente   := AClone(CrdInfClie(M->LQ_CLIENTE, M->LQ_LOJA))

          Else
               	Conout("2.LOJA701C - Lj7PrepOrc - " + ;
               		"  Orcamento: " +  M->LQ_NUM +;
               		"  Cliente+Loja: " + M->LQ_CLIENTE+M->LQ_LOJA + ;
          			"  aCrdCliente[1] e [2] : " +;
          			If(Empty(aCrdCliente[1]), ";", aCrdCliente[1]) + ;
          			If(Empty(aCrdCliente[2]), ";", aCrdCliente[2]) )

          EndIf
       Else
       	   Conout("3.LOJA701C - Lj7PrepOrc - " 		+;
               	" Orcamento: " +  M->LQ_NUM 		+;
       			" nOpc = " + Alltrim(Str(nOpc)) 	+;
       			" lTemParcFI = " + If (lTemParcFI, ".T.", ".F.") )
       EndIf

	   Conout("4.LOJA701C - Lj7PrepOrc - Orcamento: " +  M->LQ_NUM     +;
	   			"  Contrato: " + If( Empty(cContrato), " ", cContrato )+;
	   			"  Total: " + Str( Lj7T_Total(2) ) +;
       			"  Chamada da funcao AprovaCrd: Lj7AprovCRD " )

       aRetCrd   := AClone(Lj7AprovCRD( "1"   ,@cContrato ,Lj7T_Total(2) ,NIL   ,;
                                         NIL   ,"11"       ,.F.           ))
       If Len(aRetCrd) > 1
          If aRetCrd[5]            //Venda rejeitada
	          Conout("5.LOJA701C - Lj7PrepOrc - " +;
	               " Orcamento: " +  M->LQ_NUM +;
	               " Contrato : " + If( Empty(cContrato), " ", cContrato )  +;
	      		   " VENDA REJEITADA.. Return(.F.) " )
	         Return (.F.)
	      ElseIf aRetCrd[1] == 2  //Aprovacao off-line
	      	 Conout("6.LOJA701C - Lj7PrepOrc - " +;
	      	 	   " Orcamento: " +  M->LQ_NUM +;
	      	       " Contrato : " + If( Empty(cContrato), "", cContrato ) +;
	      		   " Aprovacao OFF-LINE " )
	         lForcada  := .T.
	      Else
	      	 Conout("7.LOJA701C - Lj7PrepOrc - " +;
	      	 	   " Orcamento: " +  M->LQ_NUM +;
	      	       " Contrato : " + If( Empty(cContrato), "", cContrato ) )
	      	   	Conout(" aRetCrd[1] = " + If( Empty(aRetCrd[1]), "", Alltrim(STR(aRetCrd[1]))))
	      	 	Conout(" aRetCrd[2] = " + If( Empty(aRetCrd[2]), "", Alltrim(STR(aRetCrd[2]))))
	      	 	Conout(" aRetCrd[3] = " + If( Empty(aRetCrd[3]), "", Alltrim(STR(aRetCrd[3]))))
	      	 	Conout(" aRetCrd[4] = " + If( Empty(aRetCrd[4]), "", aRetCrd[4]) )
	      	 	Conout(" aRetCrd[5] = " + If( Empty(aRetCrd[5]), "", If(aRetCrd[5],".T.",".F.")))

	      EndIf
	   Else
	      Conout("8.LOJA701C - Lj7PrepOrc - "  +;
	      		   " Orcamento: " + M->LQ_NUM  +;
	               " Contrato : " + If( Empty(cContrato), " ", cContrato) +;
	      		   " Tamanho do array aRetCrd : " + Str(Len(aRetCrd)) )
       EndIf
    Else
    	Conout("9.LOJA701C - Lj7PrepOrc - Orcamento: " +  M->LQ_NUM + "  Sem Integracao com o CRD")
    EndIf

	If lUsaIntFS .AND. !lMVLJPDVPA    //Incluida a validacao da analise de credito

		For nX := 1 to Len(aPgtos)
			If AllTrim(aPgtos[nX][3]) == "FI"
				lTemParcFI  := .T.
			EndIf
		Next nX

	       //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	       //³Chama a tela para selecionar a Adm. Financeira quando grava orcamento,   ³
	       //³tiver ao menos uma parcela em que avalia o credito e SIGACRD integrado   ³
	       //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If 	lTemParcFI .AND. cMVCliPad + cMVLojaPad <> M->LQ_CLIENTE + M->LQ_LOJA

			Lj7InfPgtos(nTipo)

			Conout("8B.LOJA701C - Lj7PrepOrc - Orcamento: " +  M->LQ_NUM + "  Com Integracao com o Financial Service")

		ElseIf lTemParcFI .AND. cMVCliPad + cMVLojaPad == M->LQ_CLIENTE + M->LQ_LOJA

				lFSCliPad := .T.

				If !IsBlind()
					MsgAlert(STR0161) //"Para integraÇÃo com o Financial Services, o cliente do orçamento não poderá ser o padrÃo."
				Else
					Conout("8C.LOJA701C - Lj7PrepOrc - Orcamento: " +  M->LQ_NUM + "Para integracao com o Financial Services, o cliente do orçamento não poderá ser o padrao")

				EndIf

		EndIf


	EndIf


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona o SA1                                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea("SA1")
	DbSetOrder(1)
	DbSeek(xFilial("SA1")+M->LQ_CLIENTE+M->LQ_LOJA)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona o SA3                                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea("SA3")
	DbSetOrder(1)
	DbSeek(xFilial("SA3")+M->LQ_VEND)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gravacao do orcamento                                                    ³
	//³ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
	//³ A gravacao dos valores dos campos L1_VLRTOT, L1_DESCONT, L1_VLRLIQ,      ³
	//³ L1_VALBRUT, L1_VALMERC serao ajustadas na funcao LJRecTrib durante o     ³
	//³ fechamento da venda                                                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta o array aSL1                                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	aAdd( aSL1, { "L1_FILIAL", 		xFilial("SL1") } )
	aAdd( aSL1, { "L1_EMISSAO", 	dDataOrc } )

	aTimeUf := { dDataBase, Time()}

	If cPaisLoc == "BRA"
		If cHoraRMT == "3" 
			aArea2	:= GetArea()
			dbSelectArea("SM0")
			aAreaSM0	:= GetArea()
			dbSetOrder(1)
			If dbSeek(cEmpAnt+cFilAnt)
				aTimeUf := FwTimeUF(SM0->M0_ESTENT,,lHVerao)
				aTimeUf[1] := StoD(aTimeUf[1])
			EndIf
			RestArea(aAreaSM0)
			RestArea(aArea2)
		ElseIf cHoraRMT == "1" .AND. !IsBlind() 
			aTimeUf := { GetRmtDate(), GetRmtTime()}
		EndIf

	EndIf

	If lMVLJPDVPA .OR. ((lEmitNFCe .Or. lIsPafNfce) .And. !lEmiteNF)
		If !Empty(M->LQ_EMISNF) .AND. (lEmitNFCe .Or. lIsPafNfce)
			aAdd( aSL1, { "L1_EMISNF", 	  	M->LQ_EMISNF } )
		ElseIf nTipo <> 1 
			aAdd( aSL1, { "L1_EMISNF", 	  	aTimeUf[1] } )
		EndIf
	EndIf


	aAdd( aSL1, { "L1_NUM",	 		cNumOrc } )
	aAdd( aSL1, { "L1_COMIS",		SA3->A3_COMIS } )
	aAdd( aSL1, { "L1_VEND1",       "" })
	aAdd( aSL1, { "L1_VEND2",       SA3->A3_SUPER })	
	aAdd( aSL1, { "L1_VEND3",       SA3->A3_GEREN })
	aAdd( aSL1, { "L1_VEND4",       "" })
	aAdd( aSL1, { "L1_VEND5",       "" })
	aAdd( aSL1, { "L1_CLIENTE",		SA1->A1_COD } )
	aAdd( aSL1, { "L1_LOJA",		SA1->A1_LOJA } )

	//Importante limpar esse campo devido a reutilização de orçamento, afeta o LOJA140 posteriormente
	If SL1->(ColumnPos("L1_DOCCCF")) > 0
		aAdd( aSL1, {"L1_DOCCCF",""})
	EndIf
		
	If lAutoExC  //Tratamento para buscar o tipo do cliente informado no orcamento quando EXECAUTO esta posicionado o M->LQ_CLIENTE
		If !Empty(M->LQ_TIPOCLI) .AND. AllTrim(M->LQ_CLIENTE) == AllTrim(SA1->A1_COD)
			aAdd( aSL1, { "L1_TIPOCLI",		M->LQ_TIPOCLI } )
		Else
			aAdd( aSL1, { "L1_TIPOCLI",		SA1->A1_TIPO } )
		EndIf
	Else	//Tratamento para buscar o tipo do cliente informado no orcamento quando eh tela esta posicionado o SL1->L1_CLIENTE
		If !Empty(M->LQ_TIPOCLI) .AND. AllTrim(SL1->L1_CLIENTE) == AllTrim(SA1->A1_COD)
			aAdd( aSL1, { "L1_TIPOCLI",		M->LQ_TIPOCLI } )
		Else
			aAdd( aSL1, { "L1_TIPOCLI",		SA1->A1_TIPO } )
		EndIf
		
		//Tratamento para comissao dos demais vendedores na SL1
		If cPaisLoc == "BRA" .And. !lAutoExC //Funcionalidade apenas para Venda Assistida 
			For nX := 1 To 5 //Maximo de 5 vendedores 
				If SL1->(FieldPos("L1_VEND" + AllTrim(Str(nX)))) > 0 .And.; //Verifica se campo existe
					ValType(&("M->LQ_VEND" + AllTrim(Str(nX)))) <> Nil .And.; //Verifica se variavel de memoria existe			
					Empty(aSL1[aScan(aSL1, {|x| AllTrim(Upper(x[1])) == "L1_VEND" + AllTrim(Str(nX))})][2]) //Atualiza somente se posicao do vendedor no array está vazia
					
					aSL1[aScan(aSL1, {|x| AllTrim(Upper(x[1])) == "L1_VEND" + AllTrim(Str(nX))})][2] := &("M->LQ_VEND" + AllTrim(Str(nX))) //Armazena vendedor				
				EndIf	
			Next nX
		EndIf
	EndIf

	aAdd( aSL1, { "L1_DESCNF",		Lj7T_DescP(2) } )
	If nOpc == 3 .AND. nMVDtlimit != 0
		aAdd( aSL1, { "L1_DTLIM",	M->LQ_EMISSAO + nMVDtlimit } ) // Data limite de validade do orcamento segundo o MV_DTLIMIT
	Else
		aAdd( aSL1, { "L1_DTLIM",	M->LQ_DTLIM } )                // Data limite de validade do orcamento
	EndIf
	aAdd( aSL1, { "L1_PARCELA",		Len(aPgtos) } )
	aAdd( aSL1, { "L1_CONDPG",		cCondPgto } )
	aAdd( aSL1, { "L1_TIPOJUR",		M->LQ_TIPOJUR } )
	If Len(aPgtos) > 0
		cFormaPgto := aPgtos[1][3]
	EndIf
	aAdd( aSL1, { "L1_FORMPG",		cFormaPgto } )
	aAdd( aSL1, { "L1_CONFVEN",		"SSSSSSSSNSSS" } )

	If SLQ->( ColumnPos( "LQ_CODMNEG" ) ) > 0 .And. SL1->( ColumnPos( "L1_CODMNEG" ) ) > 0
		aAdd( aSL1, { "L1_CODMNEG",		M->LQ_CODMNEG } )
	EndIf

	//Deve trazer no PAF a data do ECF - efetuado teste de validacao em homologacao
	//alterando a hora do computador, devendo estar no registro a hora do ECF
	If !lAutoExC .And. lNfPafEcf
		nRet := IFStatus( nHdlECF, '1', @cRetorno )
		If nRet == 0
			aAdd( aSL1, { "L1_HORA",	 SubStr(cRetorno,1,5) } )
		Else
			aAdd( aSL1, { "L1_HORA",	 Time() } )
		EndIf
	Else
		//Quando NFCe a hora eh atualizada no momento que atualiza Doc, para evitar rejeicao de diferenca de horario
		If (!lEmitNFCe .And. !lIsPafNfce) .Or. lEmiteNF .Or. lIntegDef
			If lIntegDef .OR. lUseSAT
				aAdd( aSL1, { "L1_HORA",		Time() } )
			Else
				aAdd( aSL1, { "L1_HORA",		aTimeUf[2] } )
			EndIf
			
		EndIf
	EndIf

	If M->LQ_TPFRET == "0" .Or. M->LQ_TPFRET == "S"		// Sem Frete
		cTpFrete := "S"
	ElseIf M->LQ_TPFRET == "1" .Or. M->LQ_TPFRET == "C"	// CIF
		cTpFrete := "C"
	ElseIf M->LQ_TPFRET == "2" .Or. M->LQ_TPFRET == "F"	// FOB
		cTpFrete := "F"
	EndIf
	
	aAdd( aSL1, { "L1_TPFRET",		cTpFrete } )
	aAdd( aSL1, { "L1_FRETE", 		M->LQ_FRETE } )
	aAdd( aSL1, { "L1_SEGURO", 		M->LQ_SEGURO } )
	aAdd( aSL1, { "L1_DESPESA", 	M->LQ_DESPESA } )
	
	//Tratamento integracao Mensagem Unica
	If lIntegDef 
		aAdd( aSL1, { "L1_ESPECIE",	 	M->LQ_ESPECIE } )
		aAdd( aSL1, { "L1_SERSAT" ,	 	M->LQ_SERSAT } )
		
		//Nota Fiscal
		If AllTrim(M->LQ_ESPECIE) == "NFM" .Or. AllTrim(M->LQ_ESPECIE) == "SPED"
			aAdd( aSL1, { "L1_IMPRIME",	 	"2N" } )
		Else
			aAdd( aSL1, { "L1_IMPRIME",	 	"1N" } )
		EndIf
	Else
		aAdd( aSL1, { "L1_IMPRIME",	 	"1N" } )
	EndIf
	
	aAdd( aSL1, { "L1_TIPODES", 	Str(aDesconto[1],1,0) } )
	aAdd( aSL1, { "L1_ESTACAO", 	cEstacao } )
	aAdd( aSL1, { "L1_FATOR",		M->LQ_FATOR } )
	aAdd( aSL1, { "L1_ADMFIN", 		M->LQ_ADMFIN } )
	If ( LjConcNota() .OR. !lFiscal ) .AND. SL1->(ColumnPos("L1_IMPNF")) > 0
		aAdd( aSL1, { "L1_IMPNF", 	LjNFFimVd() } )
	EndIf
	If cPaisLoc <> "BRA"
	   aAdd( aSL1, { "L1_MOEDA", 	nMoedaCor } )
	   aAdd( aSL1, { "L1_TXMOEDA", 	nTxMoeda  } )
		If SL1->( ColumnPos( "L1_PROVENT" ) ) > 0 .AND. SLQ->( ColumnPos( "LQ_PROVENT" ) ) > 0
			aAdd( aSL1, { "L1_PROVENT", M->LQ_PROVENT } )
		EndIf
	EndIf

	If lCenVenda
		aAdd( aSL1, { "L1_TABELA", 	cTabCnVda } )
	EndIf

	If !lEmitNfce
		aAdd( aSL1, { "L1_SERPDV", 	LjGetStation("LG_SERPDV") } )
	EndIf

	If AllTrim(Str(SuperGetMv("MV_LJRGMID",,0))) $ "1|2"
   		aAdd( aSL1, { "L1_MIDIA", M->LQ_MIDIA } )
	EndIf

	If lMvLjDAVOS
		If SL1->(ColumnPos("L1_NUMFAB")) > 0
			aAdd( aSL1, { "L1_NUMFAB", 	M->LQ_NUMFAB } )
		EndIf

		If SL1->(ColumnPos("L1_MARCVEI")) > 0
			aAdd( aSL1, { "L1_MARCVEI", M->LQ_MARCVEI } )
		EndIf

		If SL1->(ColumnPos("L1_MODEVEI")) > 0
			aAdd( aSL1, { "L1_MODEVEI", M->LQ_MODEVEI } )
		EndIf

		If SL1->(ColumnPos("L1_ANOFVEI")) > 0
			aAdd( aSL1, { "L1_ANOFVEI", M->LQ_ANOFVEI } )
		EndIf

		If SL1->(ColumnPos("L1_PLACVEI")) > 0
			aAdd( aSL1, { "L1_PLACVEI", M->LQ_PLACVEI } )
		EndIf

		If SL1->(ColumnPos("L1_RNVMVEI")) > 0
			aAdd( aSL1, { "L1_RNVMVEI",	M->LQ_RNVMVEI } )
		EndIf
	EndIf

	If (SL1->(ColumnPos("L1_VEIPESQ")) > 0) .AND. (SLQ->(ColumnPos("LQ_VEIPESQ")) > 0)
		aAdd( aSL1, {"L1_VEIPESQ", M->LQ_VEIPESQ} )
	EndIf

	If (SL1->(ColumnPos("L1_VEICTIP")) > 0) .AND. (SLQ->(ColumnPos("LQ_VEICTIP")) > 0)
		aAdd( aSL1, {"L1_VEICTIP", M->LQ_VEICTIP} )
	EndIf

	If (Type("M->LQ_ECFLAG") == "C")
		aAdd( aSL1, { "L1_ECFLAG",	M->LQ_ECFLAG } )
	EndIf

	If (Type("M->LQ_ECPEDEC") == "C")
		aAdd( aSL1, { "L1_ECPEDEC",	M->LQ_ECPEDEC } )
	EndIf

	If  SL1->(ColumnPos("L1_PEDPRS") > 0) .AND. !( Empty(M->LQ_PEDPRS) )
		aAdd( aSL1, { "L1_PEDPRS",	M->LQ_PEDPRS } )
	EndIf

	// Grava se o cliente recolhera o iss na venda
	If SL1->(ColumnPos("L1_RECISS")) > 0 .AND. !( Empty(M->LQ_RECISS) )
		aAdd( aSL1, { "L1_RECISS",	M->LQ_RECISS } )
	EndIf

	If SLQ->( ColumnPos( "LQ_UMOV" ) ) > 0 .And. SL1->( ColumnPos( "L1_UMOV" ) ) > 0
		aAdd( aSL1, { "L1_UMOV",		M->LQ_UMOV } )
	EndIf

	If SLQ->( ColumnPos( "LQ_UMOVINF" ) ) > 0 .And. SL1->( ColumnPos( "L1_UMOVINF" ) ) > 0
		aAdd( aSL1, { "L1_UMOVINF",		M->LQ_UMOVINF } )
	EndIf
	
	If	(lMenNota .Or. lIntegDef) .AND.  SL1->(ColumnPos("L1_MENNOTA")) > 0	
		aAdd( aSL1, { "L1_MENNOTA",		M->LQ_MENNOTA } )
	EndIf

	If !lEmiteNF .And. lUseSAT .And. SL1->(ColumnPos("L1_SERSAT") > 0) .AND. SLG->(ColumnPos("LG_SERSAT") > 0) 
		aAdd( aSL1, { "L1_SERSAT",		LJGetStation("SERSAT") } )
	EndIf
	
	If (!lEmitNfce .Or. lIsPafNfce ) .AND. lNfPafEcf .AND. SL1->(ColumnPos("L1_NUMORC")) > 0 .AND. SL1->(ColumnPos("L1_TPORC")) > 0 .AND. !lFtvdVer12 .AND. !lIntegDef
		aSequencia	:= {}
		nTamOrc		:= TamSX3("LQ_NUMORC")[1]

		If !lMVLJPDVPA .AND. Empty(M->LQ_NUMORC)

			If lPreVenda
				LjxDNota(	SuperGetMv("MV_LJSERPRE",,"PRE")	, 1				, .T.	, 1		,;
							@aSequencia							, Space(nTamOrc), nil	, 1		,;
							999									, .F.			, ""	, Nil	,;
							nTamOrc								, .T. )
				aAdd( aSL1, { "L1_TPORC", 	"P" } )
			Else
				LjxDNota(	SuperGetMv("MV_LJSERDAV",,"DAV")	, 1				, .T.	, 1		,;
							@aSequencia							, Space(nTamOrc), nil	, 1		,;
							999									, .F.			, ""	, Nil	,;
							nTamOrc								, .T. )
				aAdd( aSL1, { "L1_TPORC", 	"D" } )
			EndIf

			If Len(aSequencia) > 0
				If Len(AllTrim(aSequencia[1][2])) < 10 .OR. Len(AllTrim(aSequencia[1][2])) > 13 // ATO COTEPE Requisito 6 Item II
					MsgAlert(STR0162 + " " + Alltrim(IIF(lPreVenda, SuperGetMv("MV_LJSERPRE",,"PRE"), SuperGetMv("MV_LJSERDAV",,"DAV"))) + " " + STR0163) // "O numero da serie" ; "da tabela SERIES DE N. FISCAIS (01) da Tabelas Genericas (SX5) deve conter 10 posicoes"
				EndIf

				M->LQ_NUMORC := aSequencia[1][2]
				aAdd( aSL1, { "L1_NUMORC", 	M->LQ_NUMORC } )
			EndIf

		ElseIf !lMVLJPDVPA .AND. lMvLjDAVOS //Deve-se somente gerar um novo de DAV na retaguarda

			LjxDNota(	SuperGetMv("MV_LJSERDAV",,"DAV")	, 1				, .T.	, 1		,;
						@aSequencia							, Space(nTamOrc), nil	, 1		,;
						999									, .F.			, ""	, Nil	,;
						nTamOrc								, .T. )

			aAdd( aSL1, { "L1_TPORC", 	"D" } )

			If Len(aSequencia) > 0
				If Len(AllTrim(aSequencia[1][2])) < 10 .OR. Len(AllTrim(aSequencia[1][2])) > 13 // ATO COTEPE Requisito 6 Item II
					MsgAlert(STR0162 + " " + Alltrim(SuperGetMv("MV_LJSERDAV",,"DAV")) + " " + STR0163) // "O numero da serie" ; "da tabela SERIES DE N. FISCAIS (01) da Tabelas Genericas (SX5) deve conter 10 posicoes"
				EndIf
				M->LQ_NUMORC := aSequencia[1][2]
				aAdd( aSL1, { "L1_NUMORC", 	M->LQ_NUMORC } )
			EndIf

			If SL1->(ColumnPos("L1_DVOSORI")) > 0
				aAdd( aSL1, { "L1_DVOSORI" , cNumDAVOSOrig } )
			EndIf

		Else
			If lIsPafNfce//Segundo ER-PAF-ECF 02.03 deve-se gerar como DAV a NFC-e com PAF
				aAdd( aSL1, { "L1_TPORC", 	"E" } )				
			Else
				If lPreVenda
					aAdd( aSL1, { "L1_TPORC", 	"P" } )
				Else
					aAdd( aSL1, { "L1_TPORC", 	"D" } )
				EndIf
			EndIf
			aAdd( aSL1, { "L1_NUMORC", 	M->LQ_NUMORC } )
		EndIf
    ElseIf lEmitNFCe .And. !lEmiteNF .And. nTipo == 2 //Somente gravar tipo E se finalizacao de venda NFC-E, se orcamento nao deve gravar por pode ser finalizado em uma estaca ECF.
		aAdd( aSL1, { "L1_TPORC", "E" } )
	EndIf
	
	//Integracao via Mensagem Unica, devera manter as informacoes do cupom enviados na integracao
 	If lIntegDef
    	aAdd(aSL1, {"L1_DOC"	, M->LQ_DOC})
    	aAdd(aSL1, {"L1_SERIE"	, M->LQ_SERIE})
    	aAdd(aSL1, {"L1_OPERADO", M->LQ_OPERADO}) 		 		
    	aAdd(aSL1, {"L1_PDV"	, M->LQ_PDV})
    	aAdd(aSL1, {"L1_EMISNF"	, M->LQ_EMISNF})
    	aAdd(aSL1, {"L1_TIPO"	, M->LQ_TIPO})
    	aAdd(aSL1, {"L1_SITUA"	, M->LQ_SITUA})
    	aAdd(aSL1, {"L1_STORC"	, M->LQ_STORC})  			
    	aAdd(aSL1, {"L1_KEYNFCE", M->LQ_KEYNFCE})
    	aAdd(aSL1, {"L1_PRONFCE", M->LQ_PRONFCE})	
    	aAdd(aSL1, {"L1_RESEHTL", M->LQ_RESEHTL})		 		 		
    	aAdd(aSL1, {"L1_DOCRPS"	, M->LQ_DOCRPS})
    	aAdd(aSL1, {"L1_SERRPS"	, M->LQ_SERRPS}) 		
    	aAdd(aSL1, {"L1_DOCPED"	, M->LQ_DOCPED})
    	aAdd(aSL1, {"L1_SERPED"	, M->LQ_SERPED}) 		
	EndIf
	
	lCondNeg := (Trim( cCondPgto ) == "CN")				// VerIfica se eh condicao negociada

	If !lCondNeg
		DbSelectArea( "SE4" )
		SE4->(DbSetOrder( 1 ))
		SE4->(DbSeek( xFilial( "SE4" ) + cCondPgto ))

		nPerDescFin   := E4_DESCFIN                                    	//Valor do desconto financeiro
		nPerAcrsFin   := E4_ACRSFIN                                    	//Valor do acrescimo financeiro
	EndIf
	If (lECExec .Or. lMultNeg) .And. M->LQ_JUROS > 0
		//Acrescimo Financiero
		nPerAcrsFin := M->LQ_JUROS
		LjGrvLog( cNumOrc , "Acrescimo Financeiro ", nPerAcrsFin)
	EndIf
	
	lMaFisFound := MaFisFound("NF")
	nNFTOTAL	:= IIf(lMaFisFound,MaFisRet(,"NF_TOTAL"),0)
	If lIntegDef
		If nNFTOTAL > 0
			nNFTOTAL := nNFTOTAL + IIF(Type("M->LQ_VALIPI") == "N", M->LQ_VALIPI, 0) //Soma o valor de IPI no Total
		EndIf
	EndIf

	If lFtvdVer12
		If lMaFisFound
			For nX := 1 To Len(aCols)
				If !aCols[nX][Len(aCols[nX])]
					nTotICM += MaFisRet(nX,"IT_DEDICM")
				EndIf
			Next nX
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Caso exista um desconto financeiro (apenas por condicao de pagamento)  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nPerDescFin > 0
        If lFtvdVer12 .AND. nOpc == 4
			Lj7T_DescV(2,0)
			Lj7T_DescP(2,0)
        EndIf
        
        nLj7TDescV	:= iif(ExistFunc("LjNewCalSol") .And. LjNewCalSol(),0 ,Lj7T_DescV(2))

		If !lFtvdVer12
			If nMvLjTpDes <> 2
                If nNCCUsada <= (nNFTOTAL - nLj7TDescV)
    				nVlrDescFin += NoRound( ( ( nNFTOTAL - nLj7TDescV - nNCCUsada) * nPerDescFin) / 100, TamSx3("L2_VRUNIT")[2] )
                EndIf
			Else
				If nNCCUsada <= (nNFTOTAL - nLj7TDescV)
					nVlrDescFin += A410Arred( ( ( nNFTOTAL - nLj7TDescV - nNCCUsada ) * nPerDescFin) / 100, "D2_DESCON" )
				EndIf
			EndIf
       ElseIf lFtvdVer12
			If nMvLjTpDes <> 2
				nVlrDescFin += NoRound((( nNFTOTAL + nTotICM - nLj7TDescV ) * nPerDescFin) / 100, TamSx3("L2_VRUNIT")[2] )
			Else
				nVlrDescFin += A410Arred(((nNFTOTAL + nTotICM - nLj7TDescV ) * nPerDescFin) / 100, "D2_DESCON" )
			EndIf
		EndIf

		nDescontFi := nVlrDescFin
		LjGrvLog( cNumOrc , "Desconto Financeiro Valor ", nVlrDescFin)		
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tira o valor do acrescimo financeiro do total porque nao deve incidir ³
	//³ impostos, pois trata-se de um acrescimo condicional (dado na condicao ³
	//³ de pagamento)                                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nPerAcrsFin > 0     	        
        If nTipo == 2
	     	If nMvLjTpDes <> 2  
				nVlrAcreFin += NoRound( ((nNFTotal - nVlrFSD - Lj7T_DescV(2)) * nPerAcrsFin) / 100, TamSx3("L2_VALDESC")[2] )
			Else
	          	nVlrAcreFin += A410Arred(((nNFTotal - nVlrFSD - Lj7T_DescV(2)) * nPerAcrsFin) / 100, "D2_VALACRS")
	        EndIf
	    Else
	    	If nMvLjTpDes <> 2  
				nVlrAcreFin += NoRound( ((nNFTotal - Lj7T_DescV(2)) * nPerAcrsFin) / 100, TamSx3("L2_VALDESC")[2] )
			Else
	          	nVlrAcreFin += A410Arred(((nNFTotal - Lj7T_DescV(2)) * nPerAcrsFin) / 100, "D2_VALACRS")
	        EndIf
	    
	    EndIf 
        LjGrvLog( cNumOrc , "Acrescimo Financeiro Valor ", nVlrAcreFin)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Release 11.5 - Localizacoes                      ³
	//³Somar o calculo de juros ao acrescimo financeiro.³
	//³Paises: Chile / Colombia  - F1CHI                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lLocR5 .AND. lCondNeg .AND. M->LQ_JUROS > 0
		nVlrAcreFin += NoRound( (nNFTOTAL * M->LQ_JUROS) / 100, TamSx3("L2_VALDESC")[2] )
	EndIf

	If lMaFisFound .AND. !(nRotina == 4 .AND. !Empty(SL1->L1_ORCRES))
		
		If nVlrAcreFin > 0 
			MaFisAlt("NF_ACRESCI", nVlrAcreFin)
		EndIf

		If cPaisLoc <> "BRA"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³L1_DESCONT -> Desconto sobre o Total sem Desc. Fin.                                           ³
			//³L1_VLRTOT  -> Total dos Itens (com Descontos aplicados) + Acresc. Fin. - Desc. Fin. - nVlrFSD ³
			//³L1_VALBRUT -> Total dos Itens (com Descontos aplicados) + Acresc. Fin. - Desc. Fin. - nVlrFSD ³
			//³L1_VLRLIQ  -> Valor das Mercadorias com Descontos e sem Imposto                               ³
			//³L1_VALMERC -> Valor das Mercadorias com Descontos e sem Imposto                               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aAdd( aSL1, { "L1_DESCONT"	, Lj7T_DescV(2) } )
			aAdd( aSL1, { "L1_VLRTOT"	, A410Arred( ( nNFTOTAL + nVlrAcreFin - nVlrDescFin - nVlrFSD ), "L1_VALIMP1",nMoedaCor) } )
			aAdd( aSL1, { "L1_VALBRUT"	, A410Arred( ( nNFTOTAL + nVlrAcreFin - nVlrDescFin - nVlrFSD ), "L1_VALIMP1",nMoedaCor) } )
			aAdd( aSL1, { "L1_VLRLIQ"	, nNFTOTAL } )
			aAdd( aSL1, { "L1_VALMERC"	, nNFTOTAL } )

		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ajuste da gravacao dos dados do SL1 para a venda                                       ³
			//³                                                                                        ³
			//³ Exemplo de gravavao dos campos                                                         ³
			//³ Venda de 1 item de R$100,00 com:                                                       ³
			//³                          L1_VLRTOT   L1_DESCONT   L1_VLRLIQ   L1_VALBRUT   L1_VALMERC  ³
			//³ Acresc.financ de 10%        100.00         0.00      110.00      110.00       100.00   ³
			//³ Descon.financ de 10%        100.00        10.00       90.00       90.00       100.00   ³
			//³ Descon.total  de 10%         90.00        10.00       90.00       90.00       100.00   ³
			//³ Descon.item   de 10%         90.00         0.00       90.00       90.00       100.00   ³
			//³	                                                                                       ³
			//³ Obs.1: A gravacao dos campos tem como base a gravacao da Venda Balcao para mantermos   ³
			//³ o legado das customizacoes.                        ³                                   ³
			//³                                                                                        ³
			//³ Obs.2: Nao eh necessario dar um RecLock no SL1, pois esta preso desde o inicio da rotina³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nLj7TDescV	:= iif(ExistFunc("LjNewCalSol") .And. LjNewCalSol(),0 ,Lj7T_DescV(2))
			aAdd( aSL1, { "L1_VLRTOT",	nNFTOTAL - nLj7TDescV })			

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se trabalhar com o conceito de acrescimo separado, ³
			//³não grava o acrescimo no valor do cupom, pois o    ³
			//³mesmo sera gravado no Contas a receber (SE1)       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lVerEmpres .OR. SuperGetMV("MV_LJICMJR",,.F.)
			   	aAdd( aSL1, { "L1_VLRLIQ",	( nNFTOTAL - nLj7TDescV + nVlrFSD - nVlrDescFin) } )
		   	   	aAdd( aSL1, { "L1_VALBRUT",	( nNFTOTAL - nLj7TDescV + nVlrFSD - nVlrDescFin) } )
			Else
		   		aAdd( aSL1, { "L1_VLRLIQ",	( nNFTOTAL - nLj7TDescV + nVlrAcreFin + nVlrFSD - nVlrDescFin) } )

		   		If nOpc == 4 .And. nTipo == 2 .And. MaFisRet(,"NF_SUFRAMA")
		   			aAdd( aSL1, { "L1_VALBRUT",	( MaFisRet(,"NF_VALMERC") - nLj7TDescV + nVlrAcreFin + nVlrFSD - nVlrDescFin) } )
		   		Else
		   	    	aAdd( aSL1, { "L1_VALBRUT",	( nNFTOTAL - nLj7TDescV + nVlrAcreFin + nVlrFSD - nVlrDescFin) } )
		   	    EndIf
			Endif

			If !MaFisRet(,"NF_SUFRAMA")
				aAdd( aSL1, { "L1_VALMERC",	MaFisRet(,"NF_VALMERC") } )
			Else
				aAdd( aSL1, { "L1_VALMERC",	MaFisRet(,"NF_VALMERC") + 	MaFisRet(,"NF_DESCZF") } )
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Desconto financeiro só será lancado ao total de desconto quando for finalização da VENDA     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aAdd( aSL1, { "L1_DESCONT",	Lj7T_DescV(2) + iIf(nTipo == 2,nVlrDescFin,0) } ) // Desconto sobre o Total +  desconto Financeiro

			If lDescFin
				aAdd( aSL1, { "L1_DESCFIN",	nVlrDescFin } ) // Desconto Financeiro
			EndIf
			
			If lIntegDef //Tratamento de impostos - Integracao
				aAdd( aSL1, { "L1_VALICM",	IIF(ValType(M->LQ_VALICM) == "N", M->LQ_VALICM, 0)} )
				aAdd( aSL1, { "L1_VALISS",	IIF(ValType(M->LQ_VALISS) == "N", M->LQ_VALISS, 0)} )
				
				//Valores de IPI
				aAdd( aSL1, { "L1_VALIPI",  IIF(ValType(M->LQ_VALIPI) == "N", M->LQ_VALIPI, 0)} )
				If SL1->( ColumnPos( "L1_BASEIPI" ) ) > 0
					aAdd( aSL1, { "L1_BASEIPI",  IIF(Type("M->LQ_BASEIPI") == "N", M->LQ_BASEIPI, 0)} )
				EndIf
				
				//Valores de ICMS Solidario (ICMS-ST)
				aAdd( aSL1, { "L1_BRICMS",  IIF(Type("M->LQ_BRICMS") == "N", M->LQ_BRICMS, 0)} )
				aAdd( aSL1, { "L1_ICMSRET",  IIF(Type("M->LQ_ICMSRET") == "N", M->LQ_ICMSRET, 0)} )
			Else
				aAdd( aSL1, { "L1_VALICM",	MaFisRet(,"NF_VALICM" ) } )
				aAdd( aSL1, { "L1_VALISS",	MaFisRet(,"NF_VALISS" ) } )
				aAdd( aSL1, { "L1_VALIPI",  MaFisRet(,"NF_VALIPI" ) } )
				
				//Valores de ICMS Solidario (ICMS-ST)
				aAdd( aSL1, { "L1_BRICMS",	MaFisRet(,"NF_BASESOL" ) } )
				aAdd( aSL1, { "L1_ICMSRET",	MaFisRet(,"NF_VALSOL" ) } )
			EndIf

			lRetemPCC := LjRetemPCC(MaFisRet(,"NF_TOTAL"), MaFisRet(,'NF_VALPIS'), MaFisRet(,'NF_VALCOF'), MaFisRet(,'NF_VALCSL'))
			
			If lIntegDef //Tratamento de impostos PIS, COFINS e CSLL - Integracao
				aAdd(aSL1, {"L1_VALPIS" , IIF(ValType(M->LQ_VALPIS) == "N", M->LQ_VALPIS, 0)})
				aAdd(aSL1, {"L1_VALCOFI", IIF(ValType(M->LQ_VALCOFI) == "N", M->LQ_VALCOFI, 0)})
				aAdd(aSL1, {"L1_VALCSLL", IIF(ValType(M->LQ_VALCSLL) == "N", M->LQ_VALCSLL, 0)})				
			ElseIf lRetemPCC
				aAdd(aSL1, {"L1_VALPIS" , If( LJPCCRet(1) > 0, LJPCCRet(1), MaFisRet(,'NF_VALPIS') ) })
				aAdd(aSL1, {"L1_VALCOFI", If( LJPCCRet(2) > 0, LJPCCRet(2), MaFisRet(,'NF_VALCOF') ) })
				aAdd(aSL1, {"L1_VALCSLL", If( LJPCCRet(3) > 0, LJPCCRet(3), MaFisRet(,'NF_VALCSL') ) })
			Else
				aAdd(aSL1, {"L1_VALPIS" , 0 })
				aAdd(aSL1, {"L1_VALCOFI", 0 })
				aAdd(aSL1, {"L1_VALCSLL", 0 })
			EndIf
	 	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se existir o campo L1_ABTOPCC (onde é gravado o valor de abatimento de PIS/COFINS/CSLL)³
			//³ grava o valor abatido do total da venda.                                               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ			
			If lRetemPCC
				aAdd(aSL1, { "L1_ABTOPCC", If( LJPCCRET()>0, LJPCCRET(), MaFisRet(,'NF_VALPIS')+MaFisRet(,'NF_VALCOF')+MaFisRet(,'NF_VALCSL') ) })
			EndIf
			
	 		aAdd(aSL1, {"L1_VALINSS", MaFisRet(,'NF_VALINS') })		 	
		 	
		 	If lIntegDef //Integracao mantem o valor do imposto IRRF enviado no xml
		 		aAdd(aSL1, {"L1_VALIRRF", IIF(ValType(M->LQ_VALIRRF) == "N", M->LQ_VALIRRF, 0)})	
		 	Else
		 		aAdd(aSL1, {"L1_VALIRRF", MaFisRet(,'NF_VALIRR') })
		 	EndIf
		 	
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Valoriza os campos referentes aos impostos variáveis...³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc <> "BRA"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Realiza a gravacao do troco em sua respectiva moeda...³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nY := 1 To nMoedExist
			If ( ( nPos := aScan( aMoedas,{ |x| x[6] == nY } ) )  > 0 )
				AAdd(aSL1,{"L1_TROCO" + Alltrim(Str(nY)), aMoedas[nPos][3]})
			EndIf
		Next nY

		For nY := 1 to Len(aImpsSL1)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³tratamento para clientes responsaveis inscritos, porque ³
			//³o calculo dos impostos na ecf sao feitos de maneira     ³
			//³diferente para esses clientes.	                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			nPos := Ascan(aSL1,{|x| Trim(x[1]) == aImpsSL1[nY][2]})

            If cPaisLoc == "ARG" .AND. ALLTRIM(SA1->A1_TIPO) == "I"
                If nPos > 0
					aSL1[nPos][2] += A410Arred(aImpsSL1[nY][8],"L1_VALIMP1")   //Valor do imposto
                Else
	               	Aadd(aSL1,{aImpsSL1[nY][2],A410Arred(aImpsSL1[nY][8],"L1_VALIMP1")})   //Valor do imposto
	            EndIf
            Else
                If nPos > 0
 					aSL1[nPos][2] += A410Arred(aImpsSL1[nY][3],"L1_VALIMP1",nMoedaCor)   //Valor do imposto
    	      	Else
	 		      	Aadd(aSL1,{aImpsSL1[nY][2],A410Arred(aImpsSL1[nY][3],"L1_VALIMP1",nMoedaCor)})   //Valor do imposto
 		      	EndIf
	      	EndIf

			nPos := Ascan(aSL1,{|x| Trim(x[1]) == aImpsSL1[nY][4]})
            If nPos > 0
				aSL1[nPos][2] += aImpsSL1[nY][5]   //Base do imposto
            Else
				Aadd(aSL1,{aImpsSL1[nY][4],aImpsSL1[nY][5]})   //Base do imposto
            EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Acerta o valor liquido abatendo o valor dos impostos...³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    	  	If aImpsSL1[nY][06] == "1"
				nPos := Ascan(aSL1,{|x| Trim(x[1]) == "L1_VLRLIQ"})
				If nPos > 0
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			  		//³ Subtrai do total o valor do imposto sem arredondamento     ³
			  		//³e depois pega apenas a parte inteira para nao dar dIferenca ³
			 		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aSL1[nPos][2] -= aImpsSL1[nY][8]

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³tratamento para clientes responsaveis inscritos, porque ³
					//³o calculo dos impostos na ecf sao feitos de maneira     ³
					//³diferente para esses clientes.	                       ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		            If cPaisLoc == "ARG" .AND. ALLTRIM(SA1->A1_TIPO) == "I"
          				aSL1[nPos][2]:=  A410Arred(aSL1[nPos][2],"L1_VALIMP1")
                    Else
						aSL1[nPos][2]:=  NoRound(aSL1[nPos][2],TamSx3("L1_VALIMP1")[2])
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³No caso do recuperamento da Venda que foi gravada   ³
					//³como orcamento verIfica os valores (Arredondamento) ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					nDIf := 1 / (10 ^ nDecimais)
					If ( SL1->L1_VALMERC > 0 ) .AND. ABS((SL1->L1_VALMERC - aSL1[nPos][2])) <= nDIf
						aSL1[nPos][2] := SL1->L1_VALMERC
					EndIf
		  		EndIf
		  	EndIf
  		Next nI

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Implementação continua. VerIfica a existencia dos elementos na Array³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Ascan(aSL1,{|x| Trim(x[1]) == "L1_VALMERC"}) > 0 .AND. Ascan(aSL1,{|x| Trim(x[1]) == "L1_VLRLIQ"}) > 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Acerta o valor da mercadoria com base no valor liquido da venda...³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aSL1[Ascan(aSL1,{|x| Trim(x[1]) == "L1_VALMERC"})][2] := aSL1[Ascan(aSL1,{|x| Trim(x[1]) == "L1_VLRLIQ"})][2]
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se existe os campos de base e valor de impostos	   ³
		//³se nao tem carregado na array aSL1 incluir zerado para nao  ³
		//³ficar sujeira quando e' modificado um orçamento ja gravado  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nX := 1 To 9
			cValImpCam := "L1_VALIMP" + StrZero(nX,1)
			cBasImpCam := "L1_BASIMP" + StrZero(nX,1)
			If SL1->( ColumnPos( cValImpCam ) ) > 0 .AND. SL1->( ColumnPos( cBasImpCam ) ) > 0
				If Ascan(aSL1,{|x| AllTrim(x[1]) == cValImpCam}) == 0 .AND. Ascan(aSL1,{|x| AllTrim(x[1]) == cBasImpCam}) == 0
					Aadd(aSL1,{cValImpCam,0})   //Valor do imposto
					Aadd(aSL1,{cBasImpCam,0})   //Base de imposto
				EndIf
			EndIf
		Next nX

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cria a lista de campos de troco. Essa lista é utilizada para³
		//³bloquear a adição automática desses campos no aSL1          ³
		//³pois eles são adicionados manualmente.                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nX := 1 To nMoedExist
			aAdd( aCposTroco, "L1_TROCO" + Alltrim(Str(nX)) )
		Next nX
	Else

		If nTPCompNCC <> 4 .AND. nNCCUsada > Lj7T_Total(2)
			nVlrTroco := 0
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Para o caso do Brasil, existe apenas a gravacao do Troco em 1 moeda³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SL1->( ColumnPos( "L1_TROCO1" ) ) > 0 .AND. GetNewPar( "MV_LJTROCO", .F. ) .AND. nVlrTroco >= 0
			If lMVLJGRVON
				AAdd( aSL1, { "L1_TROCO1", nVlrTroco } )
			ElseIf nMVLJTRDIN == 0
				AAdd( aSL1, { "L1_TROCO1", nVlrTroco } )
			Endif
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cria a lista de campos de troco. Essa lista é utilizada para³
		//³bloquear a adição automática desses campos no aSL1          ³
		//³pois eles são adicionados manualmente.                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aAdd( aCposTroco, "L1_TROCO1" )
	EndIf

	If CrdXInt()
		aAdd( aSL1, { "L1_CONTRA", cContrato })

		Conout("10.LOJA701C - Lj7PrepOrc - Orcamento: " +  M->LQ_NUM +;
               " Contrato: " + If (Empty(cContrato), "", cContrato) +;
      		   " adiciona CONTRATO no array SL1. " )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Controlar se a venda foi off-line (1) ou uma venda on-line (2) - WebService³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lForcada
		     aAdd( aSL1, {"L1_FORCADA", Str(FORCADA,1) } )
	
		     Conout("11.LOJA701C - Lj7PrepOrc - " +;
		     	   " Orcamento: " +  M->LQ_NUM +;
	               " Contrato : " + If (Empty(cContrato), "", cContrato) +;
	      		   " adiciona L1_FORCADA array SL1. " )
	
			 If SL1->(FieldPos("L1_CGCCART")) > 0
			    If Empty(aCrdCliente[1]+aCrdCliente[2]) .AND. M->LQ_CLIENTE+M->LQ_LOJA <> cMV_CLIPAD+cMV_LOJAPAD
			         aCrdCliente  := AClone(CrdInfClie(M->LQ_CLIENTE, M->LQ_LOJA))
			    EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Grava no campo L1_CGCCART o Numero do CGC/CPF ou Numero do Cartao do Cliente, o que tiver sido ³
				//³informado.                                                                                     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				AADD( aSL1, {"L1_CGCCART", If(!Empty(aCrdCliente[1]), aCrdCliente[1], aCrdCliente[2]) } )
	
				Conout("12.LOJA701C - Lj7PrepOrc - Orcamento: " +  M->LQ_NUM +;
			            " Cliente+Loja : " + M->LQ_CLIENTE+M->LQ_LOJA +;
	               		" Contrato :  " + If (Empty(cContrato), "", cContrato) +;
	               		" L1_CGCCART: " + If(!Empty(aCrdCliente[1]), aCrdCliente[1], aCrdCliente[2])+;
	               		" Preenche aSL1(L1_CGCCART) . " )
			 EndIf
		Else
	
	          Conout("13.LOJA701C - Lj7PrepOrc - Orcamento: " +  M->LQ_NUM +;
		            " Cliente+Loja : " + M->LQ_CLIENTE+M->LQ_LOJA +;
	           		" Contrato: " + If (Empty(cContrato), "", cContrato) +;
	  		   		" Preenche aSL1(FORCADA)=NAOFORCADA e  aSL1(CGCCART)= " )
	
		     aAdd( aSL1, {"L1_FORCADA", Str(NAOFORCADA,1) } )
			 aAdd( aSL1, {"L1_CGCCART", "" } )
		EndIf
    Else
    	Conout("14.LOJA701C - Lj7PrepOrc - Orcamento: " +  M->LQ_NUM + "  Sem Integracao com o CRD")
    EndIf

	aAux := {	"L1_VEND"	, "L1_JUROS"	, "L1_TIPOJUR"	, "L1_TRANSP"	,;
				"L1_ENDCOB"	, "L1_BAIRROC"	, "L1_MUNC"		, "L1_CEPC"		,;
				"L1_ESTC"	, "L1_ENDENT"	, "L1_BAIRROE"	, "L1_MUNE"		,;
				"L1_CEPE"	, "L1_ESTE"		, "L1_VOLUME"	, "L1_ESPECIE"	,;
				"L1_MARCA"	, "L1_NUMERO"	, "L1_PLIQUI"	, "L1_PBRUTO"	,;
				"L1_PLACA"	, "L1_UFPLACA"	, "L1_FRETE"	, "L1_SEGURO"	,;
				"L1_DESPESA" }
	
	If SL1->( ColumnPos( "L1_VEICUL1" ) ) > 0
		aAdd( aAux, "L1_VEICUL1" )
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Alimenta o array aSL1                                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX := 1 to Len(aAux)//Nao pode alterar o endereco de entrega por causa dos impostos fiscais
		cCampo := "M->LQ_"+Trim(Substr(aAux[nX],4,Len(aAux[nX])))
		aAdd( aSL1, { aAux[nX], &(cCampo) } )
	Next nX

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ VerIfica se existem campos de usuario que estao sendo utilizados para    ³
	//³ gravacao do SL1                                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SX3->(DbSetOrder(2))
	DbSelectArea("SL1")
	DbSetOrder(1)
	For nX := 1 to FCount()
		cCampo := FieldName(nX)
		If SX3->( DbSeek(PadR(cCampo,10," ")) )
			If	SX3->X3_PROPRI $ "UT" .AND. X3Uso(SX3->X3_USADO)
				If Ascan(aSL1,{|x| AllTrim(x[1]) == AllTrim(cCampo)}) == 0
					If !FieldName(nX) $ "L1_NUMORC|L1_TPORC|L1_PAFMD5"
						cCampo := "M->LQ_"+	Trim(Substr(FieldName(nX),4,Len(FieldName(nX))))
						aAdd( aSL1, { FieldName(nX), &(cCampo) } )
					EndIf
				EndIf
			EndIf
		EndIf
	Next nX

	LjGrvLog(cNumOrc,"EMITE NFCe",lEmitNFCe)
	If LjHomolPaf()
		LjGrvLog(cNumOrc,"EMITE NFCe no PAF-ECF",lIsPafNfce)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ VerIfica se existem campos de usuario que estao sendo utilizados para    ³
	//³ gravacao do SL2                                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aCamposU := {}
	SX3->(DbSetOrder(2))
	For nX := 1 to len(aHeader)
		If SX3->(DbSeek(aHeader[nX][2]))
			If SX3->X3_PROPRI $ "UT" .AND. X3Uso(SX3->X3_USADO)
				aAdd( aCamposU, SX3->X3_CAMPO )
			EndIf
		EndIf
	Next nX

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Analisa as proporcoes dos itens                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nVlrItens := 0
	aEval( aCols, {|x| If(!x[Len(x)], nVlrItens += x[nPosVlrItem], Nil) } )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se ha algum item deletado no aCols.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nOpc == 4	//Primeiro, para todos os países.
		If ( (AllTrim(Str(SuperGetMv("MV_LJGERSC",,1))) $ "2|3") ) .AND. ExistFunc("LA590CNCVA") //como na exclusão NF
			For nX := 1 To Len(aCols)
				If aCols[nX][Len(aCols[nX])] .AND. iif(nPosSolCom>0,!Empty(aColsDet[nX][nPosSolCom]),.F.)  //Se deletado e Número da Solicitação de Compra preenchido
   					LA590CncVA(cNumOrc,xFilial("SL1"),aColsDet[nX][nPosSolCom],IIf(nPosFilRes>0,aColsDet[nX][nPosFilRes],""))
				EndIf
			Next nX
		Endif
	EndIf
	If nOpc == 4 .AND. cPaisLoc <> "BRA"
		For nX := 1 To Len(aCols)
			If aCols[nX][Len(aCols[nX])]
				lDelete := .T.
				Exit
			EndIf
		Next nX
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Rateio de ISS - Final³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	//Iniciamos o array usado na funcao Lj7Arred, pois usaremos ela para proporcionalizar o Acrescimo Financeiro
	Lj7Arred(1)
		
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta o array aSL2³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//Quando PAF-ECF, deve armazenar o registro mesmo quando deletado no banco, sinalizando o cancelamento
	For nX := 1 to Len(aCols)
		//Qdo Paf-Ecf verifica se o aCols está em branco pois qdo linha deletada em branco não deve continuar
		If (!aCols[nX][Len(aCols[nX])] .OR. (lNfPafEcf .AND. !Empty(AllTrim(aCols[nX][2])))) .And. !(Empty( aCols[nX][nPosProd] ))

			If cTpComiss == "1"
				cVend := M->LQ_VEND
			Else
				cVend := aCols[nX][nPosVend]

				// Gravação dos Vendedores informados na L2 quando o parametro MV_LJTPCOM = 2  , serão gravados na SF2
			    If !Empty(cVend) .AND. aScan(aVendDig,cVend) == 0 // não pode haver vendedores repetidos no array
			        aAdd(aVendDig,cVend)
			    Endif

				// Comissao de Parceiros
				If lParceiros
					cParceiro := aCols[nX][nPosParc]
					If nX == 1
						Lj7SetParceiros({})
					EndIf
					aParc	 := Lj7GetParceiros()
					aAdd( aParc , { cParceiro , aCols[nX][nPosItem] , aCols[nX][nPosProd] , aCols[nX][nPosDescri] } )
					Lj7SetParceiros(aParc)
				EndIf

			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Checa se existe reserva                                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty(aColsDet[nX][nPosDtReserva])
				lReserva := .T.
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona o SB1 , SF4 e SB0                                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SB1->(DbSetOrder(1))
			SB1->(DbSeek(xFilial("SB1")+ aCols[nX][nPosProd]))

			SF4->(DbSetOrder(1))
			SF4->(DbSeek(xFilial("SF4")+ aColsDet[nX][nPosDtTes]))

			SB0->(DbSetOrder(1))
			SB0->(DbSeek(xFilial("SB0")+ aCols[nX][nPosProd]))

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Efetua o Calculo do Preco de Tabela que sera gravado no SL2              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Empty(aColsDet[nX][nPosDtPrcTab])
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Se foi escolhida uma tabela zerada para alteração, grava o valor  ³
				//³ digitado no preco unitario do item.                               ³
				//³ Caso tenha o desconto no item, este deve ser somado para que o    ³
				//³ valor de preco de tabela fique correto							  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nPrcTab := aCols[nX][nPosVrUnit] + (aCols[nX][nPosValDesc] / aCols[nX][nPosQuant])
			Else
				If cPaisLoc <> "BRA"
					If lCenVenda
						LjxeValPre(	@nPrcTab	, aCols[nX][nPosProd], M->LQ_CLIENTE, M->LQ_LOJA,;
									nMoedaCor	, aCols[nX][nPosQuant] )
					Else
						If SB0->(DbSeek(xFilial("SB0") + aCols[nX][nPosProd]))		//COD. PRODUTO
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Se existir o campo (B0_MOEDA + Tabela utilizada), verIfica se a ³
							//³ moeda da tabela e'a moeda corrente. Se nao for, faz a conversao ³
							//³ e grava o valor na moeda corrente.                              ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		    	    		If SB0->(FieldPos("B0_MOEDA" + aColsDet[nX][nPosDtTabela])) > 0
				            	If  &("SB0->B0_MOEDA" + aColsDet[nX][nPosDtTabela]) <> nMoedaCor
									nPrcTab := 	xMoeda(	aColsDet[nX][nPosDtPrcTab],;
														&("SB0->B0_MOEDA" + aColsDet[nX][nPosDtTabela]),;
														nMoedaCor,;
														dDataBase,;
														nDecimais)
		        		    	Else
									nPrcTab	:= aColsDet[nX][nPosDtPrcTab]
					    		EndIf
				    	  	Else
		        		   		nPrcTab := aColsDet[nX][nPosDtPrcTab]
				            EndIf
						Else
	        		   		nPrcTab := aColsDet[nX][nPosDtPrcTab]
						EndIf
					EndIf
				Else
					nPrcTab := aColsDet[nX][nPosDtPrcTab]
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta o array aSL2                                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aAdd( aSL2, {} )

			//PAF-ECF: Sinaliza Registro deletado -- ultima posicao do aCols sinaliza registro marcado como deletado, quando PDV PAF nao soma na Qtde de Itens
			If lNfPafEcf .AND. aCols[nX][Len(aCols[nX])]
				aAdd( aSL2[Len(aSL2)], { REG_DELETED	, .T. } )
				If !lMVLJPDVPA
					cItem := SomaIt( cItem )
				EndIf
			Else
				cItem := SomaIt( cItem )
			EndIf

			aAdd( aSL2[Len(aSL2)], { "L2_FILIAL"	, xFilial("SL2") } )
			aAdd( aSL2[Len(aSL2)], { "L2_NUM"		, cNumOrc } )
			aAdd( aSL2[Len(aSL2)], { "L2_ITEM"		, cItem } )
			aAdd( aSL2[Len(aSL2)], { "L2_PRODUTO"	, aCols[nX][nPosProd] } )
			
			If lNfPafEcf 
				//CONVÊNIO ICMS 25, DE 8 DE ABRIL DE 2016
				aAdd( aSL2[Len(aSL2)], { "L2_DESCRI", LjDscCESCF(aCols[nX][nPosDescri],nX) } )
				
				If Empty( AllTrim( SB1->B1_IPPT )) .Or. Empty( AllTrim( SB1->B1_IAT ))
					Conout(" Campo B1_IPPT/B1_IAT em branco, por ser obrigatório no PAF-ECF preenchido com conteúdo padrão ")
					LjGrvLog( NIL ," Campo B1_IPPT/B1_IAT em branco, por ser obrigatório no PAF-ECF preenchido com conteúdo padrão")
					
					nRecnoSB1 := SB1->(Recno())
					
					RecLock("SB1",.F.)
					
					If Empty( AllTrim( SB1->B1_IPPT ))
						REPLACE SB1->B1_IPPT WITH "T"
					EndIf
					
					REPLACE SB1->B1_IAT	WITH IIf( SuperGetMV("MV_ARREFAT",,"N") == "S", "A", "T" )
					SB1->(MsUnlock())
					
					cMD5Sb1 := LjxPAFMD5("SB1")
					
					RecLock("SB1",.F.)
					REPLACE SB1->B1_PAFMD5 WITH cMD5Sb1
					SB1->(MsUnlock())
					
					SB1->(DbGoTo(nRecnoSB1))
				EndIf

				If SL2->(ColumnPos("L2_IAT")) > 0
					aAdd( aSL2[Len(aSL2)], { "L2_IAT"		, IIf( SuperGetMV("MV_ARREFAT",,"N") == "S", "A", "T" ) })
				EndIf
				
				If SL2->(ColumnPos("L2_IPPT")) > 0
					aAdd( aSL2[Len(aSL2)], { "L2_IPPT"		, SB1->B1_IPPT })
				EndIf

				If SL2->(ColumnPos("L2_DECQTD")) > 0
					aAdd( aSL2[Len(aSL2)], { "L2_DECQTD", 	TamSX3("L2_QUANT")[2] } )
				EndIf
				
				If SL2->(ColumnPos("L2_DECVLU")) > 0
					aAdd( aSL2[Len(aSL2)], { "L2_DECVLU", 	TamSX3("L2_VRUNIT")[2] } )
				EndIf
			Else
				aAdd( aSL2[Len(aSL2)], { "L2_DESCRI", aCols[nX][nPosDescri] } )
			EndIf
			
			aAdd( aSL2[Len(aSL2)], { "L2_QUANT"	, aCols[nX][nPosQuant] } )

			If cPaisLoc <> "BRA"
				If cMvDescSai == "2"
					aAdd( aSL2[Len(aSL2)], { "L2_VRUNIT"	, NoRound(( MaFisRet(nX, "IT_VALMERC") - MaFisRet(nX, "IT_DESCONTO")) / aCols[nX][nPosQuant] ,TamSX3("D2_PRCVEN")[2] )  } )
				Else
					aAdd( aSL2[Len(aSL2)], { "L2_VRUNIT"	, MaFisRet(nX, "IT_PRCUNI")  } )
				EndIf
			Else
				// Somente ha SUFRAMA se for Venda Direta
				If MaFisRet(,"NF_SUFRAMA")
					If (nOpc == 3 .And. nTipo <> 1) .OR. (nOpc == 4 .And. nTipo == 2)						
						aAdd( aSL2[Len(aSL2)], { "L2_VRUNIT"	, aCols[nX][nPosVrUnit] - (MaFisRet(nX, "IT_DESCZF") / aCols[nX][nPosQuant])} )
					ElseIf nOpc == 4 .Or. nTipo == 1
						aAdd( aSL2[Len(aSL2)], { "L2_VRUNIT"	, aCols[nX][nPosVrUnit]} )
					EndIf
				Else
					aAdd( aSL2[Len(aSL2)], { "L2_VRUNIT", aCols[nX][nPosVrUnit]})
				EndIf
			EndIf

			//Campos de itens Mostruario/Saldao
			If SL2->(ColumnPos("L2_VDMOST")) > 0 .AND. nPosMostruario > 0
				aAdd( aSL2[Len(aSL2)], { "L2_VDMOST"		, aCols[nX][nPosMostruario] } )
			EndIf

			If SL2->(ColumnPos("L2_VDOBS")) > 0 .AND. nPosObsMostrua > 0
				aAdd( aSL2[Len(aSL2)], { "L2_VDOBS"			, aCols[nX][nPosObsMostrua] } )
			EndIf

			If SL2->(ColumnPos("L2_VLTROCA")) > 0 .AND. nPosVlTroca > 0
				aAdd( aSL2[Len(aSL2)], { "L2_VLTROCA"			, aCols[nX][nPosVlTroca] } )
			EndIf

			If SL2->(ColumnPos("L2_ISVFE")) > 0
				aAdd( aSL2[Len(aSL2)], { "L2_ISVFE"			, LjRetVFE() } )
			EndIf

			If SL2->(ColumnPos("L2_FILPED")) > 0  .AND. nPosFILPED > 0
				aAdd( aSL2[Len(aSL2)], { "L2_FILPED"		, aCols[nX][nPosFILPED] } )
			EndIf

			If SL2->(FieldPos("L2_CEST")) > 0  .AND. nPosCEST > 0 .AND. nPosCEST <= Len(aColsDet[nX])
				aAdd( aSL2[Len(aSL2)], { "L2_CEST"		, aColsDet[nX][nPosCEST] } )
			EndIf

			If cPaisLoc == "BRA"

				If !lFtvdVer12 .AND. nVlrAcreFin > 0	//proporcionamos o Acrescimo Financeiro ao salvar o orcamento
					aAdd( aSL2[Len(aSL2)], { "L2_VALACRS", Lj7Arred(2, 3, ((nVlrAcreFin*MaFisRet(nX,"IT_TOTAL"))/MaFisRet(,"NF_TOTAL"))) } )
				EndIf
				If lIntegDef //Tratamento Valor do Item integracao
					If aColsDet[nX][nPosDtDProp] > 0						
						aAdd( aSL2[Len(aSL2)], { "L2_VLRITEM"	, aCols[nX][nPosVlrItem] - aColsDet[nX][nPosDtDProp] } )
					Else
						aAdd( aSL2[Len(aSL2)], { "L2_VLRITEM"	, aCols[nX][nPosVlrItem]  } )
					EndIf
					//Somente no VENDA DIRETA
				ElseIf MaFisRet(,"NF_SUFRAMA")			
					If (nOpc == 3 .And. nTipo <> 1) .Or. (nOpc == 4 .And. nTipo == 2)						
						aAdd( aSL2[Len(aSL2)], { "L2_VLRITEM" , aCols[nX][nPosVlrItem] - MaFisRet(nX, "IT_DESCZF") } )
					ElseIf nOpc == 4 .Or. nTipo == 1
						aAdd( aSL2[Len(aSL2)], { "L2_VLRITEM", aCols[nX][nPosVlrItem]})
					EndIf
				Else
					aAdd( aSL2[Len(aSL2)], {"L2_VLRITEM"	, aCols[nX][nPosVlrItem]} )
				EndIf

			Else
				If cPaisLoc <> "BRA"
					If cMvDescSai == "2"
						aAdd( aSL2[Len(aSL2)], { "L2_VLRITEM"	, MaFisRet(nX, "IT_VALMERC") - MaFisRet(nX, "IT_DESCONTO") } )
					Else
						aAdd( aSL2[Len(aSL2)], { "L2_VLRITEM"	, MaFisRet(nX, "IT_VALMERC") } )
					EndIf
				Else
					If nOpc <> 4 .AND. aColsDet[nX][nPosDtDProp] <> 0 .OR. aDadosJur[1] <> 0
						aAdd( aSL2[Len(aSL2)], { "L2_VLRITEM"	, MaFisRet(nX, "IT_VALMERC")  } )
					Else
					    If (lDelete .AND. aColsDet[nX][nPosDtDProp] <> 0) .OR. (Lj7GetDescAnt() <> Lj7T_DescV(2) .AND. Lj7T_DescV(2) > 0)
						    aAdd( aSL2[Len(aSL2)], { "L2_VLRITEM"	, MaFisRet(nX, "IT_VALMERC")  } )
						Else
							aAdd( aSL2[Len(aSL2)], { "L2_VLRITEM"	, aCols[nX][nPosVlrItem]  } )
						EndIf
					EndIf
				EndIf
			EndIf

			// Quando no item da venda nao informado nenhum(BRANCO) tipo de entrega(1-Retira Posterior / 2-Retira / 3-Entrega)
			// O sistema ira considerar que o tipo de entrega sera Retira e ira gravar L2_ENTREGA igual a "2"
			aAdd( aSL2[Len(aSL2)], { "L2_ENTREGA"	, Iif(!Empty(aCols[nX][nPosEntrega]) .AND. aCols[nX][nPosEntrega]<>"2", aCols[nX][nPosEntrega], "2") } )

			If nPosDtEntr > 0
				aAdd( aSL2[Len(aSL2)], { "L2_FDTENTR"	, aCols[nX][nPosDtEntr] } )
			EndIf
			If nPosDtMont > 0
				aAdd( aSL2[Len(aSL2)], { "L2_FDTMONT"	, aCols[nX][nPosDtMont] } )
			EndIf
			If nPosContato > 0
				If !Empty(aCols[nX][nPosContato])
					aAdd( aSL2[Len(aSL2)], { "L2_CODCONT"	, aCols[nX][nPosContato] } )
				Else
					If nPCLIENTREGA > 0
						aAdd( aSL2[Len(aSL2)], { "L2_CLIENT"	, aCols[nX][nPCLIENTREGA] } )
						aAdd( aSL2[Len(aSL2)], { "L2_CLILOJA"	, aCols[nX][nPLOJCLIENT] } )
					Endif
				Endif
			EndIf
			If nPosTurno > 0 .AND. LJAnalisaLeg(47)[1]
				aAdd( aSL2[Len(aSL2)], { "L2_TURNO"	, aColsDet[nX][nPosTurno] } )
			EndIf
			
			If lIntegDef .And. !Empty(aColsDet[nX][nPosStTrib])  //Integracao mantem a tributacao informada
				Aadd(aTail(aSL2), {"L2_SITTRIB", aColsDet[nX][nPosStTrib]})
			//PAF-ECF: Quando DAV e Retaguarda PAFECF, deve armazenar SitTrib no orcamento(campo utilizado na relação de DAV´s emitidos)
			ElseIf !lPreVenda .AND. lNfPafEcf .AND. !lMVLJPDVPA .AND. SL2->(ColumnPos("L2_SITTRIB")) > 0

				Lj7Strib( @cSitTrib, @nAliquota, @nAliqRed, cTpSolCf, nX )
				Lj7AjustSt(@cSitTrib)

				Aadd( Atail(aSL2), {"L2_SITTRIB", cSitTrib} )

			ElseIf nPosStTrib > 0 .AND. (LjVassConc() .OR. lAutoExec .OR. ((lEmitNFCe .Or. lIsPafNfce) .And. !lEmiteNF))

				If lAutoExC .AND. Empty( aColsDet[nX][nPosStTrib] )
					If (lEmitNFCe .AND. !lUseSAT) .Or. lIsPafNfce
						aColsDet[nX][nPosStTrib] := AllTrim( Str(MaFisRet(nX, "IT_ALIQICM"), 5, 2) )
					Else
						aColsDet[nX][nPosStTrib] := Lj7Strib( Nil, Nil, Nil, Nil, nX )
						Lj7AjustSt( @aColsDet[nX][nPosStTrib] )
					EndIf
				ElseIf (lEmitNFCe .AND. !lUseSAT) .OR. lIsPafNfce
					aColsDet[nX][nPosStTrib] := AllTrim( Str(MaFisRet(nX, "IT_ALIQICM"), 5, 2) )
				Else
					aColsDet[nX][nPosStTrib] := Lj7Strib( Nil, Nil, Nil, Nil, nX )
					Lj7AjustSt( @aColsDet[nX][nPosStTrib] )
				EndIf

				Aadd( aTail(aSL2), {"L2_SITTRIB", aColsDet[nX][nPosStTrib]} )

			EndIf

			If nPosCodBar > 0
				aAdd( aSL2[Len(aSL2)], { "L2_CODBAR"	, aColsDet[nX][nPosCodBar] } )
			EndIf

			//Campos para otimizar geracao da NFC-e
			If (lEmitNFCe .Or. lIsPafNfce) .And. !lEmiteNF
				If lL2Origem
					cL2Origem := RetFldProd(SB1->B1_COD,"B1_ORIGEM")
					aAdd( aSL2[Len(aSL2)], { "L2_ORIGEM"	, Iif(Empty(cL2Origem), SB1->B1_ORIGEM, cL2Origem) } )
				EndIf
			EndIf

			If lL2PosIpi
				If lIntegDef
                    aAdd( aSL2[Len(aSL2)], { "L2_POSIPI", aColsDet[nX][nPosPosIpi] } )
                Else
    				aAdd( aSL2[Len(aSL2)], { "L2_POSIPI", SB1->B1_POSIPI } )
    			EndIf
    		EndIf
			
			aAdd( aSL2[Len(aSL2)], { "L2_CODISS"	, Alltrim(MaSBCampo("CODISS")) } )

			// para NFC-e conjugada, é necessário gravar a BASE e ALIQUOTA do ISS
			If lL2CmpISS
				aAdd( aSL2[Len(aSL2)], { "L2_BASEISS"	, MaFisRet(nX, "IT_BASEISS") } )
				aAdd( aSL2[Len(aSL2)], { "L2_ALIQISS"	, MaFisRet(nX, "IT_ALIQISS") } )
				If lL2CNAE
					aAdd( aSL2[Len(aSL2)], { "L2_CNAE"	, MaFisRet(nX, "IT_CNAE") } )
				EndIf
			Endif

			If lCAT83
				aAdd( aSL2[Len(aSL2)], { "L2_CODLAN"	, aColsDet[nX][nPosCodLan] } )
			EndIf

			aAdd( aSL2[Len(aSL2)], { "L2_LOCAL"		, aColsDet[nX][nPosDtLocal] } )
			aAdd( aSL2[Len(aSL2)], { "L2_UM"		, SB1->B1_UM } )

	   		If SL2->(ColumnPos( "L2_SEGUM" )) > 0
				aAdd( aSL2[Len(aSL2)], { "L2_SEGUM"		, SB1->B1_SEGUM } )
			EndIf

			If SL2->(ColumnPos( "L2_DTVALID" ) ) > 0 .AND. nPosDtValid > 0 .AND. !Empty( aColsDet[nX][nPosDtValid] )
				aAdd( aSL2[Len(aSL2)], { "L2_DTVALID"		, aColsDet[nX][nPosDtValid] } )
			EndIf

			If lParceiros
				aAdd( aSL2[Len(aSL2)], { "L2_INDPAR"	, cParceiro } )
			EndIf

			aAdd( aSL2[Len(aSL2)], { "L2_DESC"			, aCols[nX][nPosDesc] } )

			If SL2->(ColumnPos( "L2_DESCICM" )) > 0 .And. SL2->(ColumnPos( "L2_MOTDICM" )) > 0

				If MaFisRet(nX,"IT_VALICM") > 0 .And. MaFisRet(nX,"IT_DEDICM") > 0
					aAdd( aSL2[Len(aSL2)], { "L2_DESCICM"	, MaFisRet(nX,"IT_DEDICM") } )
					aAdd( aSL2[Len(aSL2)], { "L2_MOTDICM"	, MafisRet(nX,"LF_MOTICMS" ) } )
				EndIf
			EndIf

			aAdd( aSL2[Len(aSL2)], { "L2_VALDESC"	, aCols[nX][nPosValDesc] } )
			aAdd( aSL2[Len(aSL2)], { "L2_TES"		, aColsDet[nX][nPosDtTes] } )
			aAdd( aSL2[Len(aSL2)], { "L2_CF"		, aColsDet[nX][nPosDtCF] } )
			aAdd( aSL2[Len(aSL2)], { "L2_EMISSAO"	, dDataOrc } )
			aAdd( aSL2[Len(aSL2)], { "L2_GRADE"		, "N" } )
			aAdd( aSL2[Len(aSL2)], { "L2_VEND"		, cVend } )
			aAdd( aSL2[Len(aSL2)], { "L2_TABELA"	, aColsDet[nX][nPosDtTabela] } )
			aAdd( aSL2[Len(aSL2)], { "L2_RESERVA"	, aColsDet[nX][nPosDtReserva] } )
			aAdd( aSL2[Len(aSL2)], { "L2_LOJARES"	, aColsDet[nX][nPosDtLojaRes] } )
			aAdd( aSL2[Len(aSL2)], { "L2_FILRES"	, aColsDet[nX][nPosDtFilRes] } )
			aAdd( aSL2[Len(aSL2)], { "L2_NSERIE"  	, aColsDet[nX][nPosNumSerie] } )
			aAdd( aSL2[Len(aSL2)], { "L2_LOTECTL"	, aColsDet[nX][nPosLoteCTL] } )
			aAdd( aSL2[Len(aSL2)], { "L2_NLOTE"		, aColsDet[nX][nPosLote] } )
			aAdd( aSL2[Len(aSL2)], { "L2_LOCALIZ"	, aColsDet[nX][nPosLocaliz] } )

			// Cria proteção para campos incluidos no fonte loja701

	  		If lGE
				If nPosGarant > 0
					aAdd( aSL2[Len(aSL2)], { "L2_GARANT"  		, aCols[nX][nPosGarant] } )
	            EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Caso haja produto com garantia, e houve itens deletados , eh necessario
				//  reorganizar a relacao entre os itens de garantia e o produto
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	            If nPGarItem > 0 .AND. !Empty(aCols[nX][nPGarItem])
	            	nItem		:= Val(RETASC(cItem,2,.F.))   // Se o valor for "A0" sera retornado "100", e assim por diante
	            	nItemGar 	:= Val(RETASC(aCols[nX][nPGarItem],2,.F.))   // Se o valor for "A0" sera retornado "100", e assim por diante

	            	If nItem <> nX  // houve produtos deletados
		            	If lSomaGar
		            		nItem++
		            		nItemGar := nItem
		            		lSomaGar := .F.
		            	Else
		            		lSomaGar := .T.
		            		nItem--
		            		nItemGar := nItem
		            	Endif
					EndIf

	            	cItemGar	 := RETASC((nItemGar),2,.T.)   // Se o valor for "100" sera retornado A0, e assim por diante
					aAdd( aSL2[Len(aSL2)], { "L2_ITEMGAR"  , cItemGar } )
	            EndIf

	    	EndIf

			//Servico Financeiro
			If lSFinanc
				If nPosItSer > 0 .AND. nPosPrdCob > 0
					aAdd( aSL2[Len(aSL2)], { "L2_ITEMCOB"  , aCols[nX][nPosItSer] } )
					aAdd( aSL2[Len(aSL2)], { "L2_PRDCOBE"  , aCols[nX][nPosPrdCob] } )
				EndIf
			EndIf

			If SuperGetMV("MV_LJECOMM",,.F.)

				If  (nPosECPresSN > 0)
					aAdd( aSL2[Len(aSL2)], { "L2_ECPRESN" , aColsDet[nX][nPosECPresSN] } )
	            EndIf
				If  (nPosECSedex > 0)
					aAdd( aSL2[Len(aSL2)], { "L2_ECSEDEX" , aColsDet[nX][nPosECSedex] } )
	            EndIf
				If  (nPosECMensPr > 0)
					aAdd( aSL2[Len(aSL2)], { "L2_ECMSGPR" , aColsDet[nX][nPosECMensPr] } )
	            EndIf
	            If  (nPosECValor > 0)
					aAdd( aSL2[Len(aSL2)], { "L2_ECVALOR" , aColsDet[nX][nPosECValor] } )
	            EndIf
	            
	        EndIf

			If cPaisLoc <> "BRA"
				aAdd( aSL2[Len(aSL2)], { "L2_DESCPRO"	, aColsDet[nX][nPosDtDProp]} )
				If SL2->( ColumnPos( "L2_PROVENT" ) ) > 0 .AND. SLR->( ColumnPos( "LR_PROVENT" ) ) > 0 .AND. nPosProvEnt > 0
					aAdd( aSL2[Len(aSL2)], { "L2_PROVENT"	, aCols[nX][nPosProvEnt] } )
				EndIf
			EndIf

			If SL2->( ColumnPos("L2_ITEMSD1")) > 0
				aAdd( aSL2[Len(aSL2)], { "L2_ITEMSD1", "000000" } )
			EndIf
			
			If lIntegDef //Tratamento Desconto Proporcional e Preco de tabela - Integracao
				aAdd( aSL2[Len(aSL2)], { "L2_DESCPRO"	,	aColsDet[nX][nPosDtDProp]} )
				aAdd( aSL2[Len(aSL2)], { "L2_PRCTAB"	,	nPrcTab} )	
			Else
				aAdd( aSL2[Len(aSL2)], { "L2_PRCTAB"	,	nPrcTab} )
			EndIf
			
			If nPosValePre > 0
				aAdd( aSL2[Len(aSL2)], { "L2_VALEPRE", aColsDet[nX][nPosValePre]} )
			EndIf
			If SL2->( ColumnPos("L2_CODREG")) > 0
				aAdd( aSL2[Len(aSL2)], { "L2_CODREG", aColsDet[nX][nPosCodReg]} )
            EndIf
			If SL2->( ColumnPos("L2_VLDESRE")) > 0
				aAdd( aSL2[Len(aSL2)], { "L2_VLDESRE", aColsDet[nX][nPosVlDesR]} )
			EndIf

			If nPosKit > 0
				aAdd( aSL2[Len(aSL2)], {"L2_KIT", AllTrim(aCols[nX][nPosKit])} )
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Grava campos especificos do SIGAPHOTO.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nModulo == 72
				If nPosEnvelo > 0
					aAdd( aSL2[Len(aSL2)], {"L2_ENVELO", aColsDet[nX][nPosEnvelo]} )
				EndIf

				If nPosBrinde > 0
					aAdd( aSL2[Len(aSL2)], {"L2_BRINDE", aColsDet[nX][nPosBrinde]} )
				EndIf

				If nPosCliEnv > 0
					aAdd( aSL2[Len(aSL2)], {"L2_CLIENV", aColsDet[nX][nPosCliEnv]} )
				EndIf

				If nPosLojEnv > 0
					aAdd( aSL2[Len(aSL2)], {"L2_LOJENV", aColsDet[nX][nPosLojEnv]} )
				EndIf

				If nPosPa2Item > 0
					aAdd( aSL2[Len(aSL2)], {"L2_PA2ITEM", aColsDet[nX][nPosPa2Item]} )
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Grava campos do Ped de Venda+Item+Sequen ³
			//³Se houver U_UPDFAT14                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SL2->(ColumnPos("L2_PEDSC5")) > 0 .and. nPosPedSC5 > 0
				aAdd( aSL2[Len(aSL2)], {"L2_PEDSC5", aColsDet[nX][nPosPedSC5]} )
				aAdd( aSL2[Len(aSL2)], {"L2_ITESC6", aColsDet[nX][nPosIteSC6]} )
				aAdd( aSL2[Len(aSL2)], {"L2_SEQUEN", aColsDet[nX][nPosSequen]} )
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se usa reserva sem estoque. Se usar Grava numero da solicitacao de compra  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If AllTrim(Str(SuperGetMv("MV_LJGERSC",,1))) $ "2|3"
				If nPosSolCom > 0
					aAdd( aSL2[Len(aSL2)], {"L2_SOLCOM", aColsDet[nX][nPosSolCom]} )
					If nPosFilRes > 0
						aAdd( aSL2[Len(aSL2)], {"L2_FILRES", aColsDet[nX][nPosFilRes]} )		//Necessário gravar neste campo pois pode ter solicitado com outra filial
					EndIf
				EndIf
			EndIf

			If nPosMesRec > 0
				aAdd( aSL2[Len(aSL2)], {"L2_MESREC", aColsDet[nX][nPosMesRec]} )
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava Qtde dias da validade da garantia do produto   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	   		If lGE .AND. nPosVldProd > 0
				aAdd( aSL2[Len(aSL2)], {"L2_VLGAPRO", aColsDet[nX][nPosVldProd]} )
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Release 11.5 - Cartao fidelidade				³
			//³Gravacao dos campos especificos para recarga	³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lLjcFid .AND. LaFunhProd(aCols[nX][nPosProd])
				If nPosNumcFi > 0
					aAdd( aSL2[Len(aSL2)], {"L2_NUMCFID", aColsDet[nX][nPosNumcFi]} )
				EndIf
				If nPosDtsdFi > 0
					aAdd( aSL2[Len(aSL2)], {"L2_DTSDFID", aColsDet[nX][nPosDtsdFi]} )
				EndIf
				If nPosVlrcFi > 0
					aAdd( aSL2[Len(aSL2)], {"L2_VLRCFID", aColsDet[nX][nPosVlrcFi]} )
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Recarga do cartao fidelidade processada: ³
				//³B - Via processo batch (LJGRVBATCH)      ³
				//³W - Via WebService(LJCCARFID) 		    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If  (nModulo == 23) .OR. (nModulo ==12 .AND. lMvLjPdvPa)
					If Ca280CkWs ()
						//Via WebService(LJCCARFID)
						aAdd( aSL2[Len(aSL2)], {"L2_PROCFID", "W"} )
					Else
						//Via processo batch (LJGRVBATCH)
						aAdd( aSL2[Len(aSL2)], {"L2_PROCFID", "B"} )
					EndIf
				ElseIf nModulo ==12 .AND. !lMvLjPdvPa
					//Via processo batch (LJGRVBATCH)
					aAdd( aSL2[Len(aSL2)], {"L2_PROCFID", "B"} )
				EndIf

		  	EndIf

			If nPosLista > 0
				aAdd( aSL2[Len(aSL2)], {"L2_CODLPRE", aCols[nX][nPosLista]} )
				//Se for lista do tipo credito não pode ficar com o status de reserva quando for orçamento.
				If !Empty(aColsDet[nX][nPosDtReserva]) .And. aCols[nX][nPosEntrega] == "3" .And. !Empty(aCols[nX][nPosLista]) .And.;
					GetAdvfVal("ME1","ME1_TIPO",xFilial("ME1") + aCols[nX][nPosLista],2) == "1"
					lReserva := .F.
				EndIf
			EndIf

			If nPosItLista > 0
				aAdd( aSL2[Len(aSL2)], {"L2_ITLPRE", aCols[nX][nPosItLista]} )
			EndIf

			If nPosMsgLPre > 0
				aAdd( aSL2[Len(aSL2)], {"L2_MSGLPRE", aCols[nX][nPosMsgLPre]} )
			EndIf

			If nPosRevLPre > 0
				aAdd( aSL2[Len(aSL2)], {"L2_REVLPRE", aCols[nX][nPosRevLPre]} )
			EndIf

			If nPosMsmLPre > 0
				aAdd( aSL2[Len(aSL2)], {"L2_MSMLPRE", aCols[nX][nPosMsmLPre]} )
			EndIf

			If nPosRemLPre > 0
				aAdd( aSL2[Len(aSL2)], {"L2_REMLPRE", aCols[nX][nPosRemLPre]} )
			EndIf

			If lNfPafEcf .AND. lTplPCL
				nPosLR_BICO  := Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_BICO"})
				nPosLR_LEGCOD:= Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_LEGCOD"})

				If nPosLR_BICO > 0
					Aadd(aSL2[Len(aSL2)], {"L2_BICO", aCols[nX][nPosLR_BICO]} )
				EndIf

				If nPosLR_LEGCOD > 0
					Aadd(aSL2[Len(aSL2)], {"L2_LEGCOD", aCols[nX][nPosLR_LEGCOD]} )
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ VerIfica a gravacao dos impostos no SL2                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If MaFisFound("IT",nX) .AND. !(nRotina == 4 .AND. !Empty(SL1->L1_ORCRES))

				If cPaisLoc == "BRA"

					//Regra utilizada no MatxFis para verificar a modalidade da base de calculo
					If (lEmitNFCe .Or. lIsPafNfce) .AND. lL2Modbc .And. !lEmiteNF
						aModBc := MaFisRet(nX,"IT_SPED")
						If Len(aModBc) > 0
							cModBc := aModBc[1][6]
						EndIf
						aAdd( aSL2[Len(aSL2)], { "L2_MODBC", cModBc } )
					EndIf
					
					If lIntegDef //Tratamento Impostos
						aAdd( aSL2[Len(aSL2)], { "L2_VALICM",	aColsDet[nX][nPosValIcm] } ) 
						aAdd( aSL2[Len(aSL2)], { "L2_PICM",		aColsDet[nX][nPosAliIcm] } )
												
						aAdd( aSL2[Len(aSL2)], { "L2_VALISS",	aColsDet[nX][nPosValIss] } )
						aAdd( aSL2[Len(aSL2)], { "L2_ALIQISS",	aColsDet[nX][nPosAliIss] } )
						
						aAdd( aSL2[Len(aSL2)], { "L2_VALIPI", aColsDet[nX][nL2PosVlIpi] } )
						If lL2BASEIPI .And. nL2BASEIPI > 0
							aAdd( aSL2[Len(aSL2)], { "L2_BASEIPI", aColsDet[nX][nL2BASEIPI] } )
						EndIf
						If lL2IPI .And. nL2IPI > 0
							aAdd( aSL2[Len(aSL2)], { "L2_IPI", aColsDet[nX][nL2IPI] } )
						EndIf
					Else						
						aAdd( aSL2[Len(aSL2)], { "L2_VALIPI",   MaFisRet(nX,"IT_VALIPI") } )
						aAdd( aSL2[Len(aSL2)], { "L2_VALICM",	MaFisRet(nX,"IT_VALICM") } )
						aAdd( aSL2[Len(aSL2)], { "L2_VALISS",	MaFisRet(nX,"IT_VALISS") } )
					EndIf										
					
					If lIntegDef //Tratamento BaseIcm e BaseIss - Integracao 													
						aAdd( aSL2[Len(aSL2)], { "L2_BASEICM",	aColsDet[nX][nPosBasIcm] } )														
						aAdd( aSL2[Len(aSL2)], { "L2_BASEISS",	aColsDet[nX][nPosBasIss] } )					
					ElseIf !lFtvdVer12
						If cPaisLoc == "BRA" .AND. SF4->F4_BASEICM > 0 .AND. SF4->F4_BASEICM < 100 .AND. SB0->B0_ALIQRED > 0 .AND. lImpCupFis .AND. SuperGetMV("MV_MAPARES") == "N"
		   					aAdd( aSL2[Len(aSL2)], { "L2_BASEICM",	MaFisRet(nX, "IT_TOTAL") } )
						Else
		   					aAdd( aSL2[Len(aSL2)], { "L2_BASEICM",	MaFisRet(nX,"IT_BASEICM") } )
						EndIf
					ElseIf lFtvdVer12
						If cPaisLoc == "BRA" .AND. SF4->F4_BASEICM > 0 .AND. SF4->F4_BASEICM < 100 .AND. SB0->B0_ALIQRED > 0 .AND. SuperGetMV("MV_MAPARES") == "N"
	   						aAdd( aSL2[Len(aSL2)], { "L2_BASEICM",	MaFisRet(nX, "IT_TOTAL") } )
						Else
	   						aAdd( aSL2[Len(aSL2)], { "L2_BASEICM",	MaFisRet(nX,"IT_BASEICM") } )
						EndIf
					EndIf

					If lL2CEST
						aAdd( aSL2[Len(aSL2)], { "L2_CEST",	MaFisRet(nX,"IT_CEST") } )
					EndIf
					
     
                    If lIntegDef //Tratamento FECP e FECP_ST
			
						If lL2FECP .And. nPosAlqFecp > 0 .And. nPosValFecp > 0
							aAdd( aSL2[Len(aSL2)], { "L2_ALQFECP",  aColsDet[nX][nPosAlqFecp] } )
							aAdd( aSL2[Len(aSL2)], { "L2_VALFECP",  aColsDet[nX][nPosValFecp] } )
							
							If lL2BASFECP .And. nPosBasFecp > 0
								aAdd( aSL2[Len(aSL2)], { "L2_BASFECP",  aColsDet[nX][nPosBasFecp] } )
							EndIf
							
						EndIf
						
						If lL2FECPST  .And. nPosAlqSTFecp > 0 .And. nPosValSTFecp > 0
	                        aAdd( aSL2[Len(aSL2)], { "L2_ALQFCST",  aColsDet[nX][nPosAlqSTFecp] } )
	                        aAdd( aSL2[Len(aSL2)], { "L2_VFECPST",  aColsDet[nX][nPosValSTFecp] } )
	                        
	                        If lL2STBASFECP .And. nPosBasSTFecp > 0
	                       		aAdd( aSL2[Len(aSL2)], { "L2_BSFCPST",  aColsDet[nX][nPosBasSTFecp] } )
							EndIf
	                        
	                    EndIf						
						
						
					Else						
						If lL2FECP
							aAdd( aSL2[Len(aSL2)], { "L2_ALQFECP",  MaFisRet(nX, "IT_ALIQFECP") } )
							aAdd( aSL2[Len(aSL2)], { "L2_VALFECP",  MaFisRet(nX, "IT_VALFECP") } )
						EndIf
						If lL2BASFECP
							aAdd( aSL2[Len(aSL2)], { "L2_BASFECP",  MaFisRet(nX, "IT_BASFECP") } )
						EndIf

						
						If lL2FECPST
	                        aAdd( aSL2[Len(aSL2)], { "L2_ALQFCST",  MaFisRet(nX, "IT_ALFCST") } )
	                        aAdd( aSL2[Len(aSL2)], { "L2_VFECPST",  MaFisRet(nX, "IT_VFECPST") } )
	                    EndIf
                        If lL2STBASFECP
                       		aAdd( aSL2[Len(aSL2)], { "L2_BSFCPST",  MaFisRet(nX, "IT_BSFCPST") } )
						EndIf
					EndIf	

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Caso exista os campos no Itens do orcamento, gravo seus respectivos valores³
					//³ref. a PIS/COFINS de Retencao ou Apuracao                                  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Regra para o cAlculo do PIS/COFINS/CSLL                                            ³
					//³=======================================                                            ³
					//³O calculo podera ser realizado de duas formas:                                     ³
					//³                                                                                   ³
					//³1) Por Apuracao: Neste caso e` rodado no faturamento um programa                   ³
					//³para fazer a apuracao dos impostos: L2_VALPS2,  L2_VALCF2 etc, onde                ³
					//³Na venda o sistema verIfica se a TES calcula PIS/COFINS/CSLL e alimenta            ³
					//³os campos referente a estes impostos na tabela SL2.                                ³
					//³                                                                                   ³
					//³2) Por Retencao: Neste caso o calculo e` realizado na emissão da nota;             ³
					//³Regra para retenção:                                                               ³
					//³====================                                                               ³
					//³Criar uma natureza que calcule PIS/COFINS/CSLL;         							  ³
					//³Amarrar esta natureza no cadastro do cliente;                                      ³
					//³Preencher um ou todos os Campos:A1_RECPIS, A1_RECCOF e A1_RECCSLL com o valor "SIM"³
					//³                                                                                   ³
					//³Importante: Para Retencao, somente sera calculado os impostos se o produto tambem  ³
					//³ Tiver retencao de PIS/COFINS/CSLL.                                                ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Calculo do PIS/COFINS/CSLL por Retencao                                          ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If SL2->(FieldPos("L2_VALPIS")) >0 	.AND. SL2->(FieldPos("L2_VALCOFI"))>0 .AND.	;
					   SL2->(FieldPos("L2_VALCSLL"))>0 .AND. SL2->(FieldPos("L2_VALPS2")) >0 .AND.	;
					   SL2->(FieldPos("L2_BASEPS2"))>0	.AND. SL2->(FieldPos("L2_ALIQPS2"))>0 .AND.	;
					   SL2->(FieldPos("L2_VALCF2")) >0	.AND. SL2->(FieldPos("L2_BASECF2"))>0 .AND.	;
					   SL2->(FieldPos("L2_ALIQCF2"))>0	.AND. ;
					   ( SA1->A1_RECPIS == "S" .OR. SA1->A1_RECCOFI == "S" .OR. SA1->A1_RECCSLL == "S" )

						aAdd( aSL2[Len(aSL2)], { "L2_VALPIS ", MaFisRet(nX,"IT_VALPIS") } )  //Valor PIS Retencao
						aAdd( aSL2[Len(aSL2)], { "L2_ALIQPIS", MaFisRet(nX,"IT_ALIQPIS") } ) //Aliquota PIS - Retencao
						aAdd( aSL2[Len(aSL2)], { "L2_BASEPIS", MaFisRet(nX,"IT_BASEPIS") } ) //Base PIS - Retencao	

						aAdd( aSL2[Len(aSL2)], { "L2_VALCOFI", MaFisRet(nX,"IT_VALCOF") } )  //Valor COFINS - Retencao	
						aAdd( aSL2[Len(aSL2)], { "L2_ALIQCOF", MaFisRet(nX,"IT_ALIQCOF") } ) //Aliquota COFINS - Retencao	
						aAdd( aSL2[Len(aSL2)], { "L2_BASECOF", MaFisRet(nX,"IT_BASECOF") } ) //Base COFINS - Retencao

						aAdd( aSL2[Len(aSL2)], { "L2_VALCSLL" , MaFisRet(nX,"IT_VALCSL") } ) //Valor para CSLL 	
						aAdd( aSL2[Len(aSL2)], { "L2_ALQCSLL" , MaFisRet(nX,"IT_ALIQCSL") } ) //Aliquota para CSLL
						aAdd( aSL2[Len(aSL2)], { "L2_BASCSLL" , MaFisRet(nX,"IT_BASECSL") } ) //Base para CSLL
						
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Calcula PIS/COFINS/CSLL por Apuracao, onde o sistema verIfica se  ³
					//³a TES calcula os impostos                                         ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lIntegDef //Tratamento Pis / Cofins / CSLL / IRRF - Integracao Mensagem Unica
						aAdd( aSL2[Len(aSL2)], { "L2_VALPS2 ", aColsDet[nX][nPosValPS2] } ) //Valor PIS - Apuracao
						aAdd( aSL2[Len(aSL2)], { "L2_ALIQPS2", aColsDet[nX][nPosAliPS2] } ) //Aliquota PIS - Apuracao
						aAdd( aSL2[Len(aSL2)], { "L2_BASEPS2", aColsDet[nX][nPosBasPS2] } ) //Base PIS - Apuracao												 
						
						aAdd( aSL2[Len(aSL2)], { "L2_VALPIS ", aColsDet[nX][nPosValPis] } ) //Tratamento para PIS Retencao
						aAdd( aSL2[Len(aSL2)], { "L2_ALIQPIS", aColsDet[nX][nPosAliPis] } ) //Aliquota PIS - Retencao
						aAdd( aSL2[Len(aSL2)], { "L2_BASEPIS", aColsDet[nX][nPosBasPis] } ) //Base PIS - Retencao		
						
						aAdd( aSL2[Len(aSL2)], { "L2_VALCOFI" , aColsDet[nX][nPosValCof] } ) //Valor COFINS - Retencao	
						aAdd( aSL2[Len(aSL2)], { "L2_ALIQCOF", aColsDet[nX][nPosAliCof] } ) //Aliquota COFINS - Retencao	
						aAdd( aSL2[Len(aSL2)], { "L2_BASECOF", aColsDet[nX][nPosBasCof] } ) //Base COFINS - Retencao				
												
						aAdd( aSL2[Len(aSL2)], { "L2_VALCF2" , aColsDet[nX][nPosValCF2] } ) //Valor COFINS - Apuracao
						aAdd( aSL2[Len(aSL2)], { "L2_ALIQCF2", aColsDet[nX][nPosAliCF2] } ) //Aliquota COFINS - Apuracao
						aAdd( aSL2[Len(aSL2)], { "L2_BASECF2", aColsDet[nX][nPosBasCF2] } ) //Base COFINS - Apuracao						
																								
						aAdd( aSL2[Len(aSL2)], { "L2_VALCSLL" , aColsDet[nX][nPosVlCSLL] } ) //Valor para CSLL 	
						aAdd( aSL2[Len(aSL2)], { "L2_BASCSLL" , aColsDet[nX][nPosBsCSLL] } ) //Base para CSLL
						aAdd( aSL2[Len(aSL2)], { "L2_ALQCSLL" , aColsDet[nX][nPosAlCSLL] } ) //Aliquota para CSLL
						
						aAdd( aSL2[Len(aSL2)], { "L2_VALIRRF" , aColsDet[nX][nPosVlIrrf] } ) //Valor para IRRF																													
						aAdd( aSL2[Len(aSL2)], { "L2_BASIRRF", aColsDet[nX][nPosBasIrrf] } ) //Base para IRRF																
						aAdd( aSL2[Len(aSL2)], { "L2_ALQIRRF", aColsDet[nX][nPosAliIrrf] } ) //Aliquota para IRRF

						If nL2ICMSRET > 0 
							aAdd( aSL2[Len(aSL2)], { "L2_ICMSRET" , aColsDet[nX][nL2ICMSRET] } )//Valor para ICMS Solidario (ICMS-ST)
						EndIf
						If nL2BRICMS > 0																													
							aAdd( aSL2[Len(aSL2)], { "L2_BRICMS", aColsDet[nX][nL2BRICMS] } ) 	//Base para ICMS Solidario (ICMS-ST)
						EndIf
						If lL2AliqSOL .And. nL2ALIQSOL > 0																
							aAdd( aSL2[Len(aSL2)], { "L2_ALIQSOL", aColsDet[nX][nL2ALIQSOL] } ) //Aliquota para ICMS Solidario (ICMS-ST)
						EndIf						
					Else
						aAdd( aSL2[Len(aSL2)], { "L2_BASEPS2", MaFisRet(nX,"IT_BASEPS2") } )
						aAdd( aSL2[Len(aSL2)], { "L2_BASECF2", MaFisRet(nX,"IT_BASECF2") } )
	
						aAdd( aSL2[Len(aSL2)], { "L2_VALPS2" , MaFisRet(nX,"IT_VALPS2") } )
						aAdd( aSL2[Len(aSL2)], { "L2_VALCF2" , MaFisRet(nX,"IT_VALCF2") } )
	
						aAdd( aSL2[Len(aSL2)], { "L2_ALIQPS2", MaFisRet(nX,"IT_ALIQPS2") } )
						aAdd( aSL2[Len(aSL2)], { "L2_ALIQCF2", MaFisRet(nX,"IT_ALIQCF2") } )
	
						aAdd( aSL2[Len(aSL2)], { "L2_BRICMS", 	MaFisRet(nX,"IT_BASESOL") } )
						aAdd( aSL2[Len(aSL2)], { "L2_ICMSRET",	MaFisRet(nX,"IT_VALSOL") } )
					EndIf

				EndIf

				If lIntegDef
					aAdd( aSL2[Len(aSL2)], { "L2_VALFRE",	aColsDet[nX][nPosDtVlFret] } )
					aAdd( aSL2[Len(aSL2)], { "L2_DESPESA",  aColsDet[nX][nPosDtVlDesp] } )
					aAdd( aSL2[Len(aSL2)], { "L2_SEGURO",	MaFisRet(nX,"IT_SEGURO")  } )
				Else
					aAdd( aSL2[Len(aSL2)], { "L2_VALFRE",	MaFisRet(nX,"IT_FRETE") } )
					aAdd( aSL2[Len(aSL2)], { "L2_SEGURO",	MaFisRet(nX,"IT_SEGURO") } )
					aAdd( aSL2[Len(aSL2)], { "L2_DESPESA",  MaFisRet(nX,"IT_DESPESA") } )
				Endif
				
				
			ElseIf lEmitNFCe .Or. lIsPafNfce

				If nPosOrigem > 0
					aAdd( aSL2[Len(aSL2)], {"L2_ORIGEM", aColsDet[nX][nPosOrigem]} )
				EndIf

				If nPosModbc > 0
					aAdd( aSL2[Len(aSL2)], {"L2_MODBC",  aColsDet[nX][nPosModbc]} )
				EndIf

				If nPosPosIpi > 0
					aAdd( aSL2[Len(aSL2)], {"L2_POSIPI", aColsDet[nX][nPosPosIpi]} )
				EndIf

			EndIf

           If nPosCodIss > 0
				aAdd( aSL2[Len(aSL2)], {"L2_CODISS", aColsDet[nX][nPosCodIss]} )
			EndIf

			If cPaisLoc <> "BRA"
		        For nY := 1 To Len(aImpsSL2[nX][3])
		        	If aImpsSL2[nX][3][nY][4] > 0 .AND. aImpsSL2[nX][3][nY][3] > 0
			        	Aadd(aSL2[Len(aSL2)],{aImpsSL2[nX][3][nY][6],aImpsSL2[nX][3][nY][4]})   //Valor do imposto
		                Aadd(aSL2[Len(aSL2)],{aImpsSL2[nX][3][nY][7],aImpsSL2[nX][3][nY][3]})   //Base do imposto
		                Aadd(aSL2[Len(aSL2)],{"L2_ALQIMP"+Substr(aImpsSL2[nX][3][nY][7],10,1),MaFisRet(nX,"IT_ALIQIV"+Substr(aImpsSL2[nX][3][nY][7],10,1))})
	            	EndIf
	            Next nY
	        EndIf

			/*
			O array aSxFci é carregado no inicio da função para funcionalidade da FCI
			aSxFci ->	[1] - MV_FISFRAS
						[2] - MV_FCIMOD
						[3] - AliasInDic("CFD")
						[4] - SD2->(FieldPos("D2_FCICOD") ) > 0
						[5] - SD2->(FieldPos("D2_VLIMPOR")) > 0
						[6] - SLR->(FieldPos("LR_VLIMPOR")) > 0 .And. SL2->(FieldPos("L2_VLIMPOR")) > 0
						[7] - SD1->(FieldPos("D1_FCICOD") ) > 0
						[8] - SLR->(FieldPos("LR_FCICOD") ) > 0 .And. SL2->(FieldPos("L2_FCICOD")) > 0
						[9] - MV_FISAUCF
			*/
		  	If lFciVlImpor .AND. nPosVlImpor > 0
				nVlimp := aCols[nX][nPosVlImpor]
			EndIf

			If lFciCod .AND. nPosFCICod > 0
				cFciCod := aCols[nX][nPosFCICod]
			EndIf

			If aSxFci[1] .And. aSxFci[9] .And. (lFciVlImpor .Or. lFciCod) .And. nPosClasFis > 0
				lRetFci := LjCRetFci(aCols[nX][nPosProd], aColsDet[nX][nPosLote], aColsDet[nX][nPosLoteCTL], @nVlImp, @cFciCod, aCols[nX][nPosClasFis], nX)
			EndIf

			If lFciVlImpor
				aAdd( aSL2[Len(aSL2)], { "L2_VLIMPOR", nVlimp } )
			EndIf

			If lFciCod
				aAdd( aSL2[Len(aSL2)], { "L2_FCICOD", cFciCod } )
			EndIf

			If nPosClasFis > 0
				If lRetFci//Caso em branco, o cClasFisc é zerado dentro o SpedRastro2
			   		aAdd( aSL2[Len(aSL2)], { "L2_CLASFIS", MaFisRet(nX,"IT_CLASFIS") } )
			   	Else
			   		aAdd( aSL2[Len(aSL2)], { "L2_CLASFIS", aCols[nX][nPosClasFis] } )
			   	EndIf
			EndIf

			//%Redução da Base do ICMS
			If nPosPRedIc > 0 .And. SL2->(ColumnPos("L2_PREDIC")) > 0 .And. SLR->(ColumnPos("LR_PREDIC")) > 0
			   	aAdd( aSL2[Len(aSL2)], { "L2_PREDIC", aCols[nX][nPosPRedIc] } )
			EndIf
			
			//Integracao via Mensagem Unica, devera manter as informacoes do cupom enviados
		 	If lIntegDef
		 		aAdd(aSL2[Len(aSL2)], {"L2_DOC"		, M->LQ_DOC})	
		 		aAdd(aSL2[Len(aSL2)], {"L2_SERIE"	, M->LQ_SERIE})	
		 		aAdd(aSL2[Len(aSL2)], {"L2_PDV"		, M->LQ_PDV})	
		 		aAdd(aSL2[Len(aSL2)], {"L2_VENDIDO", "S"})
		 		
		 		If lIntegHtl //Integracao Hotelaria
			 		aAdd(aSL2[Len(aSL2)], {"L2_CCUSTO"	, aColsDet[nX][nPosCCusto]}) 
			 		aAdd(aSL2[Len(aSL2)], {"L2_ITEMCC"	, aColsDet[nX][nPosItCC]}) 
			 		aAdd(aSL2[Len(aSL2)], {"L2_CLVL"	, aColsDet[nX][nPosClvl]}) 
				EndIf		 			
		 	EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³VerIfica os campos de usuario ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nY := 1 to Len(aCamposU)
				nPos := aScan(aHeader,{|x| Trim(x[2])==Trim(aCamposU[nY]) })
				If nPos > 0
					cCampUsr := AllTrim("L2_"+SubStr(aCamposU[nY],4))
					If Ascan( aSL2[Len(aSL2)],{|x| AllTrim(x[1]) == cCampUsr } ) == 0
						aAdd( aSL2[Len(aSL2)],{ cCampUsr , aCols[nX][nPos] } )
					EndIf
				EndIf
			Next nY
		EndIf
	Next nX
Else
	If (lNfPafEcf .AND. lTemGeraNOrc) .OR. (LJAnalisaLeg(37)[1] .AND. lTemGeraNOrc)
		If !lRecebe
			M->LQ_NUM := GetSxENum("SL1","L1_NUM")
			ConfirmSx8()
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³VerIfica se existe condicoes de pagamento que geram troco.        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lAutoExC .Or. nOpc == 4
	For nX := 1 To Len( aPgtos )
		If ( Empty(cFormTrc) .AND. (IsMoney(aPgtos[nX][3]) .OR. Trim(aPgtos[nX][3]) == "VA"  .OR. aPgtos[nX][3] $ cMV_LJPGTRO) ) .OR.;
			( !Empty(cFormTrc) .AND. cFormTrc = aPgtos[nX][3] )
			If Empty( aFormas ) .OR. (nPosSL4 := aScan( aFormas, {|ExpA1| ExpA1[1] == aPgtos[nX][3] .AND. aPgtos[nX][1] == ExpA1[4] }) ) == 0
				If cPaisLoc == "BRA"
					AAdd( aFormas , { aPgtos[nX][3] , 0 ,  , aPgtos[nX][1], aPgtos[nX][2]})
				Else
					AAdd( aFormas , { aPgtos[nX][3] , 0, aPgtos[nX][6], aPgtos[nX][1], aPgtos[nX][2] } )
				EndIf
				nTotParcTroc += aPgtos[nX][2]
			ElseIf nPosSL4 > 0
				aFormas[nPosSL4, 05] +=  aPgtos[nX][2]
				nTotParcTroc += aPgtos[nX][2]
			EndIf
		EndIf
	Next nX
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Faz o Rateio dos valores para geracao do troco por forma de pgto. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nTotalDIfForm := Lj7AjustaTroco(.T.,Nil,cFormaPgto)
If ExistFunc("Lj7SetTrcForm")
	Lj7SetTrcForm("")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³SignIfica que o usuário utilizou o troco localizado, por isso nao deve ser realizado nenhum tipo de ³
//³acerto nos totais da venda.                                                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc <> "BRA" .AND. nTotalDIfForm == 0
	nVlrTroco := 0
EndIf
For nX := 1 To Len( aFormas )
	If nTotalDIfForm > 0
		If cPaisLoc == "BRA"
			If nX < Len(aFormas)
				nPerTroco := ((aFormas[nX][5] * 100)/nTotParcTroc)
				nTrocoRat := Round(((nTotalDIfForm * nPerTroco)/100),nDecs)
				nDiffTrc += nTrocoRat
			Else
				nTrocoRat := nTotalDIfForm - nDiffTrc
				nTotalDIfForm -= nTotalDIfForm
			EndIf
			aFormas[nX][2] := nTrocoRat

		Else
			aFormas[nX][2] := Round(xMoeda(nTotalDIfForm	, nMoedaCor	, aFormas[nX][3]	, dDatabase	,;
											MsDecimais(aFormas[nX][3])+1),MsDecimais(aFormas[nX][3]))
			nTotalDIfForm -= nTotalDIfForm
		EndIf

	EndIf
Next nX

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Monta o array aSL4         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nVlrEntrada := 0
For nX := 1 to Len(aPgtos)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Calcula o valor da parcela quando o troco nao esta habilitado. Nao permite gerar parcela com valor zero³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lHabTroco .Or. lIntegDef
	   nVlrParc  := aPgtos[nX][2]
	Else
	   nVlrParc  := Round(Max(aPgtos[nX][2] - IIf(aPgtos[nX][6] <> nMoedaCor, xMoeda( nVlrTroco, nMoedaCor, aPgtos[nX][6], dDatabase ), nVlrTroco), 0), MsDecimais(aPgtos[nX][6]))
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Considera a linha zerada quando for pagto com nota de credito³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (aPgtos[nX][2] <> 0 .AND. nVlrParc <> 0 ) .OR. ( aPgtos[nX][2] == 0 .AND. Len(aPgtos) == 1 .AND. nNCCUsada > 0 )
		If !lRecebe
			aAdd( aSL4, {} )
			aAdd( aSL4[Len(aSL4)], { "L4_FILIAL"	, xFilial("SL4") } )
			aAdd( aSL4[Len(aSL4)], { "L4_NUM"		, cNumOrc	} )
			aAdd( aSL4[Len(aSL4)], { "L4_DATA"		, aPgtos[nX][1] } )
		EndIf
		If ValType(aPgtos[nX][4]) == "A" .AND. Len(aPgtos[nX][4]) > 0  .AND. ( AllTrim(aPgtos[nX][3]) $ "CC|CO|CD|FI" .Or. lMultNeg ).AND. Len(aSL4)>0
			aAdd( aSL4[Len(aSL4)], { "L4_ADMINIS"		, aPgtos[nX][4][5] } )
		EndIf
		If (IsMoney(aPgtos[nX][3]) .OR. aPgtos[nX][3] == "VA") .And. (!lAutoExC .Or. nOpc == 4)
			If !lRecebe
				If cPaisLoc == "BRA"
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Utilizado para a gravacao de troco em qualquer            |
					//³ numerario. Se for NCC nao deixa o L4_VALOR ficar negativo |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aAdd( aSL4[Len( aSL4 )], { "L4_VALOR", nVlrParc } )
				Else
					nVlrTrcAux := Round(xMoeda(nVlrTroco	, nMoedaCor	, aPgtos[nX][6]	, dDatabase	,;
										MsDecimais(aPgtos[nX][6])+1),MsDecimais(aPgtos[nX][6]))
					aAdd( aSL4[Len(aSL4)], { "L4_VALOR", 	aPgtos[nX][2] - nVlrTrcAux } )
				EndIf
								
				If !lIntegDef //Integracao Mensagem Unica nao considera troco
					nVlrTroco -= If( nVlrTroco > 0, Lj7T_Troco( 2 ), 0 )
				EndIf
			EndIf

			If cPaisLoc == "BRA"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Utilizado para a gravacao de troco em qualquer	          |
				//³ numerario.                                                |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lHabTroco
					nVlrParcela := aPgtos[nX][2]
				Else
					nVlrParcela := aPgtos[nX][2] - nVlrTroco
				EndIf
			Else
				nVlrParcela := aPgtos[nX][2] - nVlrTrcAux
			EndIf

			If nVlrTroco > 0
				nVlrTroco   -= LJ7T_Troco( 2 )
			EndIf
		Else
			If !lRecebe
				aAdd( aSL4[Len(aSL4)], { "L4_VALOR", 	aPgtos[nX][2] } )
			EndIf
			nVlrParcela := aPgtos[nX][2]
		EndIf
		If !lRecebe
			aAdd( aSL4[Len(aSL4)], { "L4_FORMA",		aPgtos[nX][3] } )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Guarda o valor do troco caso o campo exista na base³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty( aFormas )
				If cPaisLoc == "BRA"
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Utilizado para a gravacao de troco em qualquer	|
					//³ numerario se este estiver habilitado	        |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lHabTroco
						nPosRet := aScan( aFormas, { |ExpA1| ExpA1[1] == aPgtos[nX][3] .AND. ExpA1[4] == aPgtos[nX][1] } )

						If nPosRet > 0
							AAdd( aSL4[Len( aSL4 )], { "L4_TROCO", aFormas[nPosRet][2] } )
							aFormas[nPosRet][2] := 0
						EndIf
					EndIf
				Else
					nPosRet := aScan( aFormas, { |ExpA1| ExpA1[1] == aPgtos[nX][3] .AND. ExpA1[4] == aPgtos[nX][1]} )

					If nPosRet > 0
						AAdd( aSL4[Len( aSL4 )], { "L4_TROCO", aFormas[nPosRet][2] } )
						aFormas[nPosRet][2] := 0
					EndIf
				EndIf
			Else
				AAdd( aSL4[Len(aSL4)], { "L4_TROCO", 0 } )
			EndIf

			If cPaisLoc <> "BRA"
			   aAdd( aSL4[Len(aSL4)], { "L4_MOEDA",		aPgtos[nX][_MOEDA] } )
		       nMoedaParc  := aPgtos[nX][_MOEDA]
			EndIf

			If lMultNeg .And. Len(aPgtos[nX]) > 10 .And. SL4->(ColumnPos("L4_DESCMN")) > 0
				aAdd( aSL4[Len(aSL4)], { "L4_DESCMN",		aPgtos[nX][11] } )
			EndIf
			AAdd( aSL4[Len(aSL4)], { "L4_ACRSFIN", Iif(Len(aPgtos[nX]) >= __ljAcrescFi .And. ValType(aPgtos[nX][__ljAcrescFi])=="N",aPgtos[nX][__ljAcrescFi],0) } )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Novo tratamento de visualização sintetizada e para quando nao for recebimento³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lVisuSint
				aAdd( aSL4[Len(aSL4)], { "L4_FORMAID",	aPgtos[nX][8] } )
			EndIf

			If cPaisLoc == "ARG" .AND. (SL4->(FieldPos("L4_CHEQID")) > 0)
				aAdd( aSL4[Len(aSL4)], { "L4_CHEQID",	aPgtos[nX][9] } )
			EndIf

			If cPaisLoc == "ARG" .AND. (SL4->(FieldPos("L4_VLMOED1")) > 0)
				aAdd( aSL4[Len(aSL4)], { "L4_VLMOED1",	aPgtos[nX][10] } )
			EndIf
			
			//Integracao Mensagem Unica armazena informacoes Tef integradas
			If lIntegDef 								
				If Len(aPgtos[nX]) >= _CONTAHTL			
					aAdd( aSL4[Len(aSL4)], { "L4_CONHTL"	, aPgtos[nX][_CONTAHTL] } )
					
					//Armazena informacoes Tef - Integracao
					aAdd( aSL4[Len(aSL4)], { "L4_VENDTEF"	, aPgtos[nX][_TEFINTEG][1] } )
					aAdd( aSL4[Len(aSL4)], { "L4_DATATEF" 	, aPgtos[nX][_TEFINTEG][2] } )
					aAdd( aSL4[Len(aSL4)], { "L4_HORATEF" 	, aPgtos[nX][_TEFINTEG][3] } )
					aAdd( aSL4[Len(aSL4)], { "L4_DOCTEF"	, aPgtos[nX][_TEFINTEG][4] } )
					aAdd( aSL4[Len(aSL4)], { "L4_AUTORIZ"	, aPgtos[nX][_TEFINTEG][5] } )
					aAdd( aSL4[Len(aSL4)], { "L4_DATCANC"	, aPgtos[nX][_TEFINTEG][6] } )
					aAdd( aSL4[Len(aSL4)], { "L4_HORCANC"	, aPgtos[nX][_TEFINTEG][7] } )
					aAdd( aSL4[Len(aSL4)], { "L4_DOCCANC"	, aPgtos[nX][_TEFINTEG][8] } )
					aAdd( aSL4[Len(aSL4)], { "L4_INSTITU"	, aPgtos[nX][_TEFINTEG][9] } )
					aAdd( aSL4[Len(aSL4)], { "L4_NSUTEF"	, aPgtos[nX][_TEFINTEG][10]} )
					aAdd( aSL4[Len(aSL4)], { "L4_PARCTEF"	, aPgtos[nX][_TEFINTEG][11]} )	
				EndIf	
				
				If Trim(aPgtos[nX][3]) == "CH"
					aAdd( aSL4[Len(aSL4)], { "L4_ADMINIS"	, aPgtos[nX][4][04] } )
					aAdd( aSL4[Len(aSL4)], { "L4_NUMCART"	, aPgtos[nX][4][07] } )
					aAdd( aSL4[Len(aSL4)], { "L4_AGENCIA"	, aPgtos[nX][4][05] } )
					aAdd( aSL4[Len(aSL4)], { "L4_CONTA"	, aPgtos[nX][4][06] } )
					aAdd( aSL4[Len(aSL4)], { "L4_RG"		, aPgtos[nX][4][09] } )
					aAdd( aSL4[Len(aSL4)], { "L4_TELEFON"	, aPgtos[nX][4][10] } )
					aAdd( aSL4[Len(aSL4)], { "L4_COMP"   	, aPgtos[nX][4][08] } )
				EndIf		
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Checa os numerarios        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If IsMoney(aPgtos[nX][3])
			nDinheiro += Round(xMoeda(aPgtos[nX][2]	, nMoedaParc	, nMoedaCor	, dDatabase	,;
								nDecimais+1,,nTxMoeda),nDecimais)
		ElseIf Alltrim(aPgtos[nX][3]) == Alltrim(MVCHEQUE)
			nCheque += Round(xMoeda(aPgtos[nX][2]	, nMoedaParc	, nMoedaCor	, dDatabase	,;
							nDecimais+1,,nTxMoeda),nDecimais)
		ElseIf Alltrim(aPgtos[nX][3]) == "CC"
			nCartao += Round(xMoeda(aPgtos[nX][2]	, nMoedaParc	, nMoedaCor	, dDatabase	,;
							nDecimais+1,,nTxMoeda),nDecimais)
		ElseIf Alltrim(aPgtos[nX][3]) == "CD"
			nVlrDebi += Round(xMoeda(aPgtos[nX][2]	, nMoedaParc	, nMoedaCor	, dDatabase	,;
							nDecimais+1,,nTxMoeda),nDecimais)
		ElseIf Alltrim(aPgtos[nX][3]) == "CO"
			nConveni += Round(xMoeda(aPgtos[nX][2]	, nMoedaParc	, nMoedaCor	, dDatabase	,;
							nDecimais+1,,nTxMoeda),nDecimais)
		ElseIf Alltrim(aPgtos[nX][3]) $ cFormVale
			nVales += Round(xMoeda(aPgtos[nX][2]	, nMoedaParc	, nMoedaCor	, dDatabase	,;
							nDecimais+1,,nTxMoeda),nDecimais)
		ElseIf Alltrim(aPgtos[nX][3]) == "FI"
			nFinanc += Round(xMoeda(aPgtos[nX][2]	, nMoedaParc	, nMoedaCor	, dDatabase	,;
										nDecimais+1,,nTxMoeda),nDecimais)
		ElseIf lLjcFid .AND. Alltrim(aPgtos[nX][3]) == "FID"
			nCartFid	+= Round(xMoeda(aPgtos[nX][2]	, nMoedaParc	, nMoedaCor	, dDatabase	,;
							nDecimais+1,,nTxMoeda),nDecimais)
		Else
			nOutros += Round(xMoeda(aPgtos[nX][2]	, nMoedaParc	, nMoedaCor	, dDatabase	,;
							nDecimais+1,,nTxMoeda),nDecimais)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Monta o array aSL4         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If IIF(Valtype(aPgtos[nX][1]) == "D", aPgtos[nX][1] == dDatabase, CTod(aPgtos[nX][1]) == dDatabase) 
			nVlrEntrada += Round(xMoeda(nVlrParcela	, nMoedaParc	, nMoedaCor	, dDatabase	,;
								nDecimais+1,,nTxMoeda),nDecimais)
		EndIf
	ElseIf !lIntegDef .AND. ( Empty(cFormTrc) .AND. (IsMoney(aPgtos[nX][3]) .OR. Trim(aPgtos[nX][3]) == "VA"  .OR. aPgtos[nX][3] $ cMV_LJPGTRO )) .OR. ;
			( !Empty(cFormTrc) .AND. cFormTrc = aPgtos[nX][3] )
	   nVlrTroco -= If( nVlrTroco > 0, Lj7T_Troco( 2 ), 0 )
	EndIf
Next nX

LjGrvLog(cNumOrc,"PAGAMENTOS",aSL4)

If !lRecebe
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ajusta o SL1. VerIfica se eh ou nao um orcamento gerado atraves da rotina de     ³
	//³reserva. Caso afirmativo nao grava os valores no SL1 para nao gerar financeiro   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (nOpc <> 4) .OR. (nOpc == 4 .AND. Empty(SL1->L1_ORCRES) .AND. Empty(SL1->L1_FILRES))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se o troco estiver desabilitado, os campos L1_DINHEIR e L1_ENTRADA nao devem ³
		//³considerar o valor recebido a mais(troco)									³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nVlrTroco           := 0
	    If cPaisLoc == "BRA" .AND. (!lHabTroco .OR. (!lMVLJGRVON .AND. nMVLJTRDIN == 1 )) .AND. !lIntegDef
	       nVlrTroco		:= Lj7T_Troco(2)
	    EndIf
	    If nVlrEntrada > 0
	       nVlrEntrada  := nVlrEntrada
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se tem parcela em Dinheiro, atualiza o valor da entrada ³
			//³considerar o valor recebido a mais(troco)									³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	       If cPaisLoc == "BRA" .AND. (!lHabTroco .OR. (!lMVLJGRVON .AND. nMVLJTRDIN == 1 ))
	          If nDinheiro - nVlrTroco >= 0
	             nTrocoEnt  := nVlrTroco
	          Else
	             nTrocoEnt  := nDinheiro
	          EndIf
	          nVlrEntrada  := MAX(nVlrEntrada - nTrocoEnt,0)
	       EndIf
	    EndIf

		//Especie utilizada na geração de Nota Fiscal sobre Cupom Fiscal
	    if Len(aPafNotaCF) > 0
	    	aAdd( aSL1, { "L1_ESPECIE"  ,"NFCF" } )
	    EndIf

		aAdd( aSL1, { "L1_DINHEIR" ,MAX(nDinheiro - nVlrTroco, 0) } )
		aAdd( aSL1, { "L1_CHEQUES" ,nCheque } )
		aAdd( aSL1, { "L1_CARTAO"  ,nCartao } )
		aAdd( aSL1, { "L1_VLRDEBI" ,nVlrDebi } )
		aAdd( aSL1, { "L1_CONVENI" ,nConveni } )
		aAdd( aSL1, { "L1_VALES"   ,nVales } )
		aAdd( aSL1, { "L1_FINANC"  ,nFinanc } )
		aAdd( aSL1, { "L1_OUTROS"  ,nOutros } )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Caso seja Release 11.5                                        ³
		//³Caso seja Cartão Fidelidade Ativo                             ³
		//³Inclui a opção de Cartão Fidelidade no Array para contabilizar³
		//³as operações por Cartão Fidelidade.                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lLjcFid
			aAdd( aSL1, { "L1_CARTFID" ,nCartFid } )
		EndIf
		
		If lAutoExC .And. M->LQ_ENTRADA > 0 
			aAdd( aSL1, { "L1_ENTRADA", M->LQ_ENTRADA })	
		Else 
			aAdd( aSL1, { "L1_ENTRADA", nVlrEntrada })	
		EndIf

		//Verifica se o valor do ISS deve ser abatido no valor total da venda.
		lAbateISS := LJ220AbISS(Nil, Nil, SL1->L1_VALISS)

		If nNCCUsada - (LJ7T_Total(2) - ( LJPCCRet() + If(lAbateISS, SL1->L1_VALISS, 0) - nNCCGerada )) > 0
			nL1Credito := (LJ7T_Total(2) - ( LJPCCRet() + If(lAbateISS, SL1->L1_VALISS, 0) - nNCCGerada ))
		Else
			nL1Credito := nNCCUsada - nNCCGerada
		EndIf
		aAdd( aSL1, { "L1_CREDITO" ,  nL1Credito } )
		aAdd( aSL1, { "L1_RESERVA" ,If(lReserva,"S","") } )
	ElseIf (nOpc == 4) .AND. lReserva .AND. Empty(SL1->L1_DOCPED)
		aAdd( aSL1, { "L1_CREDITO" , 0 } )
	EndIf

	If lFtvdVer12
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Tratamento dos campos de transferencia de portador e ³
		//³carteira automatico (FRA)                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SL1->(FieldPos("L1_TRCXGER")) > 0
			If lUsaFecha .AND. lUsaTransf
				aAdd(aSL1,{"L1_TRCXGER",.T.})
			Else
				aAdd(aSL1,{"L1_TRCXGER",.F.})
			Endif
		Endif
		If SL1->(FieldPos("L1_TREFETI")) > 0
			aAdd(aSL1,{"L1_TREFETI",.F.})
		Endif
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gravação dos Vendores informados na L2 quando o parametro MV_LJTPCOM = 2
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX := 1 To Len(aVendDig)
		If SL1->(FieldPos("L1_VEND" + Alltrim(Str(nX)) )) > 0
			aAdd( aSL1, { "L1_VEND" + Alltrim(Str(nX))  , aVendDig[nX] })
		EndIf
	Next nX

	If lUsaIntFS .AND. !lMVLJPDVPA
	//Se tiver integracao com o financial services
	//e o orcamento não possuir financiamento, atualiza o campo em branco
		If  nOpc == 4 .AND. !Empty(M->LQ_IFSANST) .AND. lTemParcFI   //Finalização de venda
			aAdd( aSL1, { "L1_IFSANST"  , M->LQ_IFSANST })
			aAdd( aSL1, { "L1_HRST"  	, M->LQ_HRST })
			aAdd( aSL1, { "L1_USRST"  	, M->LQ_USRST})
			aAdd( aSL1, { "L1_DTST"  	, M->LQ_DTST })
		Else
			If !lTemParcFI
				aAdd( aSL1, { "L1_IFSANST"  , space(TamSX3("L1_IFSANST")[1]) })
			Else
				aAdd( aSL1, { "L1_IFSANST"  , IIF( !lFSCliPad , "9", "0") })
			EndIf
			aAdd( aSL1, { "L1_USRST"  		, space(TamSX3("L1_USRST")[1]) })
			aAdd( aSL1, { "L1_HRST"  		, space(TamSX3("L1_HRST")[1]) })
			aAdd( aSL1, { "L1_DTST"  		, CtoD("") })
		EndIf

	Else
		If lUsaIntFS .and. lMVLJPDVPA
			aAdd( aSL1, { "L1_IFSANST"  , M->LQ_IFSANST })
			aAdd( aSL1, { "L1_HRST"  	, M->LQ_HRST })
			aAdd( aSL1, { "L1_USRST"  	, M->LQ_USRST})
			aAdd( aSL1, { "L1_DTST"  	, M->LQ_DTST })
		EndIf
	EndIf

	If cPaisLoc == "ARG" .And. SL1->(ColumnPos("L1_ADIC5")) > 0 .And. SLQ->(ColumnPos("LQ_ADIC5")) > 0
		aAdd( aSL1, {"L1_ADIC5", M->LQ_ADIC5 } )
		aAdd( aSL1, {"L1_ADIC61", M->LQ_ADIC61 } )
		aAdd( aSL1, {"L1_ADIC62", M->LQ_ADIC62 } )
		aAdd( aSL1, {"L1_ADIC7", M->LQ_ADIC7 } )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Chama as rotinas de gravacao ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lFtvdVer12
		lGrava := Lj7GrvOrc( aSL1, aSL2, aSL4 )[1]
	ElseIf lFtvdVer12
		lGrava := Lj7GrvOrc( aSL1, aSL2, aSL4 , NIL  , NIL            , NIL       , NIL   , lAlteraPrc )[1]
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se a Integracao Protheus x SIAC estiver ativa,       |
	//³ou se for mantida a NCC na gravacao do orcamento,    |
	//³Carregamos o array aMDJ para que a NCC utilizada seja|
	//³ relacionada ao orcamento aberto.					|
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (lIntSiac .OR. lLjNCCOr ) .AND. Ascan( aNCCItens,{|x| x[1] == .T.} ) > 0
		// Grava as NCCs para que na subida da venda elas sejam baixadas.
		Aadd(aMDJ,{"MDJ_FILIAL"  	,xFilial("MDJ")		})
		Aadd(aMDJ,{"MDJ_DOC"  	 	,SL1->L1_DOC	 	})
		Aadd(aMDJ,{"MDJ_SERIE"   	,SL1->L1_SERIE	 	})
		Aadd(aMDJ,{"MDJ_CLIENT" 	,SL1->L1_CLIENTE 	})
		Aadd(aMDJ,{"MDJ_LOJA"  	 	,SL1->L1_LOJA		})
		Aadd(aMDJ,{"MDJ_OPERAD" 	,SL1->L1_OPERADO	})
		Aadd(aMDJ,{"MDJ_EMIS"   	,SL1->L1_EMISSAO	})
		Aadd(aMDJ,{"MDJ_NCCUSA"  	,nNCCUsada			})
		Aadd(aMDJ,{"MDJ_NCCGER" 	,nNCCGerada			})
		Aadd(aMDJ,{"MDJ_CREDIT"  	,SL1->L1_CREDITO	})
		Aadd(aMDJ,{"MDJ_NUMORC" 	,SL1->L1_NUM		})
		Aadd(aMDJ,{"MDJ_OPER"  		,"B"				})
		Aadd(aMDJ,{"MDJ_SITUA" 		,Iif(lLjNCCOr,"OR","NP")})

		Frt060GrvNcc( aMDJ , aNCCItens , 1)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Apos confirmar a gravacao do Orcamento pergunta               ³
	//³Se o usuario deseja cancelar o cupom                          ³
 	//³ Faz o cancelamento do Cupom quando for concomitante qdo sair ³
	//³ da venda. Nao faz essa verIficacao qdo eh visualizacao       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lGrava .AND. nTipo == 1 .AND. lVAssConc .AND. !lEmitNFCe .And. !lIsPafNfce
       //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	   //³ VerIfica se ha um cupom em aberto. Caso afirmativo, faz o    ³
	   //³ cancelamento antes da abertura de outro                      ³
	   //³ .T. pergunta antes de cancelar o cupom                       ³
	   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   nRet := IfStatus( nHdlECF, '5', @cRetorno )
       If nRet == 7
          cMsg := STR0079 // "Existe um Cupom Fiscal em aberto, deseja efetuar o cancelamento e abandonar a venda ?"
          lRet := MsgYesNo( cMsg, STR0007 )	 //###'Atenção'
       	  If lRet
	       	 //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			 //³Validação de superior³
			 //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	       	 If LjProfile(8)
	       	 	nRet := IfCancCup( nHdlECF )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³dá um tempo para a impressora fazer a impressao do cancelamento³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		        Inkey(8)
		        lGrava := .T.
		     Else
		        lGrava := .F.
		     EndIf
		  Else
  			 lGrava := .F.
          EndIf
       EndIf
	EndIf

	If CrdxInt() .AND. nTipo == 1 .AND. lGrava
	   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	   //³Cancela o contrato caso nao seja associado ao orcamento           ³
	   //³Se tiver alguma parcela financiada, nao verIfica se deve cancelar ³
	   //³o contrato, caso contrario, verIfica para nao deixar contrato pen-³
	   //³dente															    ³
	   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   If Len(aContraTmp) > 0

 	      Conout("15.LOJA701C - Lj7PrepOrc - "  +;
	      		   " Orcamento: " + M->LQ_NUM  +;
	               " Contrato : " + If( Empty(cContrato), " ", cContrato) +;
	      		   " If Len(aContraTmp) executa CrdAtuPend : " )

	      CrdAtuPend( "SL1"   ,10    ,aContraTmp   ,lTemParcFI   ,;
	                  .F.     )
	   Else
	   		Conout("16.LOJA701C - Lj7PrepOrc - "  +;
	      		   " Orcamento: " + M->LQ_NUM  +;
	               " Contrato : " + If( Empty(cContrato), " ", cContrato) +;
	      		   " If Len(aContraTmp) <= 0 " )
	   EndIf
	   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	   //³ Se for gravacao de orcamento, inicializa aCrdCliente e cContrato	³
	   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   Lj7SetCRDClie(.T.)

       Conout("17.LOJA701C - Lj7PrepOrc - "  +;
	   		   " Orcamento: " + M->LQ_NUM  +;
	           " Contrato : " + If( Empty(cContrato), " ", cContrato) +;
	     	   " Executa Lj7SetCRDClie " )
    Else
    	Conout("18.LOJA701C - Lj7PrepOrc - Orcamento: " +  M->LQ_NUM + "  Sem Integracao com o CRD")
	EndIf

	/*BEGINDOC
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ`¿
	//³MAN0000604-01 - Integração Protheus x Financial Service classe da analise de credito³
	//³Verifica se o orçamento deverá ser enviada a análise de crédito                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ`Ù
	ENDDOC*/

	If lUsaIntFS .and. lGrava .and. lTemParcFI  .AND. !lMVLJPDVPA .AND. !lFSCliPad
		oLjIntFSAn := LjClInFSAn():New(SL1->L1_FILIAL, SL1->L1_NUM)
  		If !(nTipo == 2 .AND.  !Empty(SL1->L1_USRST))
  			oLjIntFSAn:EnviarAnal("E")
  			Conout("17.LOJA701C - Lj7PrepOrc - "  +;
	   		   " Orcamento: " + M->LQ_NUM  +;
	   		   " Executa  LjClInFSAn:EnviarAnal() - Analise de credito" )

			oLjIntFSAn:ExibirResp(!lAutoExC)
		EndIf
		If nTipo == 2   //Se for finalização da venda, não permite o prosseguinto da gravacao
			lGrava := oLjIntFSAn:LiberarOrc()
	   	EndIf

	   	If oLjIntFSAn <> Nil
	   		FreeObj(oLjIntFSAn)
	   		oLjIntFSAn := nil
	   	EndIf

	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Chama a funcao fiscal de finalização de Calculo              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !(MaFisFound("NF"))
		MaFisEnd()
	EndIf
Else
	lGrava := .T.
EndIf

If !lMVLJPDVPA .AND. (nTipo == 1) .AND. lGrava // Só grava o motivo na geração do orçamento se não for PDV e se orçamento (nTipo = 1 - Orçamento)
	Lj7GrvMotDesc("", "", cNumOrc , "O") // (cSerie, cDoc , cNumOrc, cTipo ) - Grava o motivo de desconto qdo geração de orçamento
EndIf

LjGrvLog(cNumOrc,"GRAVADO O ORCAMENTO",lGrava)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada que possibilita efetuar gravacoes de campos no momento ³
//³ de finalizacao do orcamento ou quando ocorre algum erro de comunicacao  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lLj7052 .AND. !lFtvdVer12
	U_LJ7052( nOpc , nTipo , lGrava)
EndIf

If lFTVD7052 .AND. lFtvdVer12
	U_FTVD7052( nOpc , nTipo , lGrava)
EndIf

If !Empty(LOG_TEF)
	LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Finalização Geração Orçamento - ' + If( lGrava, 'S', 'N' ))
EndIf

If nTipo == 2 .AND. lGrava .AND. (lEmitNFCe .Or. lIsPafNfce) .AND. !IsBlind() .AND. !lRecebe 
	RecLock("SL1", .F.)
	Replace SL1->L1_SITUA with "T1" //T1 - Orcamento Gravado
	SL1->( MsUnLock() )
EndIf

RestArea( aArea )
Return lGrava

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³Lj7GrvVendaºAutor ³Vendas Clientes     º Data ³  20/08/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Faz a efetivacao da venda e a impressao do cupom fiscal     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ExpL1 := Lj7GrvVenda( ExpL2, ExpL3, ExpA4, ExpN5, ExpL6,;   º±±
±±º			 ³                      ExpN7, ExpN8)       				  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpL2 - lFinanceiro - Indica se eh para gerar a movimentacaoº±±
±±º          ³        financeira ao gravar a venda                        º±±
±±º          ³ExpL3 - lRecTrib - Chama a funcao de recalculo das tributa- º±±
±±º          ³        coes.                                               º±±
±±º          ³ExpA4 - Array com os dados do consumidor Final(Loc. Arg)    º±±
±±º          ³ExpN5 - Handle do arquivo de log							  º±±
±±º          ³ExpL6 - .T. Emite NF/.F. Emite Cupom                        º±±
±±º          ³ExpN7 - Opcao do aRotina 									  º±±
±±º          ³ExpN8 - Tipo da operacao: 1-orcamento;2-venda				  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ExpL1 - Indica se conseguiu ou nao fazer a gravacao         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Loja701                                                     º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Lj7GrvVenda(	lFinanceiro , lRecTrib  , aDadosCF	, nHandle		,;
						lEmiteNF    , nOpc      , nTipo		, lTemTefPend	,;
						aTefBKP		, nDescOrc  , cLQFrete	, lJob			,;
						nVlrAcrsFi 	, cCgcCli   , cNomeCli	, lNfManual		,;
						lImpReserva	, nFatorRes , nFatorVen	, lTefPed		,;
						cEspFo		, cDocFo	, cTpGeraGdp, nDescontFi	,;
						lDscCupTef	, nTotICM	, aDadosCNeg, nArredondar	,;
						lErroNFCe	, lTefAbort , cTipoCli 	, nSaveSx8 		,;
						nValRes		, lErroNFe	, cMsgErro  , lCartao )

Local aArea			:= Lj7GetArea( {"SL1","SL2","SL4"} )		// Salva area do SL1, SL2 e SL4
Local aRet          := {.T.,'',''}				// Array com retorno do TEF, Cupom e numero do orcamento
Local lRet 			:= .F.						// Retorno da funcao
Local lConfCRD      := .F.						// Controla se houve confirmacao da transacao do SIGACRD
Local cDoc			:= ""						// Numero do cupom
Local cPdv 			:= ""						// Numero do PDV
Local cSerie 		:= ""						// Serie do documento
Local cMV_CLIPAD	:= PadR(SuperGetMV("MV_CLIPAD"),TAMSX3("LQ_CLIENTE")[1])		// Cliente padrao
Local cMV_LOJAPAD	:= PadR(SuperGetMV("MV_LOJAPAD"),TAMSX3("LQ_LOJA")[1])			// Loja do cliente padrao
Local aSL1			:= {}						// Array com os dados do SL1 a serem gravados no arquivo
Local aSL2			:= {}						// Array com os dados do SL2 a serem gravados no arquivo
Local aSL4			:= {}						// Array com os dados do SL4 a serem gravados no arquivo
Local aSLS          := {}						// Array com os dados do SLS a serem gravados no arquivo (Loc. Argentina)
Local aMAD          := {}						// Array com os dados do MAD a serem gravados no arquivo (endereco)
Local aReservas	 	:= {}						// Array com os dado da reserva
Local aNumLay       := {}						// Numero do Lay-Away para baixa (Loc. Porto Rico)
Local aRetCrd       := {}						// Array de retorno com informacoes de credito do cliente(SIGACRD)
Local aDadosTefNF	:= {}						// Array com informacoes do TEF enviados para impressao de NF
Local i, nI, nX 	:= 0						// Controle de loop
Local nCont 		:= 0						// Contador
Local nVlrTroco 	:= 0						// Valor do troco
Local nVlrAux 		:= 0						// Valor auxiliar, utilizado para as NCCs
Local nPosLay       := 0						// Posicao do numero do Lay-Away
Local nPosItLay     := 0						// Posicao do item do Lay-Away
Local nRecnoSL2     := 1						// Recno do SL2
Local nOutros       := 0						// Conteudo do L1_OUTROS
Local nPosVlItem    := 0						// Posicao do Valor Total do Item
Local nPosProd		:= 0						// Posicao da codigo do produto
Local nPosQtd		:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_QUANT"})][2]	// Posicao da Quantidade
Local nPosStTrib	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_SITTRIB"})		   	// Posicao do codigo do Vale Presente
Local nTotalItem    := 0						// Totalizador do item
Local nTotalLay     := 0						// Retorno da funcao a800Total()
Local nVlrTrcAux    := 0						// Troco convertido para a moeda da parcela
Local lTefOk	    := .F.						// Valida se o TEF foi OK
Local lTEFFat       := .F.						// Uso do TEF dentro do modulo Faturamento
Local lCompensa     := .F.						// Compensacao do Lay-Away(Loc. POR|EUA)
Local lLayTotal     := .T.						// Valida se o nTotalItem eh igual nTotalLay ou se MV_LWPARC esta Falso
Local lImpNF		:= .T.						// Indica se a NF foi impressa corretamente
Local cTotRecNFis   := ""
Local cNumCupom     := Space(TamSx3("L1_DOC")[1])	// Numero do cupom fiscal
Local cNumPdv 		:= Space(TamSx3("L1_PDV")[1])	// Numero do PDV
Local lErroCF		:= .F.						// Valida se houve erro na impressao do cupom fiscal / envio da NFC-e
Local lLj7019       := ExistBlock("LJ7019")		// VerIfica se existe o PE LJ7019
Local xRet										// Retorno do Execblock LJ7019
Local lErrCupTEF	:= .F.						// Valida se houve erro no cupom TEF
Local lGaveta       := ( ! Empty(LJGetStation("GAVETA")) )	// Valida se a estacao utiliza gaveta
Local nRestDiv      := 0						// Calcula dIferenca do resto da divisao
Local lAbtoAll      := .F.						// Valida se houve abatimento de PIS / COFINS
Local cMvSimb1		:= SuperGetMv("MV_SIMB1")	// Simbolo da moeda principal
Local cAdminis		:= Space(TamSX3("L4_ADMINIS")[1])// Variavel com a administradora financeira
Local cStatus       := ""						// Status do contrato
Local lLog1       	:= SubStr(LJGetProfile("LOGERRO"),1,1) == "S" // Tem Log de Erro
Local lLog4         := SubStr(LJGetProfile("LOGERRO"),4,1) == "S" // Log de Recuperacao, grava as parcelas
Local lForcada		:= .F.						// Indica se a venda foi off-line ou on-line quando integra com SIGACRD
Local lHabTroco     := SL1->( ColumnPos( "L1_TROCO1" ) ) > 0 .AND. SuperGetMV( "MV_LJTROCO", ,.F. )   //Determina que o controle de troco esta habilitado
Local nSize         := 0						// Tamanho do arquivo de LOG de recuperacao
Local cRBuffer      := ""						// Buffer com conteudo da linha do log txt
Local nPos			:= 0						// Posicao do campo no array
Local nVlrEntrada	:= 0						// Valor de entrada
Local nVlrParc      := 0						// Valor da parcela calculado quando troco desabilitado
Local cMV_CRDAVAL   := SuperGetMV("MV_CRDAVAL",,"13|22|43")		// Parametro que define os modulos e processos que tem analise de credito
Local aImpCheque    := {}						// Controla se os cheques da venda foram impressos
Local lGrvPon		:= .F.						// Valida se grava pontos
Local cMsgResg   	:= ""						// Imprime no Rodape do cupom os vales resgatados
Local aProdCri		:= {}						// Array com os produtos para analise de criterio de pontos
Local cGrupoProd	:= ""						// Variavel com o grupo do produto
Local lUsafd      	:= SuperGetMV("MV_LJUSAFD",,.F.)	// Parametro que define se o cliente utiliza Vale Compra
Local nDIf			:= 0						// DIferenca de espacos para gravacao do tudook#
Local aVlrAcres		:= {}						// Array para incremento do acrescimo por item
Local nTamE1_NUM	:= TamSX3("E1_NUM")[1]		// Tamanho do campo E1_NUM - performance
Local lVAssConc	    := LjVassConc()				//Indica se o cliente utiliza a Venda Assistida Concomitante
Local lLj7040       := ExistBlock("LJ7040")		// VerIfica se existe o PE LJ7040
Local cMvCrdForm	:= SuperGetMV("MV_CRDFORM",,"VA") 		// Forma de pagamento nao considerada na pontuacao do CRD
Local nTamF2Esp     := TamSX3("F2_ESPECIE")[1]              // Tamanho no SX3 da especie do documento
Local lLojR860A		:= ExistBlock("LOJR860A") .And. SuperGetMv("MV_LJLOCNC",.F.,.F.)	// Verifica a utilização do ponto de entrada para a impressão da NCC // Roberto
Local cMvLjTGar		:= SuperGetMV("MV_LJTPGAR",,"GE")		//  Define se é tipo GE
Local aProdGar		:= {}                  		// Variável para identificação do produto Garantia
Local lAvalPremio   := .F.									// VerIfica se deve fazer analise de pontuacao do cliente
Local nTotPontos    := 0  									// Total de pontos
Local cPgVc 		:= ""									// Informa que houve pagamento com vale-compra
Local nPag			:= 0									// Total de pagamento dIferente de vale-compra
Local aRecnoSE1     := {}                                  // Array com os recnos do SE1 para compensacao do Lay-Away
Local cRetorno		:= ""									// Retorno da Impressora
Local lAterSl2		:= .F.									// Se altera SL2
Local lSemRede		:= .F.									// Variavel que retorna se a rede selecioda no TEF existe na base
Local lMVTELAFIN	:= SuperGetMv("MV_TELAFIN",,.T.)		// Define se mostra a tela de administradora
Local lVendaCup		:= .T.									// Se a venda eh proveniente de Cupom ou Nota Fiscal
Local nFrete		:= MaFisRet(, "NF_FRETE") 				//Valor do frete na venda
Local nSeguro		:= MaFisRet(, "NF_SEGURO")				//Valor do Seguro na venda
Local nDespesa		:= MaFisRet(, "NF_DESPESA")				//valor das despesas na venda
Local nNumItens		:= 0 									//Total de itens da venda
Local cSeqTrans		:= ""									//Tratamento da sequencia do TEF
Local nFreDesSeg	:= 0				                    // Soma Frete despesas e seguro
Local cMvTmkLoj     := SuperGetMV("MV_TMKLOJ",, "N") 		// verIfica se ha integracao com o Callcenter
Local nSomaPgtos	:= 0									// Soma as paracelas do aPgtos
Local nY			:= 1									// Contador de for...
Local aAreaJob  	:= {}
Local aAcrFin		:= {}									// Array para armazenar o acrescimo financeiro proporcional por item
Local aUsado		:= {}
Local cContDoc      := ""              					    // Contador de Cupom Fiscal
Local lProcBaixa 	:= .T.									// Verifica se procura baixa
Local cValidRec		:= "1"
Local lPergGrCFD	:= (SuperGetMv("MV_CFDUSO" , ,"0") == "1")			// Indica se deve perguntar pela geracao do CFD.
Local lGrvPCFD		:= .T.									// indica se Grava CFD quando
Local aMsgCert		:= {}
Local oDlg
Local oMemo
Local oFont
Local lLOGTEF       := SLG->(ColumnPos("LG_LOGTEF"))>0				// Verifica se existe o campo LG_LOGTEF
Local lAchouSLG     := .F.
Local cPath         := ""
Local lUsafdOff		:= SuperGetMV("MV_FRTCRD",,.F.) 				// verifica se usa crd(fidelizacao) por Ws
Local cMsg          := ""
Local nMvLjTpDes	:= SuperGetMv( "MV_LJTPDES", , 0 )													// Indica qual desconto sera' utilizado 0 - Antigo / 1 - Novo (objeto)
Local aLockSA1		:= {}
Local aAreaSA1		:= {}
Local oLJCLocker := If( ExistFunc("LOJA0051") .And. SuperGetMV( "MV_LJILVLO",,"2" ) == "1", LJCGlobalLocker():New(), )
Local cNumCart		:= "" 									//Armazena numero do cartao conforme padrao de seguranca PCI(6 primeiros + 4 ultimos numeros do cartao)
Local aVales		:= {}						// Vale Compra
Local lExistNF		:= .F.									//Verifica a existencia de nota fiscal duplicada
Local cDescErro		:= ""									//Descricao do erro ocorrido
Local lSped         := .F.                                 	// Verifica se a especie eh SPED
Local cEspecie      := Space(nTamF2Esp)       				// Especie do documento
Local cEspecNf      := Space(nTamF2Esp)       				// Especie do documento
Local dData			:= dDatabase							// Data para atualiza L4_data com dias de vencimento do sar
Local oWSV													// Objeto webservice de atualizacao do status do Vale Compra
Local lVendaPerdida	:= SuperGetMV ("MV_LJMVPE",,.F.)		// Habilita gravacao de movimento de venda perdida
Local aDescNCC		:= {}                                   // Itens da NCC
Local cL1Doc        := ""                                   // Numero do Doc da NCC
Local cL1Serie      := ""                                   // Numero da Serie
Local lTemImpressao := .T.									//Quando PAF-ECF, verifica se possui item sem reserva.
Local aAreaSL2		:= {}									//Salva area SL2
Local aSitTrib		:= {}									// Array com a situacao trib dos itens
Local aNewNCC		:= {}									// Array referente a NCC que será gerada. Roberto
Local lVerEmpres    := Lj950Acres(SM0->M0_CGC)				// Verifica as filiais da trabalharam com acrescimento separado
Local lAutoExC 		:= IsBlind()	   						// Verifica se a rotina sera executada via execauto ou nao
Local lUsaFecha		:= SuperGetMV("MV_LJCONFF",.T.,.F.) .AND. IIf(ExistFunc("LjUpd70Ok"),LjUpd70Ok(),.F.)	//Utilizar conf. de fechamento
Local cTransNat		:= SuperGetMV("MV_LJTRNAT",.F.,"")															//Natureza financeira da transferencia
Local lUsaTransf	:= SuperGetMV("MV_LJTRANS",.T.,.F.) .AND. !Empty(cTransNat) 								//Verifica se a transferencia de caixa esta ativa
Local cMV_LJIMPFA	:= AllTrim(SuperGetMV("MV_LJIMPFA",.F.,"1"))		// Conteudo do parâmetro MV_LJ : 1 - Pergunta se Imprime/2 - Imprime direto/3-Não imprime e não pergunta

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Release 11.5 - Cartao Fidelidade³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lLjcFid 		:= SuperGetMv("MV_LJCFID",,.F.) .AND. CrdxInt() 	   			//Indica se a recarga de cartao fidelidade esta ativa
Local cNumFid		:= ""									//Numero do cartao fidelidade
Local cLojaFid		:= ""									//Loja da recarga/venda (cartão fidelidade)
Local dDataFid		:= ""									//Data de validade da recarga do cartao fidelidade
Local nValFid		:= 0									//Valor de venda com cartao fidelidade
Local nValRecFid	:= 0									//Valor de recarga cartao fidelidade
Local lProcFidWs	:= .F.									//Indica se a recarga/venda (cartao fidelidade) sera processada via WebService
Local lRecFid		:= .F.									//Indica se o movimento de cartao fidelidade sera do tipo recarga
Local lLjDespa		:= SuperGetMv("MV_LJDESPA",NIL,.F.)	 	//Habilita desconto por Adm e banco

Local aTaxJuros		:= {0,0,0,0}							//Recebe a porcentagem de juros da administradora
Local nValJuros		:= 0									//Recebe o valor de juros da administradora
Local lMvLjJurCC	:= SuperGetMv("MV_LJJURCC",NIL,.F.)		//Habilita o juros por administradora de cartao

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Release 11.5 - Controle de Formularios       ³
//³Paises: Chile/Colombia  - F1CHI              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local aBreakNota	:= {}									//Notas geradas a partir da venda quando o numero de itens de venda exceder o limite - Release 11.5 - Chile
Local lNumcFis		:= .T. 									//Indica se grava o numero do documento no campo L1_NUMCFIS
Local lCFolChiR5	:= SuperGetMv("MV_CTRLFOL",.F.,.F.) .AND. cPaisLoc$"CHI" .AND. !lFiscal       //Localizao CHILE, Release 11.5, Controle de Formularios Ativo,Usuario nao fiscal
Local lFTVD7019     := ExistBlock("FTVD7019")				// VerIfica se existe o PE FTVD7019
Local lFTVD7040     := ExistBlock("FTVD7040")				// VerIfica se existe o PE FTVD7040
Local cNfRPS		:= "" 									// Numero da NF de Servico "RPS"
Local cSerRPS		:= "" 									// Serie da NF de Servico "RPS"
Local lMVLJPRDSV   	:= SuperGetMv("MV_LJPRDSV",.F.,.F.) 	// Verifica se esta ativa a implementacao de venda com itens de "produto" e itens de "servico" em Notas Separadas
Local nVlrServic	:= 0 									// Valor dos itens de "Servico"
Local nFatorServ 	:= 0 									// Fator (Itens de Servico)
Local nPosData   	:= 0									// Variavel que contem a posicao no Array oTef:aRetCartao:aDatas
Local dDataTrans	:= CtoD(Space(08))                     	// Conteudo do Array oTef:aRetCartao:aDatas
Local nPosTrans		:= 0                                 	// Variavel que contem a posicao no Array oTef:aRetCartao:aValores
Local nValorTrans 	:= 0									// Conteudo do Array oTef:aRetCartao:aValores
Local nPosRetCart   := 0                                    // Varial que contem posicao no Array oTef:aRetCartao
Local lTefMult		:= SuperGetMV("MV_TEFMULT", ,.F.)		// Identifica se o cliente utiliza múltiplas transacoes TEF
Local lLoop			:= .T.  								// Variavel utilizada para fazer controle de loop
Local lOnlyServ 	:= .F. 									// Variavel utilizada para indicar qdo. a venda possui apenas itens de servico
Local lUsaRegL2	  	:= .T.									// Se irá considerar registro do L2, quando PAF-ECF, necessário considerar registros excluídos
Local lNfPafEcf	  	:= LjNfPafEcf(SM0->M0_CGC)				// Se habilitado modo PAF-ECF
Local cVendido		:= "S"									// Sinaliza item vendido
Local lGE 			:= ExistFunc("LjUP104OK") .AND. LjUP104OK()	// Validação do Conceito Garantia Estendida
LocAL cCodProGar	:= ""									// Codigo do produto Garantia Estendida
Local nVlrGar  		:= 0   									// Valor da Garantia Estendida
Local nFatorGar 	:= 0  									// Fator da Garantia Estendida
Local nRetNfce		:= -1	//Sinaliza se transmitiu a NFCe
Local cKeyNfce		:= ""	//Chave da NFCe
Local aNotas 		:= {}	//array de notas
Local nTotImpNCM	:= 0
Local nTotImpFED	:= 0
Local nTotImpEST	:= 0
Local nTotImpMUN	:= 0
Local nTotVLRNCM 	:= 0
Local lFunTesISS  	:= ExistFunc("LjIsTesISS")
Local lMVLJGRVON    := SuperGetMV("MV_LJGRVON",,.T.)									//Parâmetro que identifica se será utilizado o LJGRVBATCH ou trabalhara de forma síncrona
Local nMVLJTRDIN 	:= SuperGetMv( "MV_LJTRDIN",,0 )									//Define se grava o valor liquido do troco em dinheiro, onde 0-Gera Valor Bruto; 1-Gera Valor Líquido
Local lMVLJGRVJB	:= SuperGetMV("MV_LJGRVJB",,.F.)
Local lIsVendaVP 	:= If(ExistFunc("Lj7VPNew") .And. Lj7VPNew(),Lj7VPYesNo()=="S",.F.)	// Indica se eh venda de Vale Presente
Local lIsRecarCP 	:= If(ExistFunc("Lj7CP_OK") .And. Lj7CP_OK(),Lj7CPGetSt()=="S",.F.)	// Indica se eh venda de Recarga de Cartao Presente (Gift Card)

// Indica se há possibilidade de geração do vencimento somente em dias úteis
Local lVcDUtil 		:= ExistFunc('Lj7VcDUtil') .And. SAE->( ColumnPos( "AE_DIAUTIL" ) ) > 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Relatorio Gerencial    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lRelatGere 	:= SuperGetMV("MV_LJGERRG", ,.F.)  // Gera Relatorio Gerencial
Local cTiposProd	:= SuperGetMV("MV_LJTPRG",.F.,"")  // Tipos de Produto do Relatorio Gerencial
Local cOs			:= ""   							// Armazena a OS
Local nCount		:= 0    							// Contador
Local aRelatGere	:= {}   							// Array dos itens do Relatorio Gerencial
Local nPosConju 	:= aScan(aHeader,{|x| Alltrim( Upper( x[2] ) ) == "LR_CONJUNT" }) // Posicao do campo Conjunto
Local nPosVenAvu 	:= aScan(aHeader,{|x| Alltrim( Upper( x[2] ) ) == "LR_VENDAVU" }) // Posicao do campo  Venda Avulsa
Local lMvLjImpGf	:= SuperGetMV("MV_LJIMPGF",,.T.)	//Define se imprime a GE como Comprovante Nao-Fiscal
Local nTamCodAdm	:= TamSx3("AE_COD")[1]				// Tamanho do campo SAE->AE_COD

Local nValorGer		:= 0   								//valor da NCC que sera gerada (NFC-e)
Local cDocCred		:= ""								//PREFIXO+NUM+PARCELA+TIPO+LOJA do titulo CR que sera usado para compensacao (NFC-e)
Local nRecnoSE1		:= 0								//R_E_C_N_O_ do titulo do tipo CR que foi gerado (NFC-e)
Local nMsDecimal	:= MsDecimais(1)					// Retorna decimais da moeda configurada MV_RMDLOC
Local cFormaCart	:= ""								// Forma selecionda do cartao CC/CD
Local nPosTefDados	:= 0								// Posicao no array aTefDados
Local aArrayTEFPos	:= {}								// Guarda o cartao ID+Forma para não chamar a funcao LJ7ConfAdm mais que uma vez quando parcelado
Local lTefManual	:= SuperGetMV("MV_TEFMANU",,.T.)  	// determina se continua manualmente apos cancelar uma operação TEF
Local lSelTefManu	:= .F.								//Valida se foi selecionado o TEF Manual
Local nAux			:= 0								//Variavel auxiliar
Local aNfceSL1		:= {}								// Guarda as informações a serem alteradas para transmissão da NFC-e
Local nMoedaParc    := 1								// Moeda corrente
Local aPgtosBKP 	:= {}
Local aPgSintBKP 	:= {}
Local nTotParBkp 	:= 0
Local nSubTotBkp 	:= 0
Local nTotalBkp  	:= 0
Local lTemCartao	:= .F.
Local nDIfVlrAux	:= 0
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local lIntegDef	:= If(Type("lAutoExec") == "L", lAutoExec, .F.) .And. FWHasEAI("LOJA701",, .T., .T.) .AND. IIF( ExistFunc("Lj701GtInD") , Lj701GtInD(), IsInCallStack("LOJI701"))  //Integracao via Mensagem Unica
Local lEmitNFCe	:= (!lFtvdVer12 .Or. lIntegDef) .AND. ExistFunc("LjEmitNFCe") .AND.  LjEmitNFCe() // Sinaliza se utiliza NFC-e 
Local aArea2		:= {}
Local aAreaSM0		:= {}
Local aTimeUf		:= {}
Local lHVerao		:= SuperGetMv("MV_HVERAO",.F.,.F.) // Verifica se o local fisico do servidor está em Horário de Verão  .F. Não / .T. Sim
Local cHoraRMT		:= ""
Local cNSUVndTef	:= ""								//Contem o número da NSU caso venda com TefManual
Local aNSUVndTef	:= {}								//Informacoes do TEfManual - { Forma (caracter) , ID (caracter), Valor (numerico) , NSU digitada (caracter) }
Local lUseSAT 		:= .F.		//Utiliza SAT
Local cPass 		:= ""		//Chave de ativação SAT
Local aRetSAT		:= ""		//Retorno SAT
Local cXML			:= ""		//xml venda SAT
Local aSatSL1		:= {}		//chave de venda SAT
Local cDocSat 		:= ""		//numero de documento da venda SAT
Local cSerieSat		:= ""		//numero de serie do equipamento SAT
Local lGeraLog		:= .F.
Local nPosTefSint 	:= 0
Local cNumNotaCF	:= ""
Local lAjstaPgto	:= .F. //Responsavel pela verificação de atualização do array aPgtos no tocante a Administradora Finac.
Local lSelAdm       := SuperGetMv("MV_LJADMFI",,.F.) // Parametro que desabilita a escolha das administradoras de cartoes
Local aNFCeICMST	:= {}				//utilizado na NFC-e (contem o valores de ICMS-ST), logo sera substituido por um objeto
Local cCodRede 		:= ""
Local cDescRede		:= ""
Local lAtribRede 	:= LJRDLJXTEF() //Verifica a data do fonte LOJXTEF para saber se o atributo cCodRede existe no objeto oTef:aRetCartao
Local lAutomato	:= If(Type("lAutomatoX")<>"L",.F.,lAutomatoX)
Local lMultNegoc    := SuperGetMv("MV_LJMULTN",,.F.)
Local lValeTroca    := .F.
Local aSATDoc		:= {}
Local cL4NSUTEF		:= ""
Local cL1NSUTEF		:= ""
Local aRetPbm		:= {} //Retorno das informações retornadas do PBM Funcional Card
Local aPbmImp		:= {} //Informações da impressão do PBM
Local aOrcamentos	:= {}
Local aRetVldMFE	:= {} //Retorno do validador fiscal do MFE
Local nTotCart		:= 0  //soma dos totais informados paga pagamento em cartao
Local nTotPOS		:= 0  //soma total dos valores pago no POS
Local lCpoPCorte	:= SAE->(FieldPos("AE_PCORTE")) > 0
Local lMvNFCeCnj	:= SuperGetMV("MV_NFCECNJ",,.F.) //nfce conjugada
Local lShowMsgEr	:= .F. // Indica se a mensagem de erro ja foi apresentada

Default nValRes		:= 0
Default lFinanceiro	:= .T.
Default lRecTrib 	:= .T.
Default nHandle     := -1
Default lEmiteNF	:= .F.
Default nOpc        := 3
Default nTipo       := 2
Default cLQFrete	:= ""
Default lJob 		:= .F.
Default nVlrAcrsFi	:= 0
Default cNomeCli	:= ""
Default cCgcCli		:= ""
Default lNfManual	:= .F.
Default lImpReserva := .T.
Default nFatorRes	:= 1
Default nFatorVen	:= 1
Default lTefPed		:= .F.
Default nDescontFi 	:= 0
Default cEspFo		:= ""                   //Especie do documento escolhido pelo usuario no inici da venda - Release 11.5 - Chile
Default cDocFo		:= ""					//Numero de Nota definida pelo usuário no inicio da venda - Release 11.5 - Chile
Default cTpGeraGdp	:= GDP_NO
Default lDscCupTef	:= .F.
Default nTotICM		:= 0
Default aDadosCNeg	:= {}
Default nArredondar	:= 0					//Valor para o Instituto Arredondar
Default lErroNFCe	:= .F.					//Valida se houve erro na emissao da Nfce
Default lTefAbort	:= .F.					//se o Tef foi cancelado dentro da lj7Pedido. Verificação p/ não chamar TEF pela segunda vez .
Default cTipoCli 	:= ""
Default nSaveSx8 	:= GetSx8Len()			//Numeracao do SX8
Default lErroNFe	:= .F.					//Valida se houve erro na emissao da NF-e
Default cMsgErro	:= ""					//Descrição do erro
Default lCartao     := .F.                  // Uso do TEF

LjGrvLog(SL1->L1_NUM,"Processo de gravacao da venda, opcao",nOpc)
LjGrvLog(SL1->L1_NUM,"EMITE NOTA FISCAL",lEmiteNF)
LjGrvLog(SL1->L1_NUM,"Tipo da Operacao ",nTipo)

// Verifica se utiliza SAT
lUseSAT 	:= IIF(ExistFunc("LjUseSat"),LjUseSat(),.F.)

If SLG->(ColumnPos("LG_CODSAT"))>0
	cPass		:= IIF(LJGetStation("CODSAT",.F.) == Nil,"",LJGetStation("CODSAT",.F.))
EndIf

cHoraRMT := SuperGetMv("MV_HORARMT",.F.,"2")
If ValType(cHoraRMT) == "L"
	If cHoraRMT
		cHoraRMT := "1"
	Else
		cHoraRMT := "2"
	EndIf
Else
	If cHoraRMT == NIL
		cHoraRMT := "2"
	EndIf
EndIf

If !LjRecVlEmul(cValidRec) .AND. !lFtvdVer12
   Return .F.
ElseIf lFtvdVer12 .AND. !( LjRecVlEmul(cValidRec) .OR. LjValECFE() )
   Return .F.
EndIf

aRetAdmTef:= {} //Reinicializa o array

//Somente considera ativa a implementacao de venda com itens de "produto" e itens de "servico" em Notas Separadas, se a venda nao for com "Reserva" e nao for concomitante
lMVLJPRDSV := lMVLJPRDSV .And. Empty(SL1->L1_ORCRES) .And. Empty(SL1->L1_DOCPED) .And. !lVAssConc

If nNccUsada = 0 .OR. nNccUsada < Lj7T_Total(2)
	For nX := 1 To Len( aPgtos )
		If	cPaisLoc == "ARG" .AND. (aPgtos[nX][1] == CtoD(Space(8)) .OR. aPgtos[nX][2] == 0 .OR.;
		Empty(aPgtos[nX][3]))
			cMsg := STR0117		// "Para confirmar a gravação é necessário definir a forma de pagamento."
			aAreaSA1 := SA1->(GetArea())
			DbSelectArea("SA1")
			DbSetOrder(1)
			If DbSeek( xFilial("SA1") + M->LQ_CLIENTE + M->LQ_LOJA ) .AND. !Empty(SA1->A1_COND)
				cMsg += CTRL
				cMsg += STR0140	// "Observação: A condição de pagamento padrão do cliente é: "
				cMsg += SA1->A1_COND
			EndIf
			RestArea(aAreaSA1)
			If lAutoExC
				Conout(cMsg)
				Help( " ", 1, "Help",, cMsg, 1, 0 )
			Else
				MsgInfo(cMsg)
			Endif
			Return .F.
		EndIf
	Next nX
EndIf

If !lJob
	nVlrTroco 	:= Lj7T_Troco(2)			// Valor do troco
	cSeqTrans	:= M->LQ_NUM				//Tratamento da sequencia do TEF

	nPosVlItem  := aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_VLRITEM"})][2]	// Posicao do Valor Total do Item
	nPosProd	:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_PRODUTO"})][2]	// Posicao da codigo do produto
	nPosQtd	  	:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_QUANT"})][2]	// Posicao da Quantidade

	If !lAutoExec
	    If cProfStr2 == NIL
			cProfStr2 := GetPvProfString("Recebimento Titulos", "Totalizadores", "01", cGetCliDir+"SIGALOJA.INI")
		EndIf
		cTotRecNFis   := cProfStr2
	EndIf
Else
	If !lIntegDef //Integracao nao considera troco
		nVlrTroco 	:= SL1->L1_TROCO1			// Valor do troco		
	EndIf
	
	cSeqTrans	:= SL1->L1_NUM				//Tratamento da sequencia do TEF
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³No caso do recebimento de titulos de MG  eh      ³
//³necessario preencher o numero da transacao do TEF³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(cSeqTrans) .AND. lRecebe .AND. LJAnalisaLeg(37)[1]
	If Len(aTitulo) > 0
		cSeqTrans := aTitulo[1][3]
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona no registro do orcamento corrente.               ³
//³                                                           ³
//³este processo é utilizado devido a algumas vezes o registro³
//³nao estar posicionado.                                     ³
//³                                                           ³
//³este processo nao deve ser removido                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SL1->L1_TIPO <> "P" .AND. Empty(SL1->L1_ORCRES) .AND. ((SL1->L1_FILIAL + SL1->L1_NUM) <> (xFilial("SL1") + M->LQ_NUM)) //phsm
	SL1->(DbSetOrder(1))
	SL1->(DbSeek(xFilial("SL1")+M->LQ_NUM))
EndIf

If !Empty(LOG_TEF)
	LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Inicio Gravação da Venda')
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³VerIfica se foram informadas as formas de pagamento. Caso negativo nao    ³
//³permite finalizar a venda.                                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lAutoExec .AND. lFinanceiro .OR. lMVLJPDVPA

	If !Empty(LOG_TEF)
		LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Gravação da Venda - S')
	EndIf

	nVlrAux := nNCCUsada
	aEval( aPgtos, {|x| nVlrAux+=x[2] } )
	If nVlrAux == 0
		Aviso( STR0007, STR0010, {STR0005} ) //"Atenção"###"Não foram informadas as formas de pagamento. Impossível fechar a venda."###"OK"
		Return lRet
	EndIf

	If cPaisLoc <> "BRA"
		//Faz tratamento especifico caso esteja habilitada a implementacao de taxa administrativa de Cartao de credito
		If lMvLjJurCC
			aEval( aPgtosSint, {|x| If(x[1]$_FORMATEF, lTemCartao:=.T. , Nil) } ) //Verifia se tem cartao nas formas de pagamento escolhida
			If lTemCartao
				//Verifica se o valor total pago escolhido na tela (considerando todas a formas de pagamento) esta de acordo com o total da venda
				nDIfVlrAux := Lj7T_Total( 2 ) - Lj7T_TotPar( 2 )
				If nDIfVlrAux > 0
					//"O total de parcelas para pagamento é menor que o valor total da venda.","Total das Parcelas - Total da Venda: "
					MsgStop( 	STR0001 + Chr( 13 ) + ;
								STR0104 + " " + AllTrim( Transform( ( nDIfVlrAux ), PesqPict( "SL1", "L1_VLRTOT",, nMoedaCor ) ) ) )
					Return .F.
				EndIf
			EndIf
		EndIf

		//Faz backup dos arrays "aPgtos" e "aPgtosSint"
		aPgtosBKP 	:= aClone(aPgtos)
		aPgSintBKP 	:= aClone(aPgtosSint)
		//Faz backup dos totais da venda
		nTotParBkp := Lj7T_TotPar(2) //Faz backup do Total das parcelas da Venda
		nSubTotBkp := Lj7T_SubTotal(2) //Faz backup do SubTotal da Venda
		nTotalBkp  := Lj7T_Total(2) //Faz backup do Total da Venda
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se necessario abre a tela para para pedir os dados dos       ³
	//³ cheque / financiadora                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Lj7InfPgtos( nTipo	, @aVales	, NIL		, NIL,;
					 NIL	, @aTaxJuros, aTefBKP 	)

		If !Empty(LOG_TEF)
			LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Tela Digitação de Dados do Pagamento - N')
		EndIf

		Return .F.
	Else
		If cPaisLoc <> "BRA"
			/*------------------------------------------------------------------------------------------
			Abre a tela com a relacao dos valores de cartao atualizados a serem cobrados.
			Essa tela se fez necessario, devido a situacao onde existe um determinado imposto que somente eh calculado
			quando a venda atinge determinado valor, desta forma quando se utiliza o conceito de taxa de juros no cartao
			os valores a serem cobrados nos cartoes podem sofrer alteracoes quando esse determinado imposto fizer parte do calculo,
			ja que o valor a ser cobrado do cliente sera um valor maior. Entao os valores do cartao(s) a serem cobrados sofrerao
			alteracao e assim serao exibidos com os novos valores a ser cobrados.
			Valida se pode usa Taxa Administrativa por Cartão de Crédito
			------------------------------------------------------------------------------------------*/
			If lMvLjJurCC .AND. aTaxJuros[1] > 0 .And. MaFisFound("NF")
				If !LjTelaCard(@aTaxJuros, aPgtosBKP, aPgSintBKP, nTotParBkp, nSubTotBkp, nTotalBkp, aDadosCF, cTipoCli, nSaveSx8)
					Return .F.
				EndIf
			EndIf
		EndIf
	EndIf

	// Valida caso não for faturamento - venda direta
	cTipTef := LjGetStation("TIPTEF")
	If !lFtvdVer12
		If !LjNfUsaTef(SM0->M0_CGC)
			lCartao := LJXVERTEF(.F.)
		Else
	        lTefFAT	:= LJXVERTEF(.F.)
	   		lCartao := .F.
		EndIf

		If !Empty(LOG_TEF)
			LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Tem parcelas CC/CD/MH ? - ' + If( lCartao, 'S', 'N' ))
		EndIf
    ElseIf lFtvdVer12
	    lTefFAT	:= LJXVERTEF(.F.)
	   	lCartao := .F.

		If !Empty(LOG_TEF)
			LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Tem parcelas CC/CD/MH ? - ' + If( lCartao, 'S', 'N' ))
		EndIf
    EndIf

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³Analise de credito integrada com SIGACRD                           ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If CrdxInt()
       //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
       //³Se for a opcao Atendimento->Gravacao Venda, nao selecionou analise ³
       //³pelo botao da toolbar e o contrato estiver pendente para ser finali³
       //³zado ou liberado pelo Credito, preencher cContrato para a confirma-³
       //³cao da transacao. Nao necessita de nova avaliacao                  ³
       //³Se nao estiver configurado para avaliar credito no orcamento, deve ³
       //³avaliar neste momento 											 ³
       //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
       If !Empty(cContrato) .AND. nOpc == 3 .AND. "11" $ cMV_CRDAVAL


  		  Conout("19.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
	               " Contrato: " + If (Empty(cContrato), "", cContrato) +;
	      		   " nOpc==3 E 11 $ MV_CRDAVAL - Chama a funcao CrdStContr " )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Conteudo do MAH_STATUS  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
          cStatus    := CrdStContr(cContrato,M->LQ_CLIENTE,M->LQ_LOJA)

		  Conout("20.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
	               " Contrato: "+ If( Empty(cContrato), "", cContrato) +;
	               " Status : " + If( Empty(cStatus), "", cStatus) )

          If !(Val(cStatus) == ST_PEND .OR. Val(cStatus) == ST_LIB)
			 Conout("21.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
	               " Contrato: "+If (Empty(cContrato), "", cContrato) +;
	               " Status : " +If( Empty(cStatus), "", cStatus) +;
	      		   " Status=Pendente ou Liberado " )

             cStatus    := ""
             cContrato  := Space(TamSx3("MAH_CONTRA")[1])
          EndIf
       EndIf
       If Empty(cStatus)
          //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
          //³Se nao for a opcao Atendimento->Gravacao Venda ou selecionou a ana-³
          //³lise pelo botao da toolbar, deve re-avaliar o credito. Se ja tiver ³
          //³um contrato associado a um orcamento, utiliza este contrato  		³
          //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
          If !Empty(cContrato)

           	 Conout("22.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
	               " Contrato: " + If (Empty(cContrato), "", cContrato) +;
	      		   " Contrato !empty " )


             If Empty(aCrdCliente[1]+aCrdCliente[2]) .AND. M->LQ_CLIENTE+M->LQ_LOJA <> cMV_CLIPAD+cMV_LOJAPAD

                aCrdCliente   := AClone(CrdInfClie(M->LQ_CLIENTE, M->LQ_LOJA))
             Else

   				Conout("23.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
	               " Contrato: " + If (Empty(cContrato), "", cContrato)  +;
	      		   " aCrdCliente [1] e [2]: "  + ;
	      		   If( Empty(aCrdCliente[1]), "", aCrdCliente[1] )  +;
				   If( Empty(aCrdCliente[2]), "", aCrdCliente[2] ) )

             EndIf
          EndIf
		  Conout("24.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
	             " Contrato: " + If (Empty(cContrato), "", cContrato)  +;
                 " Validacao: Chamou Lj7AprovCrd CCONTRATO ")

          aRetCrd   := AClone(Lj7AprovCRD( "1"  ,@cContrato  ,Lj7T_Total(2)  ,NIL  ,;
                                            NIL  ,"13"        ,.F. ))
          If Len(aRetCrd) > 1
            If aRetCrd[5]
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Venda rejeitada        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            	Conout("25.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
	               " Contrato: " + If (Empty(cContrato), "", cContrato) +;
	      		   " Venda Rejeitada " )

	           Return (.F.)

	        ElseIf aRetCrd[1] == 2
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Aprovacao off-line    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	            lForcada  := .T.

			 	Conout("26.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
	               " Contrato: " + If (Empty(cContrato), "", cContrato) +;
	      		   " Venda Aprovada Off-Line " )
			Else
			    Conout("27.LOJA701C - Lj7GrvVenda - " +;
	      	 	   " Orcamento: " +  M->LQ_NUM +;
	      	       " Contrato : " + If( Empty(cContrato), "", cContrato ) )
	      	   	Conout(" aRetCrd[1] = " + If( Empty(aRetCrd[1]), "", Alltrim(STR(aRetCrd[1]))))
	      	 	Conout(" aRetCrd[2] = " + If( Empty(aRetCrd[2]), "", Alltrim(STR(aRetCrd[2]))))
	      	 	Conout(" aRetCrd[3] = " + If( Empty(aRetCrd[3]), "", Alltrim(STR(aRetCrd[3]))))
	      	 	Conout(" aRetCrd[4] = " + If( Empty(aRetCrd[4]), "", aRetCrd[4]) )
	      	 	Conout(" aRetCrd[5] = " + If( Empty(aRetCrd[5]), "", If(aRetCrd[5],".T.",".F.")))

			EndIf
			If !lRecebe
				Reclock("SL1",.F.)
				SL1->L1_CLIENTE	:= M->LQ_CLIENTE
				SL1->L1_LOJA	:= M->LQ_LOJA
				SL1->(MsUnlock())
			Endif
		  Else
		  	Conout("28.LOJA701C - Lj7GrvVenda - " +;
	      	 	   " Orcamento: " +  M->LQ_NUM +;
	      	       " Contrato : " + If( Empty(cContrato), "", cContrato ) +;
	      	       " Validacao: aRetCrd =0 " )
	      EndIf
	   Else
	   	  Conout("29.LOJA701C - Lj7GrvVenda - " +;
	       	   	" Orcamento: " +  M->LQ_NUM +;
	      	    " Contrato : " + If( Empty(cContrato), "", cContrato ) +;
	      	    " Status " + cStatus )
       EndIf
       lGrvPon := .T.

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³SELF-LIQUIDATE                                                ³
		//³-----------------------------                                 ³
		//³Faz a chamada da rotina para escolha dos premios que o cliente³
		//³tem direito. Inclui Brinde, Vale-Compra e Self-Liquidate      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   If lUsaFd   .AND. (M->LQ_CLIENTE+M->LQ_LOJA <> cMV_CLIPAD+cMV_LOJAPAD )

		  lAvalPremio := Len(aPremio) == 0

		  If lAvalPremio

			 //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			 //³Monta array com os produtos comprados para  calcular os³
			 //³pontos dessa Venda                                     ³
			 //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			 For nX := 1 to Len(aCols)
				If !aCols[nX][Len(aCols[nX])]
					cGrupoProd :=  Posicione("SB1",1,xFilial("SB1") + aCols[nX][nPosProd],"SB1->B1_GRUPO")
					AADD ( aProdCri, { aCols[nX][nPosProd], cGrupoProd , aCols[nX][nPosVlItem] , aCols[nX][nPosQtd]} )

				EndIf
			 Next nX

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Para pagamento com vale-compra deve ser calcula pontos    ³
			//³somente sobre a dIferença. se o pagamento for integral com³
			//³vale compra nao deve pontuar.                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			For nX := 1 to Len( aPgtos )
				If Alltrim( aPgtos[nX][3] ) $ cMvCrdForm
					cPgVc	:= "1"
				Else
					nPag	+= aPgtos[nX][2]
				EndIf
			Next nX


			 //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			 //³Faz a chamada da funcao para calcular os pontos referente a venda.³
			 //³A regra de pontuacao esta na tabela MAT.                          ³
			 //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lUsafdOff
				aPremio := AClone(Frt271ECrd(M->LQ_CLIENTE,M->LQ_LOJA, nTotPontos, @aLibera, Lj7T_Total(2)))
		    Else
		    	Crd240_002(	"1"		    ,M->LQ_CLIENTE	,M->LQ_LOJA		,aProdCri		,;
						 nPag			,NIL		    ,NIL            ,NIL            ,;
						 NIL            ,NIL            ,.F.            ,@nTotPontos	,;
						 cPgVc  )


				 //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				 //³Chama a rotina de resgate dos pontos. A regra que verIfica    ³
				 //³quantos vales o cliente tem direito esta na tabela MAU.       ³
				 //³                                                              ³
				 //³Esta funcao devera retornar:							      ³
				 //³ aDados:{nPontosUsados,  	  							      ³
				 //³			Tipo do Premio(1-Vale,2-Brinde,3-Self-Liquidate), ³
				 //³			Produto,		                                  ³
				 //³			Nro Vale Compra,                                  ³
				 //³			Valor,                               			  ³
				 //³         % Desconto)			                              ³
				 //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				 If !Empty(aCrdCliente[2])
					aPremio := AClone(Crd240Resgate( aCrdCliente[2], M->LQ_CLIENTE, M->LQ_LOJA, Nil, ;
													 nTotPontos, @aLibera, Lj7T_Total(2) ))
				 Else
					aPremio := AClone(Crd240Resgate( "", M->LQ_CLIENTE, M->LQ_LOJA, Nil, ;
												 nTotPontos, @aLibera, Lj7T_Total(2) ))
			     EndIf
			EndIf

			 nTotPremio := 0


			For nX := 1 to Len(aPremio)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Se for Self-Liquidate soma o valor³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If aPremio[nX][2] == "2" .OR. aPremio[nX][2]=="3"
					If(aPremio[nX][5]<> 0)
						nTotPremio += aPremio[nX][5]
					Else
						nTotPremio += 0.01
						aPremio[nX][5] = 0.01
					EndIf
				EndIf
			 Next nX

			 If nTotPremio > 0

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualiza o Subtotal da Venda³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Lj7T_Subtotal( 2, LJ7T_Subtotal(2) + nTotPremio)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualiza o total da venda³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Lj7T_Total(2, Lj7T_Total(2) + nTotPremio)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ-ÄÄÄÄÄÄÄÄ--ÄÄ¿
				//³Atualiza Forma de pagamento³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ-ÄÄÄÄÄÄÄÄÄ--Ù
				Lj7CondPg(	2	, M->LQ_CONDPG  , Nil, 	Nil, ;
							Nil	, Nil			, Nil, 	LJ7T_Subtotal(2), ;
							nOpc, .F.    , .T.,	.T. )


				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Retorna a tela de pagamentos para selecionar nova condicao de acordo com novo valor da venda ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Return (.F.)
				EndIf
		  	Else
		    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Gravacao dos itens do selfliquidate e Brinde no aSL2³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			 Lj7GrvPremio()
	      	EndIf
		EndIf
    Else
    	Conout("30.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM + "  Sem Integracao com o CRD")
	EndIf
ElseIf IsInCallStack("LJNFCELOT") //Necessario, pois quando ha finalização em lote de orcamentos com forma de pagamento com administradora financeira, a variavel administ deve ser inicializada

    Lj7InfPgtos( nTipo  , @aVales   , NIL       , NIL,;
                     NIL    , @aTaxJuros, aTefBKP   )   
EndIf

If !lAutoExec

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Abre a Gaveta de Dinheiro  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lGaveta
		AbreGaveta()
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicializa antes da Trn TEF   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lCCS     := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Apos ser realizado a impressao do cupom TEF, eh gerado um  |
	//³ arquivo para a sua reimpressao, exceto VISANET. Este       |
	//³ arquivo deve ser apagado sempre que iniciar uma nova venda |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	L010DelImp()
EndIf
If lLj7040 .AND. !lFtvdVer12
   ExecBlock("LJ7040",.F.,.F.)
EndIf

If lFTVD7040 .AND. lFtvdVer12
   ExecBlock("FTVD7040",.F.,.F.)
EndIf

//Exibição da tela para consulta dos produtos reservados pela Funcional Card
If ExistTemplate("DroVLVen") .And. ExistFunc("LJGDadosVL")
	aRetPbm := LJGDadosVL()
	If Len(aRetPbm) > 2 .And. Len(aRetPbm[2]) > 0 .And. ExistFunc("LJ7DadosVL")
		ExecTemplate("DroVLVen",.F.,.F.,{aRetPbm[3],aRetPbm[2],aRetPbm[1],SL1->L1_NUM})
		LJ7DadosVL() 
	EndIf	
EndIf	

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Faz a Transacao TEF                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lAutoExec 
	If lUsaTef .AND. (lCartao .OR. (LjNfUsaTef(SM0->M0_CGC) .AND. lTEFFat)) .AND. ;
		cTipTEF $ TEF_SEMCLIENT_DEDICADO+";"+TEF_COMCLIENT_DEDICADO+";"+TEF_DISCADO+";"+TEF_CLISITEF+";"+TEF_CENTROPAG

		If !Empty(LOG_TEF)
			LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Inicio Transação TEF - S / S / ' + cTipTEF)
		EndIf
	
	    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	    //³ Tratamento Parce                                             ³
	    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    cOrcamen := SL1->L1_NUM
		aReb     := {}
		aParcTef := {}
	
		//Monta os array's para validação do tef
		LjMnReb(@aReb, @aParcTef,nArredondar)
	
		LjGrvLog(SL1->L1_NUM,"Vai realizar a transacao TEF",aPgtos)
	
		If cTipTef == TEF_CLISITEF
			If !lTefPed .AND. !lTefAbort //lAbort controla se a operação tef foi abortada na funcao lj7Pedido, não chamado o TEF de novo

				If lMFE .And. lLjEnvPgto
					For nX := 1 To Len(aPgtos)
						If AllTrim(aPgtos[nX][3]) $ _FORMATEF
							LjMsgRun("Enviando pagamento para o VFP-e..." ,,{ || aAdd(aIdPgtoMfe,LjEnvPgto(aPgtos[nX][2],.T.)) })
						EndIf	
					Next nX	
				EndIf	

				oTEF:Operacoes("V", 		aReb, 	@lTemTefPend, 	@aTefBKP, ;
								cSeqTrans, 	NIL,	@aPgtos,		@aPgtosSint, ;
								@oPgtos, 	@oPgtosSint	)
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Guarda a transacao TEF, logo após sua finalização, caso ³
				//³haja algum problema será possível exttorná-la.          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				LJTEFConfRW(cGetCliDir + "CLISITEF."+StrZero(oTEF:nIDTermina,3), .T., oTEF:cCupom, oTEF:cData, oTEF:cHora)
				lTefOk := oTef:lTefOk

				//Tratamento para administradora financeira no caso de recebimento de títulos
				//pois sempre era atribuido o próprio cliente e também impactava quando estava habilitado
				//o paramentro MV_LJUSAFD (Vale Compra)
				If lRecebe .And. Len(aTitulo) > 0
					LJVERADM(@lSemRede, lTefOk)
				EndIf	
			Else
	   			lTefOk := lTefPed
			EndIf
		ElseIf cTipTef == TEF_CENTROPAG
			oTef:Operacoes(aReb)
			lTefOk := oTef:lTefOk
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se for TEF Discado e venda com reservas, o comprovante de venda ja foi impresso	|
			//| na funcao Lj7Pedido, portanto nao sera necessario imprimi-lo novamente.			³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If IsInCallStack("Lj7Pedido")
				lTefOk := .T.
			Else
				lTefOk := LOJA010T(	"V", Nil, aReb	, Nil		,;
									Nil, Nil, Nil	, Nil		,;
									Nil, Nil, Nil	, @lSemRede	)
			EndIf
		EndIf
	
		LjGrvLog(SL1->L1_NUM,"Retorno do TEF",lTefOk)
		If Type("oTef") <> "U" .And. !oTef:lTefOk
			LjGrvLog(SL1->L1_NUM,"Objeto oTef",oTef)
		EndIf
		
		//IMPORTANTE: NAO RETIRAR ESTE TECHO
		//Para vendas com SITEF e utilizando o MFE mas ainda não foi implementado o ajuste no SITEF
		// If lTefOk
		// 	If cTipTef == TEF_CLISITEF
		// 		LjEnvStPgto(oTef:aRetcartao)
		// 	EndIf
		// EndIf		
	
		If !lTefAbort .And. FindFunction("LjGuardaTef")
			LjGuardaTef(SL1->L1_NUM,aTefBKP)
		EndIf
	
		If !Empty(LOG_TEF)
			LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Venda TEF - ' + If( ValType(lTefOK) == "L", If( lTefOK, 'S', 'N' ), lTefOk ))
		EndIf
	
		If !Valtype(lTefOk ) == "L"
			lTefOk := .F.
		ElseIf !lTefOk
			If cTipTef <> TEF_CLISITEF
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³HOMOLOGACAO: Enviar o desfazimento da operação TEF para impedir transações pendentes no Sitef³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If TEF_lEnvDF()
					If !Empty(LOG_TEF)
						LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Envio Desfazimento TEF')
					EndIf
	
					If LOJA010T("F","D")
	
						If !Empty(LOG_TEF)
							LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Transação TEF não efetuada!')
						EndIf
	
						MsgAlert(STR0047) 	//"Transação TEF não efetuada!"
					EndIf
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Na versào 3.00 do TEF qdo quando ocorre erro nao e necessario cancelar enviei o desfazimento, respeito as versoes anteriores do Sitef³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf !(SuperGetMV("MV_TEFVERS") == "03.00") .OR. SuperGetMV("MV_TEFMULT",,.F.)
					If !Empty(LOG_TEF)
						LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Envio Cancelamento TEF - ' + SuperGetMV("MV_TEFVERS") + ' / ' + ;
						       If( GetNewPar("MV_TEFMULT", .F.), 'S', 'N' ))
					EndIf
					If LOJA010T("F","N")
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Antigamente esta função nao retornava verdadeiro ou falso ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !Empty(LOG_TEF)
							LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Transação TEF não efetuada!')
						EndIf
						If ExistFunc("L010IsAuttar") .AND. L010IsAuttar(L010GetGPAtivo())
							MsgAlert(STR0047 + CTRL + STR0213) 	//"Transação TEF não efetuada!"###"Todas as transações TEF anteriores foram desfeitas!"
						Else
							MsgAlert(STR0047) 	//"Transação TEF não efetuada!"
						EndIf
					EndIf
				EndIf
			EndIf
	
		EndIf
	
		If !lTefOk .AND. !IsBlind()
			If cTipTef == TEF_CLISITEF
		        lAchouSLG := LJVerifSLG()								// Verifica se existe registro na tabela SLG
				If lLOGTEF .AND. lAchouSLG
					If !Empty(SLG->LG_LOGTEF)
						RecLock("SLG",.F.)
						REPLACE SLG->LG_LOGTEF WITH ""
						MsUnLock()
					Endif
				Else
				    cPath  := GetClientDir()
				    If File(cPath + "CLISITEF." + StrZero(oTEF:nIDTermina, 3) )
						FErase( cPath + "CLISITEF." + StrZero(oTEF:nIDTermina, 3) )
					EndIf
				Endif
	        Endif
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ lTefManual -> Foi colocado um parametro para determinar se o cliente utiliza ou nao esta pergunta ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lTEFManual
				If cTipTEF == TEF_DISCADO
					lTEFOk := LJTntTefD(aReb, @lSemRede)
					aRet[1] := lTEFOk
				Else
					aRet[1]	:= .F.
				EndIf
			Else
				If !lTemTEFPend	//somente vem TRUE (nao entrara aqui) quando for SITEF ou CENTRO_PAG
					If lSemRede	//quando a instituicao nao existir no AE_DESC
						aRet[1] := .F.
					Else
						// (lTefAbort) ->  Se estiver hab. TEF manu. e houve cancelamento da operacao TEF na função lj7Pedido,
						//				nao pergunta novamente se continua manual, pois essa pergunta já foi feita na lj7Pedido.
	 					If !lTefAbort
							aRet[1] := LojaOk( STR0198 + Chr(10) + Chr(13) + STR0199,,.T.) 	// STR0198 - "Ocorreu um problema com o ultimo Cartao!!!"  //"Continuar manualmente e passar o Cartao via POS?"
							lTefManual := aRet[1]
							lSelTefManu:= aRet[1]
						Else
							lTefManual := .T.
						EndIf
	
						If lTEFManual
							If ExistBlock("LJ7074")
								aRet[1]	:= ExecBlock( "LJ7074", .F., .F., {} )
								lTEFManual := aRet[1]
							EndIf
	
							If lTEFManual .AND. cTipTef == TEF_CLISITEF
								oTEF:FinalTrn(0)
							EndIf
						ElseIf cTipTEF == TEF_DISCADO
							lTEFOk := LJTntTefD(aReb, @lSemRede)
							aRet[1] := lTEFOk
						EndIf
					EndIf
				Else
					aRet[1] 	:= .F.
					lTefManual 	:= aRet[1]
				EndIf
			EndIf
	
			If !aRet[1]
			   nValSubTot  := Lj7T_Subtotal(2)
			EndIf
	
			If !Empty(LOG_TEF)
				LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Continua Manualmente - ' + If( aRet[1], 'S', 'N' ))
			EndIf
		EndIf
	Else
		// Caso não esteja configurado o TEF, sempre irá exibir a tela para digitação do NSU nas vendas em CC e CD.
		lTefManual := .T.
		lSelTefManu:= .T.
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Executa o recalculo das tributacoes da venda nas seguintes situacoes:     ³
//³1. Caixa nao tem acesso para usar TEF									           ³
//³2. Sucesso na transacao TEF												           ³
//³3. Forma de pagamento dIferente de cartao de credito                      |
//³4. Pagamento em cartao e estacao nao utiliza TEF	- BOPS 147684			  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lUsaTef .OR. lTefOk .OR. !lCartao .OR. lTefManual .OR. ( lCartao .AND. cTipTef == TEF_NAO_USADO )
	If !lRecebe .AND. lRecTrib .AND. cPaisLoc == "BRA"
	    nFreDesSeg := Lj7CalcFrete()

		//Quando existir RESERVA com RETIRA manda o valor nValRes
		nValRes := IIf ( !lJob .AND. !lMVLjPdvPa .AND. nFatorRes < 1,( Lj7T_Total(2) - nFreDesSeg ) * nFatorRes, nValRes )

		//Ajusta o Valor de (Frete+Seguro+Despesa) para nao gerar valor de frete para itens de "Retira" quando existir itens de "Entrega Junto" na mesma venda
		//Pois o valor de frete somente deve estar no item de "Entrega" e nao no item de "Retira"
		If nModulo == 12 .And. !lMVLJPDVPA .And. IsInCallStack("LJ7PEDIDO") .And. IsInCallStack("LOJA701") //Verifica se esta executando a finalizacao de Venda pelo Venda Assistida On-Line
			nFreDesSeg := Lj7CalcFrete(.T.,If(MaFisFound("NF"),MaFisRet(,"NF_VALSOL")>0,.F.))
		EndIf

		Lj7RecTrib(	@aVlrAcres	, nDescOrc   	, nFreDesSeg , cLQFrete	 ,;
					lJob		, lEmiteNf   	, nVlrAcrsFi , @aAcrFin	 ,;
					nValRes		, nDescontFi	, nOpc       , aTaxJuros ,;
					nTotICM		, aDadosCNeg	, @nTotImpNCM	, @nTotVLRNCM,;
					@nTotImpFED	, @nTotImpEST	, @nTotImpMUN)

		//Percorre todos os itens da Venda
		If (lEmitNFCe .Or. lIsPafNfce) .And. !lEmiteNF
			nX := 1
			While MaFisFound("IT", nX)
				If !MaFisRet(nX, "IT_DELETED")
					aNFCeICMST := Array(2)

					aNFCeICMST[1] := MaFisRet(nX, "IT_ITEM")
					aNFCeICMST[2] := {}

					Aadd( aNFCeICMST[2], MaFisRet(nX, "IT_MARGEM") )
					Aadd( aNFCeICMST[2], MaFisRet(nX, "IT_PREDST") )
					Aadd( aNFCeICMST[2], MaFisRet(nX, "IT_BASESOL"))
					Aadd( aNFCeICMST[2], MaFisRet(nX, "IT_ALIQSOL"))
					Aadd( aNFCeICMST[2], MaFisRet(nX, "IT_VALSOL") )
					Aadd( aNFCeICMST[2], MaFisRet(nX, "IT_VALFECP"))

					//alimenta o array estatico (aICMSST) do LOJNFCE.PRW
					If ExistFunc("LjSetICMST")
						LjSetICMST( aNFCeICMST )
					EndIf
				EndIf

				nX++
			End
		EndIf

	ElseIf cPaisLoc <> "BRA" .And. !lRecebe .AND. lRecTrib
		Lj7LocTrib(	aTaxJuros )
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Grava o Log de Recuperacao, caso esteja habilitado³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lLog1 .AND. lLog4 .AND. nHandle >= 0
	nSize 		:= FSeek( nHandle, 0, 2 )
	cRBuffer 	:= Space( nSize )

	FSeek( nHandle, 0, 0 )
	FRead( nHandle, @cRBuffer, nSize )

	cRBuffer := Encript( cRBuffer, 1 )
	If !("#TEF" $ cRBuffer)
		If lTefOk
			cRBuffer := cRBuffer + "#TEFS#"
		Else
			cRBuffer := cRBuffer + "#TEFN#"
		EndIf
	EndIf

	FSeek( nHandle, 0, 0 )
	FWrite( nHandle, Encript( cRBuffer, 0 ) )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Realiza a Impressao do Cheque. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(LjGetStation("IMPCHQ")) .AND. !Empty(LjGetStation("PORTCHQ"))
	LJ7ImpCH(@aImpCheque)
EndIf

If !lRecebe
	If lMVLJPDVPA
		lTemImpressao	:= .F.
		aAreaSL2		:= SL2->(GetArea())

		DbSelectArea("SL2")
		SL2->( DbSetOrder(1) )	//L2_FILIAL+L2_NUM+L2_ITEM+L2_PRODUTO
		If SL2->( DbSeek(xFilial("SL2")+SL1->L1_NUM) )
			While !EOF() .AND. (SL2->L2_FILIAL+SL2->L2_NUM == xFilial("SL2")+SL1->L1_NUM) .AND. lLoop
				If (Empty(SL2->L2_ENTREGA) .OR. (SL2->L2_ENTREGA == "2"))
					If !lGE .OR. ( lGE .AND. (!lMvLjImpGf .OR. (lMvLjImpGf .AND. !LjItGE(SL2->L2_PRODUTO))) )
						lTemImpressao := .T.
					EndIf
				EndIf

				If lMVLJPRDSV //Tratamento especifico para RPS - Venda de Produto x Servicos
					If If(lFunTesISS, LjIsTesISS(SL1->L1_NUM,SL2->L2_TES), SL2->L2_VALISS > 0) //Item de "servico"
						nVlrServic += SL2->L2_VLRITEM //Acumula o valor dos itens de "servico"
					EndIf
				Else
					If lTemImpressao
						lLoop := .F.
					EndIf
				EndIf
				SL2->( DbSkip() )
			End
			RestArea(aAreaSL2)
		EndIf
	ElseIf lMVLJPRDSV
		aAreaSL2 := SL2->(GetArea())
		DbSelectArea("SL2")
		SL2->(DbSetOrder(1))
		If SL2->(DbSeek(xFilial("SL2")+SL1->L1_NUM))
			While SL2->(!EOF()) .AND. SL2->L2_FILIAL+SL2->L2_NUM == xFilial("SL2")+SL1->L1_NUM
				If (If(lFunTesISS, LjIsTesISS(SL1->L1_NUM,SL2->L2_TES), SL2->L2_VALISS > 0)) //Item de "servico"
					nVlrServic += SL2->L2_VLRITEM //Acumula o valor dos itens de "servico"
				EndIf
				SL2->(DbSkip())
			End
		EndIf
		RestArea(aAreaSL2)
	EndIf

	//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Limpa L1_TIPODES para não recalcular desconto na retaguarda LJGRVBATCH	³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If lImpReserva .AND. ( !Empty(SL1->L1_TIPODES) .OR. (SL1->L1_TIPODES == "1"))
		RecLock("SL1",.F.)
		REPLACE SL1->L1_TIPODES WITH ""
		SL1->(MsUnLock())
    EndIf


	//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Quando ExecAuto e informou Doc/Serie  na chamada do Loja701, mantem os valores recebidos, ³
	//³se apenas NFC-e, gera Doc antes de transmitir com controle de transacao				     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lAutoExec .OR. ((lEmitNFCe .Or. lIsPafNfce) .And. !lEmiteNF  )

		If aRet[1]
			//Numeracao da serie, quando ExecAuto pode receber conteudo
			If Empty(M->LQ_SERIE)
				If lEmitNFCe .AND. lIsVendaVP .AND. SLG->(FieldPos("LG_SERNFIS")) > 0 
					// Venda Vale em estacao NFC-e presente pega série do campo LG_SERNFIS
					cSerie	:= LjGetStation("LG_SERNFIS") 
				Else
					cSerie	:= Padr(LjGetStation("LG_SERIE"),TamSx3("LG_SERIE")[1])
				EndIf	
			Else
				cSerie	:= M->LQ_SERIE
			EndIf

			//Controle sequencial da Nota, quando ExecAuto pode receber conteudo
			If !Empty(M->LQ_DOC)
				cDoc := M->LQ_DOC
			Else
				//Trata quando RPS e Nfc-e
				lTemItProd := .F.
				lTemItServ := .F.
				If (lEmitNFCe .Or. lIsPafNfce) .And. nVlrServic > 0 .And. ExistFunc("LjCheckRPS")
					LjCheckRPS(SL1->L1_NUM, @lTemItProd, @lTemItServ)
					If lTemItServ .And. !lTemItProd
						aNotaRPS := LjSerNfRPS(lFtvdVer12)
						If aNotaRPS[1]
							cNumCupom := aNotaRPS[2][1]
							cNfRPS	  := aNotaRPS[2][1]
							cSerRPS	  := aNotaRPS[2][2]
						EndIf
					EndIf
				EndIf
				lOnlyServ := lTemItServ .And. !lTemItProd .And. !Empty(cSerRPS)	//Se a variavel "cSerRPS" nao esta vazia eh pq a venda possui apenas itens de "servico"

				//Se for ambiente NFC-e, porém vendendo somente Serviço ou Vale Presente (qualquer comprovante nao-fiscal),
				//não se  deve obter a numeração do SX5, para que nao haja lacunas na numeração da nota
				If (lEmitNFCe .Or. lIsPafNfce) .AND. (lOnlyServ .OR. lIsVendaVP)
					cDoc := cNumCupom
				Else
					LjxDNota(cSerie,3,.F.,1,@aNotas,Nil,Nil,Nil,Nil,Nil,Nil,Nil,Nil,Nil,Nil,Nil,SL1->L1_NUM)
					
					If Len(aNotas) > 0
						cDoc := aNotas[1][2]										
					EndIf
				EndIf
			EndIf
			
			If (!lEmitNFCe .AND. Empty(cDoc)) .OR. ( lEmitNFCe .AND. Empty(cSerie) )//Se cDoc vazio, nao encontrou serie na SX5 para gerar sequencial de documento
				// Se regime NFC-e pega a serie nao fiscal do campo LG_SERNFIS do cadastro de estacao
				If lEmitNFCe
					aRet := { .F. , " ", STR0214 + CHR(13)+CHR(10) + STR0215 + CHR(13)+CHR(10) + STR0216 } //"Falha ao buscar a série do Documento" + "Verifique o preenchimento do campo 'Serie não Fiscal' no cadastro de estação (LG_SERNFIS)" + "Procure por :'Como configurar uma série para documentos não-fiscais para NFC-e' no TDN"
				Else
					aRet := { .F. , " ", STR0214 } //"Falha ao buscar a série do Documento"
				EndIf
			Else
				If Empty(M->LQ_PDV)
					cPdv := LjGetStation("LG_PDV")
				Else
					cPdv := M->LQ_PDV
				EndIf
	
				//Quando não possui, gera numero da Nota(NFC-e) - Quando integracao via ExecAuto com PDV de terceiros, serie/nota pode estar preenchido
				If Empty(cSerie)
					cSerie	:= LjGetStation("LG_SERIE")
				EndIf
	
				aRet := { .T. , {cDoc,cPdv},'' }
			EndIf
		EndIf
	EndIf

	If lFiscal .AND. !lEmiteNF .OR. ((lEmitNFCe .Or. lIsPafNfce) .And. !lEmiteNF .AND. !lAutoExec)

		If !lEmitNFCe .And. !lIsPafNfce
			If cPaisLoc == "ARG"
			    nRet := Lj7PegCupArg(nHdlECF, @cNumCupom)
			Else
				nRet := IfPegCupom(nHdlECF, @cNumCupom)
			EndIf

		 	If !Lj7VerCmd( nRet ) .AND. lVAssConc
		       aRet[1]  := .F.
			   aRet[2]  := " "
			   aRet[3]  := STR0110   //"Falha em pegar o numero do Cupom"
		    EndIf

		    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		    //³Para venda concomitante, ja pegou o numero do cupom na inclusao ³
		    //³do primeiro item da venda									   ³
		    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lVAssConc .And. !lIsVendaVP .And. !lIsRecarCP
	            cNumCupom := PadR( StrZero(Val(cNumCupom),Len(cNumCupom)) , TamSx3("L1_DOC")[1] )
	 		Else
	            cNumCupom := PadR( StrZero(Val(cNumCupom)+1,Len(cNumCupom)) , TamSx3("L1_DOC")[1] )
			EndIf

		    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		    //³ Pega o numero do PDV                                         ³
		    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		    nRet := IfPegPDV( nHdlECF, @cNumPdv )
		    If !Lj7VerCmd( nRet )
		       aRet[1]  := .F.
			   aRet[2]  := " "
			   aRet[3]  := STR0072   //"Falha em pegar o numero do PDV"
		    EndIf

			If cPaisLoc <> "ARG"
			   cSerie   := Padr(LjGetStation("LG_SERIE"),TamSx3("LG_SERIE")[1])
			Else
			   cSerie   := Lj7SerArg()
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica Se o Cupom Ja Foi Processado.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SF2->( DbSetOrder(1) )	//F2_FILIAL + F2_DOC + F2_SERIE + F2_CLIENTE + F2_LOJA
			If SF2->( DbSeek(xFilial("SF2")+cNumCupom+cSerie) )
				aRet[1] := .F.
				aRet[2] := " "
				aRet[3] := STR0044 +SL1->L1_NUM+Chr(10)+ STR0045 +SL1->L1_DOC+SL1->L1_SERIE       //"Orcamento: " "DOC e SERIE ja existente no SF2: "
			EndIf
		EndIf

		If lEmitNFCe .Or. lIsPafNfce .OR. !SF2->(Found())

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Faz a impressao do cupom fiscal                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cPaisLoc <> "ARG"
				If cTipTef == TEF_CLISITEF .AND. lTefOk .AND. !lMVTELAFIN
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ soh chamara a LJVERADM se for forma TEF. Antes a forma CH, que nao eh
					//  forma TEF , entraria na funcao por causa da habilitacao do TELECHEQUE ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If aScan(aPgtos,{|x|,Alltrim(x[3]) $ _FORMATEF }) > 0
						aRet[1] := LJVERADM( @lSemRede, lTefOk, lTefManual, NIL , lSelTefManu )
					EndIf

					If !aRet[1]
						lTefOK 	:= .F.
						lTemTEFPend := .T.
					EndIf
				EndIf

				If aRet[1] .AND. lTemImpressao

                    //Tratamento para impressão do termo de garantia estendida
					Lj7ImpGe(@nVlrGar,@nFatorGar,@aProdGar,@nValRes,@nFatorVen,@nFatorRes,lImpReserva,lMvLjImpGf,cMvLjTGar,lVAssConc,lEmiteNF)
					
					If lMVLJPRDSV .And. nVlrServic > 0

						nFatorServ 	:= nVlrServic / SL1->L1_VLRLIQ 	//Calcula fator (Itens de Servico)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Faz a impressao do Cupom Nao fiscal - CNF (comprovante da venda de servico) no Caso de Itens de Servico	 ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						LjMsgRun( STR0013,, {|| Lj7ImpCNF( lTefOk, nFatorServ, Nil, Nil,;
															Nil  , Nil		 , 2 ) } )    //"Aguarde ... imprimindo o comprovante de venda ...."

					ElseIf lIsVendaVP //Verifica se eh venda de Vale Presente

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Faz a impressao do Cupom Nao fiscal - CNF (comprovante da venda de Vale Presente) no Caso de Venda de Vale Presente	³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						/*
							Somente retornamos o NUMERO e SERIE para uso do Vale Presente quando for NFC-e,
							caso contrario, sera usado o COO retornado do ECF
						*/
						If lEmitNFCe .Or. lIsPafNfce
							LjMsgRun( STR0013,, {|| aRet := Lj7ImpCNF( lTefOk	, 1		, Nil	, Nil	,;
																		Nil 	, Nil	, 3 	) } )
						Else
							LjMsgRun( STR0013,, {|| Lj7ImpCNF( lTefOk	, 1		, Nil	, Nil	,;
																Nil 	, Nil	, 3 	) } )	//"Aguarde ... imprimindo o comprovante de venda ...."
						EndIf

					ElseIf lIsRecarCP //Verifica se eh venda de Recarga de Cartao Presente (Gift Card)

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Faz a impressao do Cupom Nao fiscal - CNF (comprovante da venda de Recarga de Cartao Presente) no Caso de Recarga de Cartao Presente (Gift Card) ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						LjMsgRun( STR0013,, {|| Lj7ImpCNF( lTefOk, 1, Nil, Nil,;
															Nil  , Nil		 , 4 ) } )    //"Aguarde ... imprimindo o comprovante de venda ...."

					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Trata os valores com reserva ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If nValRes > 0 .AND. nVlrGar <= 0
						nFatorVen := Lj7FatRes(nValRes, SL1->L1_VLRLIQ + SL1->L1_DESCONT)[1]
						nFatorRes := Lj7FatRes(nValRes, SL1->L1_VLRLIQ + SL1->L1_DESCONT)[2]
					EndIf

					If !lEmitNFCe .And. !lIsPafNfce
						While .T.
 							If Len(aPafNotaCF) > 0
								cNumNotaCF := aPafNotaCF[2][2]
							Else
								cNumNotaCF := ""
							EndIf

							LjMsgRun( STR0012,, {|| (aRet := Lj7ImpCF(	lTefOk    	, cNumCupom	, cNumPdv		, cMsgResg	,;
																			aVlrAcres 	, cLQFrete  , nVlrAcrsFi	, lCartao	,;
																			@aSitTrib	, nFatorRes , nFatorVen 	, aTaxJuros ,;
																			@cNfRPS 	, @cSerRPS  , nVlrGar ,nTotImpNCM	,;
																			nTotVLRNCM	, nTotImpFED,	nTotImpEST, nTotImpMUN ,;
																			cNumNotaCF ) ) } ) 	//"Aguarde ... Imprimindo o cupom fiscal ...."

							lOnlyServ := !Empty(cSerRPS)	//Se a variavel "cSerRPS" nao esta vazia eh pq a venda possui apenas itens de "servico"

							lErroCF := !aRet[1]

							If lErroCF
								If !Empty(aRet[3])			// ""Atencao!" ### "Tentar imprimir novamente?" ### "&Sim" "&Não" ### "Impressora não responde!"
									cMsg := aRet[3] + CTRL + STR0050
								Else
									cMsg  := STR0050
								EndIf

								If Aviso(STR0031,cMsg,{STR0051,STR0052},,STR0049) == 1 // ""Atencao!" ### "Sim" ### "Nao" ### "Impressora nao responde!"
									Loop
								EndIf
							Else
								lCupFiscal := .T.
							EndIf
							Exit
						End

					EndIf

                    // Tratamento para garantia estendida com impressoa de comprovante nao fiscal
					If lGE  .AND. lVAssConc .AND. nFatorGar > 0 .AND. Len(aProdGar) > 0
						// Imprimira o comprovante nao fiscal somente apos terminar o cupom fiscal , com
						// venda concomitante
						LjMsgRun( STR0013,, {|| Lj7ImpCNF( Nil, nFatorGar , Nil, 	Nil,;
															Nil  , Nil		 , 1   , aProdGar ) } )    //"Aguarde ... imprimindo o comprovante de venda ...."
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Relatorio Gerencial ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If HasTemplate("OTC") .AND. lRelatGere

						If !Empty( M->LQ_NROPCLI)    // Verifica se a OS esta nula
							DbSelectArea("SB1")
							SB1->( DbSetOrder(1) )

							For nCount := 1 To Len(aCols)
								cOs := Stuff(ALLTRIM(M->LQ_NROPCLI),7,2,"") + StrZero(aCols[nCount][nPosConju],2)  // Ordem  de Servico

								If SB1->( DbSeek(xFilial("SB1") + aCols[nCount][2]) )
									If SB1->B1_TIPO $ cTiposProd .AND. aCols[nCount][nPosVenAvu] <> "1"
										Aadd( aRelatGere, aCols[nCount] )		// Array do Kit
										If nCount +1 > Len(aCols) .OR. aCols[nCount][nPosConju] != aCols[nCount + 1][nPosConju] // Quebra os Kits do Relatorio Gerencial
											Lj7ImpRg(nHandle,aRelatGere,cOs)	// Imprime o Relatorio Gerencial
											aRelatGere := {}
										EndIf
									EndIf
								EndIf

				 			Next nCount

						EndIf

					EndIf

				EndIf
	    	Else
				If aRet[1]
					LjMsgRun( STR0012,, {|| (aRet := Lj7ImpCFArg(aTaxJuros,aDadosCF)) } ) //"Aguarde ... imprimindo o cupom fiscal ...."
				 	lErroCF := !aRet[1]
					If lErroCF .AND. cPaisLoc == "ARG"
						cDoc := aRet[2][1]
						cPdv := aRet[2][2]
				   	EndIf
				EndIf
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Retorna o Contador de Cupom Fiscal  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (!lEmitNFCe .AND. lCupFiscal) .Or. lIsPafNfce
			nRet := IFStatus(nHdlECF, "35", @cContDoc)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Não possui emissão de Cupom Fiscal mas precisa guardar o PDV onde finalizou o orçamento  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (lMVLJPDVPA .AND. !lTemImpressao)
			aRet[2] := {"",cNumPdv}
		EndIf
	EndIf
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Realiza o(s) Recebimento Nao-Fiscal e a Autenticacao do(s) documento(s) ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (!lUsaTef) .OR. (lUsaTef .AND. !lCartao) .OR. ;
		(lUsaTef .AND. lCartao .AND. ( lTefOk .OR. lTefManual ) )

		For nI := 1 To Len(aTitulo)

			If !File( cGetCliDir+"SIGALOJA.INI" )
				WritePProString("Recebimento Titulos", "Totalizadores", "01", cGetCliDir+"SIGALOJA.INI")
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³VerIfica se existe o PE Lj7019, atraves do qual podera ser realizada³
			//³a impressão de um comprovante de pagamento do título.               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lLj7019 .AND. !lFtvdVer12
				xRet := ExecBlock( "LJ7019",.F.,.F.,{cTotRecNFis, aTitulo[nI][10], &(SuperGetMV("MV_NATRECE")), nI} )

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Caso ocorra algum problema na impressão do comprovante o PE   ³
				//³poderá retornar .F. e a gravação do recebimento será abortada.³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ValType(xRet) == "L"
					lRet := xRet
				EndIf
			EndIf

			If lFTVD7019 .AND. lFtvdVer12
				xRet := ExecBlock( "FTVD7019",.F.,.F.,{cTotRecNFis, aTitulo[nI][10], &(SuperGetMV("MV_NATRECE")), nI} )

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Caso ocorra algum problema na impressão do comprovante o PE   ³
				//³poderá retornar .F. e a gravação do recebimento será abortada.³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ValType(xRet) == "L"
					lRet := xRet
				EndIf
			EndIf
		Next nI
	EndIf
EndIf
//Tratamento para impressão do recibo não-fiscal e do termo de garantia estendida 
If !lImpReserva .And. lEmiteNF
	Lj7ImpGe(@nVlrGar,@nFatorGar,@aProdGar,@nValRes,@nFatorVen,@nFatorRes,lImpReserva,lMvLjImpGf,cMvLjTGar,lVAssConc,lEmiteNF)
EndIf 

LjGrvLog(SL1->L1_NUM,"MEIO DA GRAVACAO DA VENDA")
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Faz a gravacao dos dados (SL1, SL2 e SL4) #DADOSOK#³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRecebe
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Quando for recebimento via transacao TEF a gravacao so   ³
	//³ podera ser feita se a transacao foi efetuada com sucesso ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lUsaTef .AND. lCartao
		If lTefOk .OR. lTefManual
			LJGrvRec(aPgtos,,,,,,aTitulo,,,lSelTefManu,lTefManual)
		Else
			//"Transação Tef não concluída. Não será possível efetuar o Recebimento!"
			//"Atencao!"
			MsgStop(STR0075, STR0031)
		EndIf
	Else
		If LJAnalisaLeg(35)[1]
			dbSelectArea("SFI")
			SFI->(dbSetOrder(1))
			If !SFI->(dbSeek(xFilial("SFI") + DtoS(dDatabase) + LJGetStation("PDV")))
				LJGrvRec(aPgtos,,,,,,aTitulo,,,lSelTefManu,lTefManual)
			Else
				LJMsgLeg(LjAnalisaLeg(35))
			EndIf
		Else
			LJGrvRec(aPgtos,,,,,LJ7T_Troco(2),aTitulo,,,lSelTefManu,lTefManual)
		EndIf
	EndIf
	lRet := .T.
Else

	LjGrvLog(SL1->L1_NUM,"GRAVACAO DO DOC DA VENDA",aRet)

	If aRet[1]

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Checa o numero do COO, do PDV e da Serie                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cPaisLoc == "BRA" .OR. (cPaisLoc <> "BRA" .AND. lFiscal)

			//ÚÄÄÄÄÄ¿
			//³Cupom³
			//ÀÄÄÄÄÄÙ
		    If !lEmiteNF .AND. lTemImpressao .AND. !lFtvdVer12
				cDoc 	:= aRet[2][1]
				cPdv	:= aRet[2][2]
				If cPaisLoc <> "ARG"
					If lOnlyServ //A venda possui apenas itens de "servico"
						//Considera a serie da NF de Servico (RPS), pois a venda possui apenas itens de "servico"
						cSerie  := cSerRPS
						lNumcFis := .F.
					ElseIf (lEmitNFCe .Or. lIsPafNfce) .AND. lIsVendaVP
					   	cSerie := aRet[2][3]
					Else
					   	If lIntegDef //Integracao mantem a Serie informada
					   		cSerie := M->LQ_SERIE
					   	Else
					   		cSerie := LjGetStation("LG_SERIE")
					   	EndIf
				   	EndIf
				Else
				   cSerie   := Lj7SerArg()
				EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Nota - A numeracao da Nota/Serie sera atribuida pela funcao LJGRVTUDO()³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ElseIf !lFtvdVer12 .AND. ( (!lEmitNFCe .And. !lIsPafNfce) .Or. ((lEmitNFCe .Or. lIsPafNfce) .And. lEmiteNF))
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Salva PDV para sinalizar que orcamento foi importado ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lMVLJPDVPA
					cPdv	:= aRet[2][2]
				Else
				    cPdv    := ""
				EndIf
			    cDoc    := ""
				cSerie  := ""
			ElseIf lFtvdVer12
				If cPaisLoc <> "ARG"
					If !lIntegDef //Integracao mantem dados informados no XML
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Nota - A numeracao da Nota/Serie sera atribuida pela funcao LJGRVTUDO()³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						cPdv    := ""
						cDoc    := ""
						cSerie  := ""
					EndIf
				Else
					cSerie := Lj7SerArg()
				EndIf
			EndIf
		Else
			If cPaisLoc == "ARG" .AND. !lFiscal
				cSerie := Lj7SerArg()
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Release 11.5 - Controle de Formularios       ³
			//³Obter numero e serie do formulario informado ³
			//³pelo usuario no inicio da venda.             ³
			//³                                             ³
			//³Paises: Chile/Colombia  - F1CHI              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lCFolLocR5
				lNumcFis := .F.
				If !Empty(cDocFo) .AND. LjGRecFo() > 0
					cDoc := cDocFo
					nRecnoSFP := LjGRecFo()
   					LjxDadosFo(nRecnoSFP,NIL,NIL,NIL,@cSerie)
				EndIf
			EndIf
		EndIf

		lSelTefManu :=  (lSelTefManu .And. (cPaisLoc == "BRA"))
		
		If lSelTefManu .And. ExistFunc("LjxTelaNSU")//Nao precisa fazer outras validações pois a variavel só vem .T. caso venda com cartao e Tef Manual
			For nX := 1 To Len(aPgtos)
				If Alltrim(aPgtos[nX][3]) $ _FORMATEF .AND. lUsaTef

					// Se existir no aTEFDados, a transacao ja foi CONFIRMADA e sera reutilizada
					If lTEFMult .AND. Type("aTEFDados") == "A" .AND. Len(aTEFDados) > 0 .AND. Len(aTEFDados[1]) >= 20
					
						If aScan( aTEFDados, {|x| x[20]+x[19] == aPgtos[nX][3] + aPgtos[nX][8] } ) > 0	//comparacao entre FORMA + ID
							LjGrvLog( Nil, "Lj7GrvVenda - Transacao TEF reaproveitada", aPgtos[nX][3] + aPgtos[nX][8] )
							loop
						EndIf
					EndIf

					//Soma dos valores enviados para pagamento com cartão para confrontar com o pago no POS
					/*If aPgtos[nX][3] $ "CC|CD"
						nTotCart += aPgtos[nX][2]
					EndIf	*/	
					
					nAux := Ascan(aNSUVndTef, {|x| AllTrim(x[1])+x[2] == AllTrim(aPgtos[nX][3])+aPgtos[nX][8]}) //Forma + ID
					
					If nAux > 0
						aNSUVndTef[nAux][3] += aPgtos[nX][2]
					Else
						Aadd(aNSUVndTef,{AllTrim(aPgtos[nX][3]),aPgtos[nX][8],aPgtos[nX][2],""}) //Forma , ID , Valor , NSU digitada
					EndIf
				EndIf
			Next nX
			
			If Len(aNSUVndTef) > 0
				For nX := 1 to Len(aNSUVndTef)
					LjGrvLog(Nil, "Lj7GrvVenda - Chamada da Tela para Digitação da NSU - TEF Manual")
					
					LjxTelaNSU(@aNSUVndTef[nX],@aIdPgtoMfe)
					//IMPORTANTE: NAO RETIRAR ESTE TECHO
					//Tratamento para validação do pagamento efetuado no POS
					/*If lMFE
						aRetVldMFE := LjVldPgto(aIdPgtoMfe[nX][1])
						//aRetVldMFE := LjVldPgto(aNSUVndTef[nX][4])
						If Len(aRetVldMFE) > 0
							aNSUVndTef[nX][4] := aRetVldMFE[8][2]	//NSU do pagamento
							aAdd(aNSUVndTef[nX],aRetVldMFE)
							nTotPOS += IIf( !Empty(aRetVldMFE[9][2]), Val(aRetVldMFE[9][2]),0 )
						EndIf	
					EndIf*/	
					LjGrvLog(Nil, "Lj7GrvVenda - Chamada da Tela para Digitação da NSU - Retorno:" , aNSUVndTef)
				Next nX
				//IMPORTANTE: NAO RETIRAR ESTE TECHO
				//Tratamento para efetuar o processo de cancelamento caso o valor do pagamento no POS seja diferente da venda
				/*If lMFE .And. ( nTotPOS <> nTotCart )
					MsgAlert("O valor do pagamento efetuado no POS ("+cValToChar(nTotPOS)+") é diferente do informado para o pagamento em cartão ("+cValTochar(nTotCart)+")." + CHR(10) + CHR(13);
							  +"Favor efetuar o cancelamento no POS e defina os pagamentos novamente.";
							)

					Lj7CancVenda(	"Erro na venda"	, cDoc		, cSerie	, cPdv			,;
									.F.			, lTefOk	, @lExistNF	, @cDescErro	,;
									.T. 		,  Nil		, Nil		, @aTefBKP		,;
									@lTemTEFPend	)

					aIdPgtoMfe := {}				
					Return .F.				
							
				EndIf*/

			EndIf
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Faz a gravacao do SL1                                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aAdd( aSL1, { "L1_NUM"    ,SL1->L1_NUM } )

		If Len(aPafNotaCF) > 0
			cDoc	:= aPafNotaCF[2][2]
			cSerie	:= SuperGetMV("MV_LJSNCFP",,"61") //Parametro usado somente em homologacao para pegar a série desse Cupom sobre Nota
		Else
			If !Ascan(aSL1, {|x| AllTrim(upper(x[1])) == "L1_PDV"}) > 0
				aAdd( aSL1, { "L1_PDV"    ,cPdv } )
			EndIf	
		EndIf

		aAdd( aSL1, { "L1_DOC"    ,cDoc } )		
		
		If lOnlyServ .AND. lMVLJPRDSV .AND. ( lUseSAT .OR. !lMvNFCeCnj ) .AND. SL1->L1_TPORC == "E"
			//Trata se não está habilitada a funcionalidade de nfce conjugada
			aAdd( aSL1, { "L1_TPORC"    ,"" } )	
			aAdd( aSL1, { "L1_SERSAT"    ,"" } )	
		EndIf
		
		If Len(aNSUVndTef) > 0 //Insere o numero da NSU, caso tenha sido preenchido manualmente
			cNSUVndTef	:= aNSUVndTef[1][4] //pego o primeiro conteudo do array, pois o importante mesmo é o SL4
			If !Empty(AllTrim(cNSUVndTef))
				cL1NSUTEF := cNSUVndTef
								
				aAdd( aSL1, { "L1_VENDTEF", "S"})
				aAdd( aSL1, { "L1_DOCTEF" , cNSUVndTef } )
				aAdd( aSL1, { "L1_NSUTEF" , cL1NSUTEF } )
				aAdd( aSL1, { "L1_DATATEF", Str(Year(dDataBase),4)+StrZero(Month(dDataBase),2)+StrZero(Day(dDataBase),2) } )
			Else
				LjGrvLog(Nil,"Atenção: Tela de NSU foi aberta porem não foi " +;
							 "digitado um numero de transacao. SL1 será gravada sem dados de TEF Manual")
			EndIf
		EndIf
		
		aTimeUf := { dDataBase, Time()}

		If cPaisLoc == "BRA"
			If cHoraRMT == "3" 
				aArea2	:= GetArea()
				dbSelectArea("SM0")
				aAreaSM0	:= GetArea()
				dbSetOrder(1)
				If dbSeek(cEmpAnt+cFilAnt)
					aTimeUf := FwTimeUF(SM0->M0_ESTENT,,lHVerao)
					aTimeUf[1] := StoD(aTimeUf[1])
				EndIf
				RestArea(aAreaSM0)
				RestArea(aArea2)
			ElseIf cHoraRMT == "1" .AND. !IsBlind() 
				aTimeUf := { GetRmtDate(), GetRmtTime()}
			EndIf

		EndIf
		
		//NFCe sofre rejeicao quando direnca de horario, caso tenha transacao TEF, devido a demora no processamento do TEF, pode entrar nessa condicao e ter rejeicao
		If !lEmiteNf 
			If lUseSAT
				aAdd( aSL1, { "L1_HORA", Time() } )
			EndIf
		Else
			aAdd( aSL1, { "L1_HORA", aTimeUf[2] } )
		EndIf
	
		If lIntegDef //Integracao mantem informacoes da integracao
			aAdd(aSL1, {"L1_NUMCFIS", M->LQ_NUMCFIS})		
		ElseIf lNumcFis .And. !lIsVendaVP .And. !lIsRecarCP
			If Len(aPafNotaCF) > 0
				//Devo gravar o numero do cupom fiscal para mostrar no registro do PAF
				aAdd(aSL1 , {"L1_NUMCFIS", cNumCupom})
			Else
				aAdd( aSL1, { "L1_NUMCFIS",cDoc } )
			EndIf
		EndIf
		
		If !(Len(aPafNotaCF) > 0) //Quando Emissao de Nota, não preenche o PDV
			aAdd( aSL1, { "L1_PDV"  ,cPdv } )
		EndIf
		
		If !Empty(M->LQ_SERIE) .AND. (lEmitNFCe .Or. lIsPafNfce .Or. Empty(cSerie))
			cSerie	:= M->LQ_SERIE
		EndIf

		aAdd( aSL1, { "L1_SERIE"  ,cSerie } )
		//Qdo. for PAF-ECF e a venda possui apenas itens de "servico", alimenta o campo L1_DOCRPS e L1_SERRPS com o mesmo conteudo dos campos L1_DOC e L1_SERIE.
		//Desta forma, sera possivel identificar que o numero da Nota/Serie devera ser substituida no processamento do LjGrvBatch na retaguarda.
		If lMVLJPRDSV .And. lMVLJPDVPA .And. lOnlyServ
			aAdd( aSL1, { "L1_DOCRPS"  ,cDoc } )
			aAdd( aSL1, { "L1_SERRPS"  ,cSerie } )
		EndIf
		aAdd( aSL1, { "L1_TIPO"   ,"V" } )
		
		If lIntegDef //Integracao mantem operador informado
			aAdd( aSL1, { "L1_OPERADO", M->LQ_OPERADO } )
		Else
			If !Ascan(aSL1, {|x| AllTrim(upper(x[1])) == "L1_OPERADO"}) > 0
				aAdd( aSL1, { "L1_OPERADO",xNumCaixa() } )
			EndIf	
		Endif

		If !Empty(M->LQ_EMISNF) .AND. (lEmitNFCe .Or. lIsPafNfce) .AND. !lEmiteNf
			aAdd( aSL1, { "L1_EMISNF", 		M->LQ_EMISNF } )
		ElseIf nTipo <> 1
			aAdd( aSL1, { "L1_EMISNF", 		aTimeUf[1] } )

		EndIf

		aAdd( aSL1, { "L1_LOJA" ,SL1->L1_LOJA } )
		aAdd( aSL1, { "L1_CONTDOC", cContDoc} )

		/*	Caso seja PDV PAF ou Estado de SP/SC(Joinville) ou trabalhe
			com a NF Paulista ou Venda NFC-egrava o CGC no campo L1_CGCCLI
			ou se tem o parametro MV_LJDCCLI configurado para digitar o CPF/CNPJ
		*/
		If lEmitNFCe .Or. lIsPafNfce .OR. lMVLJPDVPA .OR. LjAnalisaLeg(30)[1] .OR. LjAnalisaLeg(46)[1]
			If Type("M->LQ_CGCCLI") <> "U"	.AND. (LJ7DImpCpf() .OR. lEmitNFCe .Or. lIsPafNfce)
				Aadd(aSL1,{ "L1_CGCCLI" , IIf(!Empty(M->LQ_CGCCLI) .OR. lUseSat ,M->LQ_CGCCLI ,SA1->A1_CGC) } )
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se Existir o Campo L1_NumMov,Grava o Numero do Ultimo Movimento do SLW ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SL1->(ColumnPos("L1_NUMMOV")) > 0
			AAdd( aSL1, { "L1_NUMMOV", LJNumMov()} )
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Tratamento dos campos de transferencia de portador e ³
		//³carteira automatico (FRA)                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SL1->(ColumnPos("L1_TRCXGER")) > 0 .AND. !lFtvdVer12
			If lUsaFecha .AND. lUsaTransf
				aAdd(aSL1,{"L1_TRCXGER",.T.})
			Else
				aAdd(aSL1,{"L1_TRCXGER",.F.})
			EndIf
		EndIf
		If SL1->(ColumnPos("L1_TREFETI")) > 0 .AND. !lFtvdVer12
			aAdd(aSL1,{"L1_TREFETI",.F.})
		EndIf

		/*Tratamento colocado para que seja apagado as informacoes quando
		orcamento reaprovatado (cancelada no LOJA140) com TEF*/
		aAdd( aSL1, { "L1_DOCCANC" , ""	} )
		aAdd( aSL1, { "L1_DATCANC" , ""	} )
		aAdd( aSL1, { "L1_HORCANC" , ""	} )		

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza os campos L1_EMISSAO e L1_EMISNF     ³
		//³se a database do sistema for dIferente da data³
		//³cronologica da impressora                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lEmitNFCe .And. !lIsPafNfce .AND. lFiscal .AND. lTemImpressao
			nRet := IfStatus( nHdlECF, '2', @cRetorno )
			If nRet == 0 .AND. (CtoD(cRetorno) <> dDataBase)
				aAdd( aSL1, { "L1_EMISSAO" ,dDataBase } )
				aAdd( aSL1, { "L1_EMISNF" ,dDataBase } )
		    	lAterSl2 := .T.
		    EndIf
		EndIf

		If cPaisLoc == "BRA" .OR. (cPaisLoc <> "BRA" .AND. lFiscal)
		    If (lEmiteNF .AND. lTemImpressao) .Or. (Len(aPafNotaCF)> 0 .And. aPafNotaCF[1][1] == "S") 
				//ÚÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ emite NF  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÙ
				aAdd( aSL1, { "L1_IMPRIME","2S" } ) // 1-Cupom | 2-Nota | 3-Cupom de Venda | 4-Nao Imprimir | 5-Cupom Eletronico(NFCe)
		    ElseIf lEmitNFCe .Or. lIsPafNfce
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ emite NFCe  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aAdd( aSL1, { "L1_IMPRIME","5S" } ) // 1-Cupom | 2-Nota | 3-Cupom de Venda | 4-Nao Imprimir | 5-Cupom Eletronico(NFCe)
		    Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ emite cupom  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aAdd( aSL1, { "L1_IMPRIME","1S" } ) // 1-Cupom | 2-Nota | 3-Cupom de Venda | 4-Nao Imprimir | 5-Cupom Eletronico(NFCe)
			EndIf
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Release 11.5 Chile/ Colombia.                            ³
			//³Se LjProfile(28) == .T. então grava no campo L1_IMPRIME =³
			//³4S nao imprime.                                          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If LjProFile(28) .AND. cPaisLoc$"CHI|COL"
				aAdd( aSL1, { "L1_IMPRIME","4S" } ) // 1-Cupom | 2-Nota | 3-Cupom de Venda | 4-Nao Imprimir | 5-Cupom Eletronico(NFCe)
		    Else
				aAdd( aSL1, { "L1_IMPRIME","2S" } ) // 1-Cupom | 2-Nota | 3-Cupom de Venda | 4-Nao Imprimir | 5-Cupom Eletronico(NFCe)
			EndIf
		EndIf

	    If CrdXInt()
	       If SL1->(ColumnPos("L1_CONTRA")) > 0
	          aAdd( aSL1, { "L1_CONTRA", cContrato })

	          Conout("31.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
	               " Contrato: " + If (Empty(cContrato), "", cContrato) +;
	      		   " adiciona CONTRATO no array SL1. " )

	       EndIf

	       If SL1->(ColumnPos("L1_FORCADA")) > 0

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Controlar se a venda foi off-line (1) ou uma venda on-line (2) - WebService³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		      If lForcada
			     aAdd( aSL1, {"L1_FORCADA", Str(FORCADA,1) } )

			     Conout("32.LOJA701C - Lj7GrvVenda - " +;
		     	   " Orcamento: " +  M->LQ_NUM +;
	               " Contrato : " + If (Empty(cContrato), "", cContrato) +;
	      		   " adiciona L1_FORCADA array SL1. " )


			     If SL1->(ColumnPos("L1_CGCCART")) > 0
			        If Empty(aCrdCliente[1]+aCrdCliente[2]) .AND. M->LQ_CLIENTE+M->LQ_LOJA <> cMV_CLIPAD+cMV_LOJAPAD
			           aCrdCliente  := AClone(CrdInfClie(M->LQ_CLIENTE, M->LQ_LOJA))
			        EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Grava no campo L1_CGCCART o Numero do CGC/CPF ou Numero do Cartao do Cliente, o que tiver sido informado.  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				    AADD( aSL1, {"L1_CGCCART", If(!Empty(aCrdCliente[1]), aCrdCliente[1], aCrdCliente[2]) } )

				    	Conout("33.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
 		            	" Cliente+Loja : " + M->LQ_CLIENTE+M->LQ_LOJA +;
	               		" CrdCliente : " + If (Empty(cContrato), "", cContrato) +;
	               		" L1_CGCCART: " +  If(!Empty(aCrdCliente[1]), aCrdCliente[1], aCrdCliente[2])+;
	               		" Preenche aSL1(L1_CGCCART) . " )

			     EndIf
		      Else
	    	        Conout("34.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
		            " Cliente+Loja : " + M->LQ_CLIENTE+M->LQ_LOJA +;
               		" Contrato: " + If (Empty(cContrato), "", cContrato) +;
      		   		" Preenche aSL1(FORCADA)=NAOFORCADA e  aSL1(CGCCART)= " )


			     aAdd( aSL1, {"L1_FORCADA", Str(NAOFORCADA,1) } )
			  EndIf
		   EndIf
        Else
    		Conout("35.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM + "  Sem Integracao com o CRD")
    		// Para imprimir o comprovante de recebimento
    		If (Lj950Acres(SM0->M0_CGC) .OR. (SuperGetMV("MV_LJICMJR",,.F.) .AND. cPaisLoc == "BRA"))
	    		ImpAcrsAux()
	    	Endif
	    EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualizando os valores totais da venda, % em juros e CC      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    If (lMvLjJurCC) .AND. (Len(aTaxJuros) > 0)
			If cPaisLoc == "BRA"
				aAdd( aSL1, {"L1_JUROS"		, aTaxJuros[1] + SL1->L1_JUROS } )
			EndIf
	    	aAdd( aSL1, {"L1_CARTAO"	, aTaxJuros[2] + SL1->L1_CARTAO } )

	    	aTaxJuros := {0,0,0,0}
	    EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualizando o valor para doação - Instituto Arredondar       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If SLQ->(ColumnPos("LQ_UMOV")) > 0 .AND. SL1->(ColumnPos("L1_UMOV")) > 0
	    	aAdd( aSL1, {"L1_UMOV", M->LQ_UMOV } )
		EndIf

		If SLQ->(ColumnPos("LQ_UMOVINF")) > 0 .AND. SL1->(ColumnPos("L1_UMOVINF")) > 0
	    	aAdd( aSL1, {"L1_UMOVINF", M->LQ_UMOVINF } )
		EndIf

		If cPaisLoc == "ARG" .And. SL1->(ColumnPos("L1_ADIC5")) > 0 .And. SLQ->(ColumnPos("LQ_ADIC5")) > 0
			aAdd( aSL1, {"L1_ADIC5", M->LQ_ADIC5 } )
			aAdd( aSL1, {"L1_ADIC61", M->LQ_ADIC61 } )
			aAdd( aSL1, {"L1_ADIC62", M->LQ_ADIC62 } )
			aAdd( aSL1, {"L1_ADIC7", M->LQ_ADIC7 } )
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Faz a gravacao do SL2                                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SL2")
		SL2->(DbSetOrder(1))
		SL2->(DbSeek(xFilial("SL2") + SL1->L1_NUM))
		nRecnoSL2  := Recno()
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Valor para dar baixa no Lay-Away  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nOutros    := SL1->L1_OUTROS
		While !SL2->(EOF()) .AND. SL2->L2_FILIAL + SL2->L2_NUM == xFilial("SL2") + SL1->L1_NUM

			aSL2 := {}
			If nPosStTrib > 0 .AND. Len(aSitTrib) > 0
				nPos := aScan( aSitTrib,{|x| x[1]== SL2->L2_ITEM+SL2->L2_PRODUTO })
				If nPos > 0
					Lj7AjustSt(@aSitTrib[nPos][2])
					aAdd( aSL2, { "L2_SITTRIB",aSitTrib[nPos][2]} )
				EndIf
            EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualiza os dados da SL2³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Lj7GeraSL( "SL2", aSL2 )

			aSL2 := {}
			aAdd( aSL2, { "L2_VENDIDO", 	"S" } )	// Gravar como "S" somente quando !Empty(L1_DOC)
			If lUseSAT
				aAdd( aSL2, { "L2_DOC",  "" } )
				aAdd( aSL2, { "L2_ESPECIE",  "SATCE" } )
			Else
				aAdd( aSL2, { "L2_DOC",  		cDoc } )
			EndIf
			aAdd( aSL2, { "L2_SERIE", 		cSerie } )
			
			If Len(aPafNotaCF) > 0
				aAdd( aSL2, { "L2_PDV", 	"" } ) //Homologacao 2017 PAF-ECF -> Gravo em branco pois o L1,F2 e D2 estão sem o PDV
			Else
				aAdd( aSL2, { "L2_PDV", 	cPdv } )
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualiza os campos L2_EMISSAO e L1_EMISNF     ³
			//³se a database do sistema for dIferente da data³
			//³cronologica da impressora                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lAterSl2
				aAdd( aSL2, { "L2_EMISSAO",	dDataBase } )
			EndIf

			If !Empty(SL2->L2_RESERVA) .AND. !lMVLJPDVPA
				aAdd( aReservas, { SL2->L2_RESERVA, SL2->L2_PRODUTO, SL2->L2_LOCAL } )
			EndIf

		    If AllTrim(Str(SuperGetMv("MV_LJGERSC",,1))) $ "2|3" .AND. SL2->(ColumnPos("L2_SOLCOM")) > 0
				aAdd( aSL2, { "L2_SOLCOM",	SL2->L2_SOLCOM } )
			Endif


			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Release 11.5 - Cartao fidelidade 			³
			//³Gravacao dos campos especificos para	recarga ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lLjcFid .AND. LaFunhProd(SL2->L2_PRODUTO)
			 	aAdd( aSL2, { "L2_PRODUTO", 	SL2->L2_PRODUTO } )
				aAdd( aSL2, { "L2_NUMCFID", 	SL2->L2_NUMCFID } )
				aAdd( aSL2, { "L2_DTSDFID", 	SL2->L2_DTSDFID } )
				aAdd( aSL2, { "L2_VLRCFID", 	SL2->L2_VLRCFID } )

				lRecFid		:= .T.
				cLojaFid	:= SL1->L1_LOJA
				cNumFid 	:= SL2->L2_NUMCFID
				dDataFid 	:= SL2->L2_DTSDFID
				nValRecFid 	:= SL2->L2_VLRCFID

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Recarga do cartao fidelidade processada: ³
				//³B - Via processo batch (LJGRVBATCH)      ³
				//³W - Via WebService(LJCCARFID) 		    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If  (nModulo == 23) .OR. (nModulo ==12 .AND. lMvLjPdvPa)
					If Ca280CkWs ()
						//W - Via WebService(LJCCARFID)
						aAdd( aSL2, { "L2_PROCFID", "W" } )
						lProcFidWs := .T.
					Else
						//B - Via processo batch (LJGRVBATCH)
						aAdd( aSL2, { "L2_PROCFID", "B" } )
						lProcFidWs := .F.
					EndIf
				ElseIf nModulo ==12 .AND. !lMvLjPdvPa
					//B - Via processo batch (LJGRVBATCH)
					aAdd( aSL2, { "L2_PROCFID", "B" } )
					lProcFidWs := .F.
				EndIf
			EndIf

			// Verifico se o Item eh vale Presente.
			If SL2->( ColumnPos("L2_VLTROCA") ) > 0 .AND. SL2->L2_VLTROCA == "1" 
				lValeTroca := .T.	
			EndIf

			DbSelectArea("SL2")
			SL2->(DbSkip())
		End

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Deleta as reservas qdo necessario                            ³
		//³ O SC0 esta sendo deletado aqui pq a B2AtuComD2 faz a atualiza³
		//³ cao do SB2->B2_RESERVA mas nao mata o SC0                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty( aReservas ) .AND. !lMVLJPDVPA
			DbSelectArea( "SC0" )
			SC0->(DbSetOrder( 1 )) // filial + numero + produto + local

			For nX := 1 To Len( aReservas )
				If SC0->(DbSeek( xFilial( "SC0" ) + aReservas[nX][1] + aReservas[nX][2] + aReservas[nX][3] ))
					BEGIN TRANSACTION

					    RecLock( "SC0", .F. )
						SC0->(DbDelete())
						SC0->(MsUnlock())

					END TRANSACTION
				EndIf
			Next nx
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Faz a gravacao do SL4 somente se nao for orcamento gerado de um pedido ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Empty( SL1->L1_FILRES ) .AND. Empty( SL1->L1_ORCRES )  .AND. (cTpGeraGdp == GDP_NO)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Teve abatimento total no valor da venda (PIS/COFINS/CSLL)³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Len( aPgtos ) == 1 .AND. Empty( aPgtos[01,01] ) .AND. aPgtos[01,02] == ( LJPCCRet() + If( LJ220AbISS(), MaFisRet( , 'NF_VALISS' ), 0 ) )
				lAbtoAll := .T.
			EndIf

			// Verifica se existem pagamentos em Vale Presente e adiciona mais linhas à aPgtos neste caso
			For nX := 1 to Len( aPgtos )
				If Type( "aPgtos[nX][4][4]" ) == "A"
					For nY := 2 to Len( aPgtos[nX][4][4] )
						aAdd( aPgtos, aClone( aPgtos[nX] ) )
						aPgtos[Len(aPgtos)][2]		:= aPgtos[nX][4][4][nY][2]
						aPgtos[Len(aPgtos)][4][4]	:= aPgtos[nX][4][4][nY][1]
					Next nY

					aPgtos[nX][2]		:= aPgtos[nX][4][4][1][2]
					aPgtos[nX][4][4]	:= aPgtos[nX][4][4][1][1]
				EndIf
			Next nX
			For nX := 1 to Len( aPgtos )
			    If (Alltrim( aPgtos[nX][3] ) $ _FORMATEF) .AND. lUsaTEF
					cAdminis := aPgtos[nX][4][5]
				Endif
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Calcula o valor da parcela quando o troco nao esta habilitado. Nao permite gerar parcela com valor zero³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lHabTroco .AND. ( lMVLJGRVON .OR. (!lMVLJGRVON .AND. nMVLJTRDIN == 0 ))
					nVlrParc  := aPgtos[nX][2]
				Else
					nVlrParc  := Round(Max(aPgtos[nX][2] - IIf(aPgtos[nX][6] <> nMoedaCor, xMoeda( nVlrTroco, nMoedaCor, aPgtos[nX][6], dDatabase ), nVlrTroco), 0), MsDecimais(aPgtos[nX][6]))
				EndIf


				If cPaisLoc <> "BRA"
					nMoedaParc := aPgtos[nX][_MOEDA]
					If aPgtos[nX][1] == dDatabase
						nVlrEntrada += Round(xMoeda(nVlrParc	, nMoedaParc	, nMoedaCor	, dDatabase	,;
											nDecimais+1,,nTxMoeda),nDecimais)
					EndIf
				EndIf

				If ( aPgtos[nX][2] <> 0 .AND. nVlrParc <> 0 )
					aAdd( aSL4, {} )
					aAdd( aSL4[Len( aSL4 )], { "L4_FILIAL",xFilial( "SL4" ) } )
					aAdd( aSL4[Len( aSL4 )], { "L4_NUM",	SL1->L1_NUM	} )
					aAdd( aSL4[Len( aSL4 )], { "L4_DATA",	If( lAbtoAll, dDataBase, aPgtos[nX][1] ) } )

					/*Tratamento colocado para que seja apagado as informacoes quando 
					orcamento reaproveitado (cancelada no LOJA140) com TEF,
					se o pagamento da venda atual for TEF, ele apaga dentro do LOJXTEF*/
					aAdd( aSL4[Len( aSL4 )], { "L4_DOCCANC" , ""	} )
					aAdd( aSL4[Len( aSL4 )], { "L4_DATCANC" , ""	} )
					aAdd( aSL4[Len( aSL4 )], { "L4_HORCANC" , ""	} )

					If IsMoney(aPgtos[nX][3]) .OR. aPgtos[nX][3] == "VA"
						If cPaisLoc == "BRA"
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Utilizado para a gravacao de troco em qualquer	 |
							//³ numerario										 |
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							aAdd( aSL4[Len( aSL4 )], { "L4_VALOR", nVlrParc } )
						Else
							nVlrTrcAux := Round(xMoeda(nVlrTroco	, nMoedaCor	, aPgtos[nX][6]	, dDatabase	,;
												MsDecimais(aPgtos[nX][6])+1),MsDecimais(aPgtos[nX][6]))
							aAdd( aSL4[Len(aSL4)], { "L4_VALOR", 	aPgtos[nX][2] - nVlrTrcAux } )
						EndIf
						
						If !lIntegDef //Integracao nao considera troco
							nVlrTroco -= If( nVlrTroco > 0, Lj7T_Troco( 2 ), 0 )
						EndIf
					Else
						aAdd( aSL4[Len( aSL4 )], { "L4_VALOR", 	If( lAbtoAll, 0, aPgtos[nX][2] ) } )
					EndIf

					aAdd( aSL4[Len( aSL4 )], { "L4_FORMA",	If( lAbtoAll, cMVSimb1, aPgtos[nX][3] ) } )

				    lAjstaPgto := .F.
				    If (Alltrim( aPgtos[nX][3] ) $ _FORMATEF) .AND. cTipTef == TEF_CLISITEF .AND. lUsaTEF
				    	// Chama a LjVerAdm para ajustar o array aPgtos na posicao referente ao Cod Adm Financeira
						lAjstaPgto := LjVerAdm(.F.,.T.,lTefManual,nX,lSelTefManu)
					Endif

					If !(IsMoney(aPgtos[nX][3])) .AND. Empty(SL1->L1_FILRES) .AND. Empty(SL1->L1_ORCRES) .AND.	!lLayAway

						If Trim(aPgtos[nX][3]) == "CH"
							aAdd( aSL4[Len( aSL4 )], { "L4_ADMINIS",	aPgtos[nX][4][04] } )
							aAdd( aSL4[Len( aSL4 )], { "L4_NUMCART",	aPgtos[nX][4][07] } )
							aAdd( aSL4[Len( aSL4 )], { "L4_AGENCIA",	aPgtos[nX][4][05] } )
							aAdd( aSL4[Len( aSL4 )], { "L4_CONTA",		aPgtos[nX][4][06] } )
							aAdd( aSL4[Len( aSL4 )], { "L4_RG",			aPgtos[nX][4][09] } )
							aAdd( aSL4[Len( aSL4 )], { "L4_TELEFON",	aPgtos[nX][4][10] } )
							aAdd( aSL4[Len( aSL4 )], { "L4_COMP",		aPgtos[nX][4][08] } )
							aAdd( aSL4[Len( aSL4 )], { "L4_TERCEIR",	aPgtos[nX][4][12] } )
							aAdd( aSL4[Len( aSL4 )], { "L4_NOMECLI",	aPgtos[nX][4][14] } )
						Else
							If !lAbtoAll
								If Len(aPgtos[nX][4]) > 4
                                    //Não considera TEF quando execAuto, os dados ja vem preenchidos na chamada da execauto
									If !lAutoExec .AND. (Alltrim(aPgtos[nX][3]) $ _FORMATEF) .AND. (cTipTef $ TEF_SEMCLIENT_DEDICADO + ";" + TEF_COMCLIENT_DEDICADO + ";" + TEF_DISCADO) .AND. lUsaTEF

										If Len(aArrayTEFPos) == 0 .OR. (Alltrim(aArrayTEFPos[len(aArrayTEFPos)][1])+Alltrim(aArrayTEFPos[Len(aArrayTEFPos)][2]) <> ;
																		 Alltrim(aPgtos[nX][3])+Alltrim(aPgtos[nX][8]))

											//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
											//³Primeiro faz comparacao entre administradora informada e bandeira da administradora³
											//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                  							nPosTefDados := aScan(aTefDados,{|x|,Alltrim(x[19]) == Alltrim(aPgtos[nX][8])})
                  							nPosTefSint := aScan(aPgtosSint,{|x|,Alltrim(x[04]) == Alltrim(aPgtos[nX][8])})
           									If nPosTefDados > 0

	 											cAdminis := LJ7ConfAdm( aPgtos[nX][4][5], aTefDados[nPosTefDados][18],,aTefDados[nPosTefDados][20],aTefDados[nPosTefDados][19],,aPgtosSint[nPosTefSint][2],,,,, aTefDados[nPosTefDados][8] )

 												If !( aTefDados[nPosTefDados][18] $ cAdminis )

	 												If cTipTEF <> TEF_DISCADO
														//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
														//³Se retorno for diferente, faz comparacao entre administradora informada e administradora retornada³
														//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		 												cAdminis := LJ7ConfAdm( aPgtos[nX][4][5], aTefDados[nPosTefDados][8],,aTefDados[nPosTefDados][20])
													Else
	 													// Retorno da forma seleciona na tela de escolha da Adm Financeira
														aPgtos[nX][3] := aTefDados[nPosTefDados][20]
													Endif
												EndIf

											// Se for Pay&Go e MV_TEFMULT = .F.
 											Elseif (Alltrim( aPgtos[nX][3] ) $ _FORMATEF) .AND. cTipTEF == TEF_DISCADO .AND. !lTefMult .AND. lUsaTEF 
											
												cAdminis := LJ7ConfAdm( aPgtos[nX][4][5], aTefDados[1][18],,aTefDados[1][20],aTefDados[1][19],,aPgtosSint[1][2],,,,, aTefDados[1][8] )
	 											If !( aTefDados[1][18] $ cAdminis ) 
	 												// Retorno da forma seleciona na tela de escolha da Adm Financeira
													aPgtos[nX][3] := aTefDados[1][20]
												Endif												
											Else
												If nPosTefSint > 0
													cAdminis := LJ7ConfAdm( aPgtos[nX][4][5],,,aPgtosSint[nPosTefSint][1],aPgtosSint[nPosTefSint][4],,,,,,,, aPgtosSint[nPosTefSint][3] )
												Endif
 											EndIf

											Aadd(aArrayTEFPos,{aPgtos[nX][3],aPgtos[nX][8],cAdminis})
										Else
											cAdminis := aArrayTEFPos[Len(aArrayTEFPos)][3]
										Endif
										
										If Len(aNSUVndTef) > 0 //Insere o numero da NSU, caso tenha sido preenchido manualmente
											nAux := Ascan(aNSUVndTef, {|x| AllTrim(x[1])+x[2] == AllTrim(aPgtos[nX][3])+aPgtos[nX][8]}) //Forma + ID											
											cNSUVndTef := IIf( nAux > 0 , aNSUVndTef[nAux][4], "")
											If !Empty(AllTrim(cNSUVndTef))
												cL4NSUTEF := cNSUVndTef
												
												aAdd( aSL4[Len( aSL4 )], { "L4_VENDTEF", "S"})
												aAdd( aSL4[Len( aSL4 )], { "L4_DOCTEF" , cNSUVndTef } )
												aAdd( aSL4[Len( aSL4 )], { "L4_NSUTEF" , cL4NSUTEF } )
												aAdd( aSL4[Len( aSL4 )], { "L4_DATATEF", Str(Year(dDataBase),4)+StrZero(Month(dDataBase),2)+StrZero(Day(dDataBase),2) } )

												If nPosTefDados > 0
													aTefDados[nPosTefDados][4] := cNSUVndTef
													aTefDados[nPosTefDados][9] := cL4NSUTEF
												ElseIf !lTefMult .Or. !(nPosTefDados > 0) 
													aTefDados[1][4] := cNSUVndTef
													aTefDados[1][9] := cL4NSUTEF
												EndIf
											Else
												LjGrvLog(Nil,"ATENCAO: NSU digitada não encontrada ou  " +;
															 "NSU não digitado (na tela). SL4 será gravada sem dados de TEF Manual")
											EndIf
										EndIf

									ElseIf !lAutoExec .AND. (Alltrim( aPgtos[nX][3] ) $ _FORMATEF) .AND. cTipTef == TEF_CLISITEF .AND. lUsaTEF
										// Por estar em um For e passar pelas mesmas posicoes varias vezes,
										// as variaveis sao inicializadas novamente a cada For
										nPosData   	:= 0
										dDataTrans	:= CtoD(Space(08))
										nPosTrans	:= 0
										nValorTrans := 0
										nPosRetCart := 0

										// oTef:aRetCartao > 1 quando venda com multiplos cartoes
										nPosRetCart := Iif(lTefMult, aScan(oTef:aRetCartao, {|x| x:CIDCART == aPgtos[nX][8] } ), 1)

										If nPosRetCart > 0
											// Procura pela data conforme condicao de pagamento/parcelamento (se for parcelado, procura pela data do vencimento da parcela)
											nPosData   	:= aScan(oTef:aRetcartao[nPosRetCart]:aDatas, {|x| x == aPgtos[nX][1] } )

											// Procura pelo valor da transacao (se for parcelado, procura pelo valor da parcela)
											nPosTrans	:= aScan(oTef:aRetcartao[nPosRetCart]:aValores, {|x| x == aPgtos[nX][2] } )

                                            If nPosData > 0 .And. nPosTrans > 0
                                            	dDataTrans := oTef:aRetcartao[nPosRetCart]:aDatas[nPosData]
												nValorTrans := oTef:aRetcartao[nPosRetCart]:aValores[nPosTrans]

												If lAtribRede //Verifica se o atributo cCodRede existe no objeto oTef:aRetCartao
													cCodRede 	:= oTef:aRetCartao[nPosRetCart]:cCodRede
													cDescRede 	:= oTef:aRetCartao[nPosRetCart]:cDescRede
												EndIf

												If  dDataTrans == aPgtos[nX][1]	 .AND. nValorTrans == aPgtos[nX][2]
													cAdminis  := LJ7ConfAdm( aPgtos[nX][4][5]											, oTef:aRetCartao[nPosRetCart]:cDescAdm , .F. 										, aPgtos[nX][_FORMAPGTO]				 ,;
																			 IIf(lTefMult,oTef:aRetCartao[nPosRetCart]:cIdCart ,NIL )	, oTef:aRetCartao[nPosRetCart]:cTipCart	, oTef:aRetCartao[nPosRetCart]:nParcelas	, oTef:aRetCartao[nPosRetCart]:cDescCart ,;
																			 Nil														, nPosRetCart							, Nil										, cDescRede								 ,;
																			 Nil														, cCodRede )
 												EndIf
 											Endif
										Endif

										//Caso o Tef Tenha sido cancelado mantem a admnistradora do aPgtos
										If Empty(AllTrim(cAdminis) ) .Or. (lAjstaPgto .And. lSelAdm)
											cAdminis  := aPgtos[nX][4][05]
										EndIf
										
										If Len(aNSUVndTef) > 0 //Insere o numero da NSU, caso tenha sido preenchido manualmente
											nAux := Ascan(aNSUVndTef, {|x| AllTrim(x[1])+x[2] == AllTrim(aPgtos[nX][3])+aPgtos[nX][8]}) //Forma + ID
											cNSUVndTef := IIf( nAux > 0 , aNSUVndTef[nAux][4], "")
											If !Empty(AllTrim(cNSUVndTef))
												cL4NSUTEF := cNSUVndTef
												
												aAdd( aSL4[Len( aSL4 )], { "L4_VENDTEF", "S"})
												aAdd( aSL4[Len( aSL4 )], { "L4_DOCTEF" , cNSUVndTef } )
												aAdd( aSL4[Len( aSL4 )], { "L4_NSUTEF" , cL4NSUTEF } )
												aAdd( aSL4[Len( aSL4 )], { "L4_DATATEF", Str(Year(dDataBase),4)+StrZero(Month(dDataBase),2)+StrZero(Day(dDataBase),2) } )
												
												If nPosRetCart > 0 //Preciso preencher para os campos da SE1 ficarem preenchidos
													oTef:aRetcartao[nPosRetCart]:CNSUAUTOR := cNSUVndTef
													oTef:aRetcartao[nPosRetCart]:CNSUSITEF := cL4NSUTEF
												EndIf												
											Else
												LjGrvLog(Nil,"ATENCAO: NSU digitada não encontrada ou  " +;
															 "NSU não digitado (na tela). SL4 será gravada sem dados de TEF Manual")
											EndIf
										EndIf
									Else
										cAdminis  := aPgtos[nX][4][05]
										
										// Insere o numero da NSU, caso tenha sido preenchido manualmente
										If lTefManual .And. lSelTefManu
											If Len(aNSUVndTef) > 0 
												nAux := Ascan(aNSUVndTef, {|x| AllTrim(x[1])+x[2] == AllTrim(aPgtos[nX][3])+aPgtos[nX][8]}) //Forma + ID
												cNSUVndTef := IIf( nAux > 0 , aNSUVndTef[nAux][4], "")
												If !Empty(AllTrim(cNSUVndTef))
													cL4NSUTEF := cNSUVndTef
													
													aAdd( aSL4[Len( aSL4 )], { "L4_VENDTEF", "S"})
													aAdd( aSL4[Len( aSL4 )], { "L4_DOCTEF" , cNSUVndTef } )
													aAdd( aSL4[Len( aSL4 )], { "L4_NSUTEF" , cL4NSUTEF } )
													aAdd( aSL4[Len( aSL4 )], { "L4_DATATEF", Str(Year(dDataBase),4)+StrZero(Month(dDataBase),2)+StrZero(Day(dDataBase),2) } )
													
													If nPosRetCart > 0 //Preciso preencher para os campos da SE1 ficarem preenchidos
														oTef:aRetcartao[nPosRetCart]:CNSUAUTOR := cNSUVndTef
														oTef:aRetcartao[nPosRetCart]:CNSUSITEF := cL4NSUTEF
													EndIf
													
													If lUsaTef .AND. cTipTef == TEF_NAO_USADO   // Caixa usa TEF e estacao nao tem TEF configurado, permite escolher a Adm Financeira
														cAdminis  := LJ7ConfAdm( aPgtos[nX][4][5], Nil, .F., aPgtos[nX][_FORMAPGTO] , aPgtos[nX][8], Nil, Nil, Nil,;
																				 lTefManual		 , Nil, Nil, Nil					, Nil		   , Nil, lSelTefManu)																		  
													Endif

													//Tratamento para POS gravar o ID do enviarPagamento ao validador fiscal
													//If lMFE .And. Len(aIdPgtoMfe) > 0
														//aAdd( aSL4[nX], { "L4_IDPGVFP", aIdPgtoMfe[nAux][1] })		
													//EndIf	

												Else
													LjGrvLog(Nil,"ATENCAO: NSU digitada não encontrada ou  " +;
																"NSU não digitado (na tela). SL4 será gravada sem dados de TEF Manual")
												EndIf
											EndIf
										EndIf
									EndIf

									If nPosTefDados > 0
										aAdd( aSL4[Len( aSL4 )], { "L4_NOMECLI",	"RD: " + Alltrim(aTefDados[nPosTefDados][8]) + " / BD: " + Alltrim(aTefDados[nPosTefDados][18]) } )
									ElseIf (Alltrim( aPgtos[nX][3] ) $ _FORMATEF) .AND. cTipTEF == TEF_DISCADO .AND. !lTefMult .AND. lUsaTEF
										aAdd( aSL4[Len( aSL4 )], { "L4_NOMECLI",	"RD: " + Alltrim(aTefDados[1][8]) + " / BD: " + Alltrim(aTefDados[1][18]) } )
									Endif

									aAdd( aSL4[Len( aSL4 )], { "L4_ADMINIS",	cAdminis } )

									// ----------------------------------------------------------
									//  Verifica a necessidade de alteração no vencimento das
									// parcelas para o Id do cartão em associação com o aSL4
									If lVcDUtil
										Lj7VcDUtil( aPgtos, nX )
									EndIf

									If lLjDespa
										If aPgtos[nX][4][10] .AND. aPgtos[nX][4][12] > 0
											aAdd( aSL4[Len( aSL4 )], { "L4_DESPRC",	aPgtos[nX][4][12] } )
									   	EndIf
										aAdd( aSL4[Len( aSL4 )], { "L4_BANPRC",	aPgtos[nX][4][11] } )
									EndIf
								EndIf

								If lMultNegoc .And. Len(aPgtos[nX]) > 10 .And. SL4->(ColumnPos("L4_DESCMN")) > 0
									aAdd( aSL4[Len(aSL4)], { "L4_DESCMN",		aPgtos[nX][11] } )
								EndIf
						    	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³Grava o valor do acrescimo separado da parcela ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If lVerEmpres .OR. (SuperGetMV("MV_LJICMJR",,.F.) .AND. cPaisLoc == "BRA")
							    	If ValType(aPgtos[nX][9]) == "N"
								   		aAdd( aSL4[Len( aSL4 )], { "L4_ACRSFIN", aPgtos[nX][9] } )
									Endif
								Endif

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³Release 11.5 - Cartao Fidelidade     ³
								//³Armazenar numero do cartao fidelidade³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If Len(aPgtos[nX][4]) > 0 .AND. lLjcFid .AND. AllTrim(aPgtos[nX][3]) = "FID"
									cLojaFid	:= SL1->L1_LOJA
									cNumFid		:= aPgtos[nX][4][1]
									nValFid 	:= aPgtos[nX][2]
									lRecFid		:= .F.

									aAdd( aSL4[Len( aSL4 )], { "L4_NUMCFID",	cNumFid } )
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³Recarga do cartao fidelidade processada: ³
									//³B - Via processo batch (LJGRVBATCH)      ³
									//³W - Via WebService(LJCCARFID) 		    ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									If  (nModulo == 23) .OR. (nModulo ==12 .AND. lMvLjPdvPa)
										If Ca280CkWs ()
											//W - Via WebService(LJCCARFID)
											aAdd( aSL4[Len( aSL4 )], { "L4_PROCFID", 	"W"} )
											lProcFidWs := .T.
										Else
											//B - Via processo batch (LJGRVBATCH)
											aAdd( aSL4[Len( aSL4 )], { "L4_PROCFID", 	"B"} )
											lProcFidWs := .F.
										Endif
									ElseIf nModulo ==12 .AND. !lMvLjPdvPa
										//B - Via processo batch (LJGRVBATCH)
										aAdd( aSL4[Len( aSL4 )], { "L4_PROCFID", 	"B"} )
										lProcFidWs := .F.
									EndIf
								EndIf

								If Len(aPgtos[nX][4]) > 3
									cNumCart := ""

									If AllTrim(aPgtos[nX][3]) == "VP"
										cNumCart := aPgtos[nX][4][04]
									ElseIf !Empty(aPgtos[nX][4][04])
										If Len(AllTrim(aPgtos[nX][4][04]))	>= 10
											//Armazena numero do cartao conforme permitido no padrao de seguranca PCI(6 primeiros + 4 ultimos numeros do cartao)
											cNumCart := Trim(SubStr(aPgtos[nX][4][04],1,6))

											If !Empty(SubStr(aPgtos[nX][4][04],7,Len(Trim(aPgtos[nX][4][04]))-10))
												cNumCart += EnCript( SubStr(aPgtos[nX][4][04],7,Len(Trim(aPgtos[nX][4][04]))-10),0)
											EndIf

											cNumCart += Trim(SubStr(aPgtos[nX][4][04],Len(Trim(aPgtos[nX][4][04]))-3,4))
										Else
										    cNumCart := Trim(aPgtos[nX][4][04])
										EndIf
									EndIf
									aAdd( aSL4[Len( aSL4 )], { "L4_NUMCART",	cNumCart } )
								EndIf

								//Grava o banco associado ao cartao de credito
								If cPaisLoc == "BOL" .AND. Len(aPgtos[nX][4]) >= 8 .AND. SL4->(FieldPos("L4_BCOCART")) > 0
									aAdd( aSL4[Len( aSL4 )], { "L4_BCOCART",	aPgtos[nX][4][8] } )
								EndIf

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³Faz tratamento quando usa adm financeira e usa Paf para gravar no sl4³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If (Trim(aPgtos[nX][3]) $ "CC|VA|CO|CD|FI" .AND. lMVLJPDVPA) .OR.;
									(Trim(aPgtos[nX][3]) $ "VA" .AND. !lMVLJPDVPA .AND. lCpoPCorte .AND. SAE->AE_PCORTE > 0)	//Somente Vales e Período de Corte (AE_PCORTE) preenchido
									SAE->( DbSetOrder( 1 ) )
									If SAE->( DbSeek( xFilial( "SAE" ) + SubStr( aPgtos[nX][4][05],1,3 ) ) )
										nPos	:= aScan( aSL4[nX], { |x| Alltrim( Upper( x[1] ) ) == "L4_DATA" } )
										dData	:= 	LJCalcVenc(.T., aPgtos[nX][1])
										If nPos > 0
											aSL4[nX][nPos][2] := dData
										Else
											aAdd( aSL4[Len( aSL4 )], { "L4_DATA",	dData } )
										EndIf
									EndIf
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³Se for Financiamento, verIfica se deve somar dias no vencimento³
								//³conforme informado no cadastro da administradora financeira    ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								ElseIf Trim(aPgtos[nX][3]) == "FI"
									SAE->( DbSetOrder( 1 ) )
									If SAE->( DbSeek( xFilial( "SAE" ) + SubStr( aPgtos[nX][4][05],1,3 ) ) )
										nPos	:= aScan( aSL4[nX], { |x| Alltrim( Upper( x[1] ) ) == "L4_DATA" } )
										If nPos > 0
											aSL4[nX][nPos][2]	:= aPgtos[nX][1] + SAE->AE_VENCFIN
										Else
											aAdd( aSL4[Len( aSL4 )], { "L4_DATA",	aPgtos[nX][1] + SAE->AE_VENCFIN } )
										EndIf
									EndIf
								EndIf

							EndIf
						EndIf
					EndIf

					If cTipTEF == TEF_DISCADO
						If nPosTefDados > 0
 							aAdd( aSL4[Len( aSL4 )], { "L4_FORMA",	If( lAbtoAll, cMVSimb1, Alltrim(aTefDados[nPosTefDados][20]) ) } )
	 					ElseIf (Alltrim( aPgtos[nX][3] ) $ _FORMATEF) .AND. cTipTEF == TEF_DISCADO .AND. !lTefMult .AND. lUsaTEF
 							aAdd( aSL4[Len( aSL4 )], { "L4_FORMA",	If( lAbtoAll, cMVSimb1, Alltrim(aTefDados[1][20]) ) } )
 						Endif
					Endif

					If cPaisLoc <> "BRA"
						aAdd( aSL4[Len( aSL4 )], { "L4_MOEDA", 	aPgtos[nX][_MOEDA] } )
					EndIf
				ElseIf !lIntegDef .AND. IsMoney(aPgtos[nX][3]) .OR. aPgtos[nX][3] == "VA"
					nVlrTroco -= If( nVlrTroco > 0, Lj7T_Troco( 2 ), 0 )
				EndIf
				If cTipTEF <> TEF_DISCADO
					cAdminis := Space(TamSX3("L4_ADMINIS")[1])
				Endif
				
				//Integracao Mensagem Unica - grava informacoes Tef integradas
				If lIntegDef 				 										
					If Len(aPgtos[nX]) >= _CONTAHTL
						aAdd( aSL4[Len( aSL4 )], { "L4_CONHTL", 	aPgtos[nX][_CONTAHTL] } )
						
						//Armazena informacoes Tef - Integracao Mensagem Unica
						aAdd( aSL4[Len(aSL4)], { "L4_VENDTEF"	, aPgtos[nX][_TEFINTEG][1] } )
						aAdd( aSL4[Len(aSL4)], { "L4_DATATEF" 	, aPgtos[nX][_TEFINTEG][2] } )
						aAdd( aSL4[Len(aSL4)], { "L4_HORATEF" 	, aPgtos[nX][_TEFINTEG][3] } )
						aAdd( aSL4[Len(aSL4)], { "L4_DOCTEF"	, aPgtos[nX][_TEFINTEG][4] } )
						aAdd( aSL4[Len(aSL4)], { "L4_AUTORIZ"	, aPgtos[nX][_TEFINTEG][5] } )
						aAdd( aSL4[Len(aSL4)], { "L4_DATCANC"	, aPgtos[nX][_TEFINTEG][6] } )
						aAdd( aSL4[Len(aSL4)], { "L4_HORCANC"	, aPgtos[nX][_TEFINTEG][7] } )
						aAdd( aSL4[Len(aSL4)], { "L4_DOCCANC"	, aPgtos[nX][_TEFINTEG][8] } )
						aAdd( aSL4[Len(aSL4)], { "L4_INSTITU"	, aPgtos[nX][_TEFINTEG][9] } )
						aAdd( aSL4[Len(aSL4)], { "L4_NSUTEF"	, aPgtos[nX][_TEFINTEG][10]} )
						aAdd( aSL4[Len(aSL4)], { "L4_PARCTEF"	, aPgtos[nX][_TEFINTEG][11]} )
					EndIf
					
					If Trim(aPgtos[nX][3]) == "CH"
						aAdd( aSL4[Len(aSL4)], { "L4_ADMINIS"	, aPgtos[nX][4][04] } ) 
						aAdd( aSL4[Len(aSL4)], { "L4_NUMCART"	, aPgtos[nX][4][07] } )
						aAdd( aSL4[Len(aSL4)], { "L4_AGENCIA"	, aPgtos[nX][4][05] } )
						aAdd( aSL4[Len(aSL4)], { "L4_CONTA"	, aPgtos[nX][4][06] } )
						aAdd( aSL4[Len(aSL4)], { "L4_RG"		, aPgtos[nX][4][09] } )
						aAdd( aSL4[Len(aSL4)], { "L4_TELEFON"	, aPgtos[nX][4][10] } )
						aAdd( aSL4[Len(aSL4)], { "L4_COMP"   	, aPgtos[nX][4][08] } )						
					EndIf					
				EndIf
			Next nX

			If nVlrEntrada > 0
				aAdd( aSL1, { "L1_ENTRADA" ,nVlrEntrada })
			EndIf

			nCont := 1
			DbSelectArea("SL4")
			DbSetOrder(1)
			DbSeek( xFilial("SL4") + SL1->L1_NUM)
			While !Eof() .AND. SL4->L4_FILIAL + SL4->L4_NUM == xFilial("SL4") + SL1->L1_NUM .AND. Empty(SL4->L4_ORIGEM)
				If nCont <= Len(aSL4)
			    	Lj7GeraSL( "SL4", aSL4[nCont] )
			 	Else
 					Begin Transaction

			 		RecLock("SL4",.F.)
			 		DbDelete()
			 		MsUnlock()

			 		End Transaction
			 	EndIf
		    	SL4->(DbSkip())
				nCont ++
			End
			For nX := nCont to Len(aSL4)
				Lj7GeraSL( "SL4", aSL4[nCont], .T. )
			Next nX
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Grava informações referentes ao Consumidor Final - Argentina.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cPaisLoc == "ARG" .AND. aDadosCF[7]
			aAdd( aMAD, { "MAD_FILIAL",xFilial("MAD") })
			aAdd( aMAD, { "MAD_CODEND",aDadosCF[5] })
			aAdd( aMAD, { "MAD_END"   ,aDadosCF[6] })
			Lj7GeraSL( "MAD", aMAD, .T., .T.)

			aAdd( aSLS, { "LS_FILIAL" ,xFilial("SLS") } )
			aAdd( aSLS, { "LS_SERIE"  ,cSerie } )
			aAdd( aSLS, { "LS_DOC"    ,cDoc } )
			aAdd( aSLS, { "LS_TIPO"   ,"N" } )
			aAdd( aSLS, { "LS_DOCCF"  ,aDadosCF[1] } )
			aAdd( aSLS, { "LS_TPDOCCF",aDadosCF[2] } )
			aAdd( aSLS, { "LS_TIPOCI" ,aDadosCF[3] } )
			aAdd( aSLS, { "LS_CLIECF" ,aDadosCF[4] } )
			aAdd( aSLS, { "LS_CODEND" ,aDadosCF[5] } )
			Lj7GeraSL( "SLS", aSLS, .T., .T.)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Baixa o Lay-Away - POR|EUA                                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (cPaisLoc$"EUA|POR" .OR. cPaisLoc$"MEX|COL")  .AND. lLayAway
           nPosLay       := Ascan(aPosCpoDet,{|x| AllTrim(x[1]) == "LR_NUMLAY"}) 	// Posicao do numero do Lay-Away
           nPosItLay     := Ascan(aPosCpoDet,{|x| x[1] == "LR_ITEMLAY"})	        // Posicao do item do Lay-Away
		   SL2->(DbSetOrder(1))
		   SL2->(DbGoto(nRecnoSL2))
		   For nX := 1 to Len(aCols)
	          If (aCols[nX][Len(aCols[nX])])
		         Loop
	          EndIf
			  If nPosLay > 0 .AND. nPosItLay > 0 .AND. !Empty(aColsDet[nX][nPosLay])
				 a800BxLay(aColsDet[nX][nPosLay],aColsDet[nX][nPosItLay],nX)
				 lCompensa  := .T.
				 If Ascan(aNumLay,PadR(aColsDet[nX][nPosLay],nTamE1_NUM)) == 0
				    Aadd(aNumLay,PadR(aColsDet[nX][nPosLay],nTamE1_NUM))
				 EndIf
				 nTotalItem  += aCols[nX][nPosVlItem]
			  EndIf
	          SL2->(DbSkip())
		   Next nX
		EndIf

        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Faz a troca automatica da serie do checkout de acordo com a tabela SL6.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		LjAltSerie( cEstacao, cDoc )

        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Confirmacao da transacao integrada ao SIGACRD                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If CrdxInt()
	   	   If !Empty(cContrato)


     		  Conout("36.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
	               " Contrato: " + If (Empty(cContrato), "", cContrato) +;
	               " Total : " + Str(Lj7T_Total(2)) +;
	      		   "  Chama a funcao AprovCrd " )

		      aRetCrd := AClone(Lj7AprovCRD( "2"   ,cContrato  ,Lj7T_Total(2)  ,@lConfCRD  ,;
		                                      NIL   ,NIL        ,NIL            ))
	          //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	          //³Se nao confirmar a transacao de credito, cancela                  ³
	          //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		      If !lConfCRD

		      	   Conout("37.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
	               " Contrato: " + If (Empty(cContrato), "", cContrato) +;
	      		   " Retorno de lConfCRD = Falso " )


		         DbSelectArea("MA7")
	             DbSetOrder(1)
	             If DbSeek(xFilial("MA7")+SL1->L1_CLIENTE+SL1->L1_LOJA) .AND. (!Empty(MA7->MA7_CONTRA) .OR. !Empty(cContrato))
	                If !Empty(MA7->MA7_CONTRA)
	                   cContrato  := MA7->MA7_CONTRA
	                EndIf

            	   Conout("38.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
	               " Contrato: " + If (Empty(cContrato), "", cContrato) +;
	      		   " chama a funcao LJ7AprovCRD param1=3 " )


		            aRetCrd    := AClone(Lj7AprovCRD( "3"   ,cContrato  ,Lj7T_Total(2)  ,NIL   ,;
		         								       NIL   ,NIL       ,NIL             ))
		            MsgAlert(STR0069 + CTRL + ;   //"Nao foi possivel confirmar a transacao de credito! "
		                     STR0070 + CTRL + ;   //"Favor reter o cupom e gerar uma Nota de Devolucao ou cancelar a venda atraves da rotina "
		                     STR0071)             //"de cancelamento de cupom(LOJA140)."
		         EndIf
		      Else
		         Conout("39.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
	               " Contrato: " + If (Empty(cContrato), "", cContrato) +;
	      		   " Transacao confirmada " )

		      EndIf

		   EndIf
	       //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	       //³Cancela o contrato caso nao seja associado a venda                ³
	       //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	       If Len(aContraTmp) > 0

 	    	  Conout("40.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
	               " Contrato: " + If (Empty(cContrato), "", cContrato) +;
	      		   " Chama a funcao CRDATUPEND " )


	          CrdAtuPend( "SL1"   ,10    ,aContraTmp,.F.    ,;
	                      .F.     )
	       else
  	    	  Conout("41.LOJA701C - Lj7GrvVenda - Orcamento: " +  M->LQ_NUM +;
	               " Contrato: " + If (Empty(cContrato), "", cContrato) +;
	      		   " aContraTmp <= 0 " )

	       EndIf
	       //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	       //³Inicializar aCrdCliente e cContrato apos gravacao da venda 	³
	       //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	       Lj7SetCRDClie(.T.)
		Else
    		Conout("42.LOJA701C - Lj7GrvVenda - Orcamento: " +;
    		If( Empty(M->LQ_NUM), "", M->LQ_NUM) + "  Sem Integracao com o CRD")
		EndIf
        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	    //³Atualiza o status do(s) Vale(s) Compra(s) caso o cliente tenha usado no pagamento³
	    //³Esta rotina funciona se o parametro para MV_LJUSAFD estiver habilitado           ³
      	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      	If lUsafd .AND. !Empty(aVales)
			If lUsafdOff

				oWSV := WSFRTCRDPSVPG():New()
				oWSV :_URL := "http://"+AllTrim(LJGetStation("WSSRV"))+"/FRTCRDPSVPG.apw"

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria o array dentro do metodo ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				oWSV:oWSVALES:oWSVERARRAY					:= FRTCRDPSVPG_ARRAYOFDADVALE():New()
				oWSV:oWSVALES:oWSVERARRAY:oWSDADVALE		:= Array( Len(aVales) )

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Antes de chamar o metodo, atribui os valores ³
				//³as propriedades (passagem de parametros)     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				For nX := 1 To Len(aVales)

 					oWSV:oWSVALES:oWSVERARRAY:oWSDADVALE[nX]   				:= FRTCRDPSVPG_DADVALE():NEW()

					oWSV:oWSVALES:oWSVERARRAY:oWSDADVALE[nX]:cCODVALE		:=	aVales[nX][1]
					oWSV:oWSVALES:oWSVERARRAY:oWSDADVALE[nX]:nVALOR	   		:=	aVales[nX][2]
					oWSV:oWSVALES:oWSVERARRAY:oWSDADVALE[nX]:dVALIDADE		:=	aVales[nX][3]
					oWSV:oWSVALES:oWSVERARRAY:oWSDADVALE[nX]:lRET			:=	aVales[nX][4]
				Next nX

				lRet := oWSV:CRDUPDMAV()

				If !lRet
					If !lAutoExC
						Aviso( STR0007, STR0073, {"OK"} ) //"Atencao" ### "Não foi possivel atualizar a pontuação do cliente."
					Else
						Conout( STR0007 + " - " + STR0073 ) //"Atencao" ### "Não foi possivel atualizar a pontuação do cliente."
					Endif
				EndIf

 	   		Else
		  		If !Crd240UpdMAV( aVales, "3" )
					If !lAutoExC
						Aviso( STR0007, STR0073, {"OK"} )//"Atencao" ### "Não foi possivel atualizar a pontuação do cliente."
					Else
						Conout( STR0007 + " - " + STR0073 )//"Atencao" ### "Não foi possivel atualizar a pontuação do cliente."
					Endif
				Else
					For nY := 1 To Len( aVales )
						CRDA270Log( aVales[nY], "3", cDoc, cPdv, cSerie )
					Next nY
				EndIf
			EndIf
		EndIf
		If nArredondar > 0
			If SL1->(ColumnPos("L1_VLRARR")) > 0
				aAdd( aSL1, { "L1_VLRARR", 	LjxDInsArrTax( nArredondar, aSL4 ) } )
			EndIf
	    EndIf
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Aqui podemos fazer um tratamento para cada erro encontrado. ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len( aRet ) > 2 .AND. !Empty( aRet[3] ) .AND. !lErroCF .AND. !lShowMsgEr
			MsgStop(aRet[3])
			lShowMsgEr := .T. // Informa que mensagem ja foi apresentada
		EndIf
		If lErroCF
			MsgStop(STR0173)	//"Houve problemas na impressão do Cupom Fiscal."
		EndIf

	EndIf
EndIf

If lErroCF
	LjGrvLog(SL1->L1_NUM,"ERRO NA IMPRESSAO DO CUPOM ")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Chama a funcao LjGrvTudo³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lRecebe .AND. aRet[1]

	For nX := 1 to Len( aCols )
		If !aCols[nX][Len( aCols[nX] )]
			nNumItens++
		EndIf
	Next nX
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Para inicializar as funcoes fiscais o tipo de documento deve³
	//³ser Nota e o numero de itens na venda tem que ser maior que ³
	//³o configurado para a quantidade de itens na nota.           ³
	//³Valore possiveis para Val(Left(SL1->L1_IMPRIME,1)):         ³
	//³1-Cupom Fiscal, 2-Nota Fiscal, 3-Recibo, 4-Nao Imprime      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Val(Left(SL1->L1_IMPRIME,1)) == 2 .AND. nNumItens > SuperGetMV( "MV_NUMITEN" ) .AND. MaFisFound()
		MaFisEnd( .T. )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Chama a funcao de gravacao do 'PACOTE'                                    ³
	//³ .T. = Mostrar as mensagens com MsgStop ou Help / .F. Mostrar com ConOut	  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	// Quando o Primeiro .T. = Mostrar as mensagens com MsgStop ou Help / .F. Mostrar com ConOut

	If !(lMVLJPDVPA)
		// Nao sendo PAF verifica se utiliza NCC no pagamento e/ou tem reserva de produto
		lProcBaixa := nNccUsada == 0 .OR. Len(aReservas) == 0
	EndIf

	//Condicao para gravar a venda gerando apenas SL1,Sl2 e SL4, sendo necessario utilizacao do GrvBatch
	// Se utiliza Venda Assistida On-Line, MV_LJGRVON = .F. e utiliza NCC e/ou reserva de produto a venda por padrao sera gravada on-line
	// 
	If !lEmiteNF .AND. ;
	( 	(!lMVLJGRVON .AND. lProcBaixa) .OR. ;
		lMVLJPDVPA .OR. ;
		((lEmitNFCe .Or. lIsPafNfce) .AND. !lMVLJGRVON) .OR. ;
		(lAutoExec .AND. !lAutomato .AND. LjNfGrvAuto(SM0->M0_CGC));
	)

		aAreaJob := GetArea()

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza os dados da SL1³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Lj7GeraSL( "SL1", aSL1, .F., .F. )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Faz a gravacao do SL2                                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SL2")
		SL2->(DbSetOrder(1))

		//PAF-ECF: Para o PAF-ECF, considera os registros deletados que possuem MD5
		If lNfPafEcf
			SET DELETED OFF
		EndIf

		SL2->(MsSeek(xFilial("SL2") + SL1->L1_NUM))
		nRecnoSL2  := SL2->(Recno())

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Valor para dar baixa no Lay-Away  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nOutros    := SL1->L1_OUTROS
		While !SL2->(EOF()) .AND. SL2->L2_FILIAL + SL2->L2_NUM == xFilial("SL2") + SL1->L1_NUM

			//Verifica se registro deletado será considerado
			If lNfPafEcf
				lUsaRegL2 := !SL2->(Deleted()) .OR. ( SL2->(Deleted()) .AND. !Empty(SL2->L2_PAFMD5) )
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualiza os dados da SL2³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		    If lUsaRegL2

				If lNfPafEcf
					cVendido := IIF(SL2->(Deleted()),"N","S")

					nPos 	:= aScan( aSL2, {|x| Alltrim( Upper( x[1] ) ) == "L2_VENDIDO" } )
					If nPos == 0
						aAdd( aSL2, { "L2_VENDIDO", cVendido } )
					Else
						aSL2[nPos][2] := cVendido
					EndIf
				EndIf

				Lj7GeraSL( "SL2", aSL2 )
			EndIf

			If !SL2->(Deleted())
				// Efetua a gravação da venda do Vale Presente
		   		If SL2->( ColumnPos("L2_VALEPRE") ) > 0 .AND. !Empty( SL2->L2_VALEPRE )
					LjGrVVlPre(	SL2->L2_VALEPRE	, SL1->L1_VEND  , SL2->L2_DOC , SL1->L1_ESTACAO,;
						   		SL2->L2_PDV		, SL1->L1_EMISNF, SL1->L1_HORA, SL1->L1_CLIENTE,;
								SL1->L1_LOJA, SL2->L2_SERIE )
				EndIf
			EndIf
			DbSelectArea("SL2")
			DbSkip()
		End

		//PAF-ECF: Para o PAF-ECF, desconsidera os registros deletados
		If lNfPafEcf
			SET DELETED ON
		EndIf

		RestArea(aAreaJob)

		lVendaCup := .T.
   		lRet := .T.

		If !lEmiteNf
			If (lEmitNFCe .Or. lIsPafNfce) .And. !lMVLJGRVON .AND. !lOnlyServ .AND. !lIsVendaVP .AND. !lUseSat .And. !lIntegDef
				lErroNFCe := !Lj701CNFCe( 	SL1->L1_FILIAL	, SL1->L1_NUM	, SL1->L1_DOC	, SL1->L1_SERIE ,;
											cPDV			, lTefOk		, @cKeyNFCe		, @cDescErro	)
				cMsgErro := cDescErro	//Atribuo a mensagem de erro da transmissão da NFC-e
				If lErroNFCe
					lRet := .F.
					aRet[1] := lRet
				Else
					//Atualiza o campo L1_HORA e L1_EMISSNF
						
					If (npos := aScan( aSL1,{ |x| x[1] == "L1_HORA"} ) ) > 0
						aSL1[npos][2] := SL1->L1_HORA
					EndIf
					
						
					If (npos := aScan( aSL1,{ |x| x[1] == "L1_EMISNF"} ) ) > 0
						aSL1[npos][2] := SL1->L1_EMISNF
					EndIf	

				EndIf

			ElseIf lUseSat .And. !lOnlyServ .AND. !lIsVendaVP
				cXML := LjSATXml() // Gera XML

				LjGrvLog( SL1->L1_NUM, "SAT - Gerado XML ")

				If At("<det",cXML) <> 0

					If SuperGetMv("MV_VERSAT",,'0.06') >= '0.08'
						MsgAlert("Versão 0.08 ainda não homologada - Vigência 01/01/2017")
						aRetSAT := {}
					Else
						aRetSAT := LJSATComando({"12","EnviarDadosVenda",LJSATnSessao(),cPass,cXML})
					EndIf

					If Len(aRetSAT) > 1 .And. Val(aRetSAT[2]) == 6000 //retorno de sucesso

						If ExistFunc("LJSATRetDoc")
							aSATDoc := LJSATRetDoc(Decode64(aRetSAT[5]))  //retorna o doc e serie gerado no SAT

							cDoc := cDocSat	:= aSATDoc[1] 
							cSerieSat			:= aSATDoc[2]

							aSatSL1 :=	{	{ "L1_DOC"		, cDoc 		},;
											{ "L1_SERIE"	, cSerie 		},;
											{ "L1_ESPECIE", "SATCE"		},;
											{ "L1_SERSAT"	, cSerieSat	},;
											{ "L1_KEYNFCE", SubStr(aRetSAT[7],4,Len(aRetSAT[7])) } }

							Lj7GeraSL("SL1", aSatSL1, .F.)
							aSatSL1 := {}

							LjGrvLog( SL1->L1_NUM, "SAT - Numeração do Doc e Serie do SAT", aSATDoc )

						EndIf

						LjGrvLog( SL1->L1_NUM, "SAT - Venda com sucesso " )

						If !lMVLJGRVON .AND. nNccUsada > 0

							//Gera nova NCC para o cliente, caso seja necessario

							LjGrvLog(SL1->L1_NUM,"Vai realizar a baixa das NCCs",aNCCItens)

							lRetNCC := StaticCall( WSFRTNCC	, FrtIncluiNCC		,;
							aNCCItens		, 	nNccUsada		, nNccGerada		, SL1->L1_DOC		,;
							SL1->L1_SERIE	,	SL1->L1_OPERADO	, SL1->L1_EMISSAO	, SL1->L1_CLIENTE	,;
							SL1->L1_LOJA	)

							LjGrvLog(SL1->L1_NUM,"Retorno se incluiu NCC",nNccGerada)

							If lRetNCC
								//Inclui tipo CR para as NCCs usadas na venda
								lRetNCC := StaticCall( WSFRTNCC		, FrtIncluiCR		,;
													SL1->L1_SERIE	, @cDocCred			, @nRecnoSE1	, SL1->L1_DOC		,;
													SL1->L1_SERIE	, SL1->L1_CLIENTE	, SL1->L1_LOJA	, SL1->L1_CREDITO	,;
													SL1->L1_OPERADO	, nNccUsada			, nNccGerada   	, aNccItens			)

									LjGrvLog(SL1->L1_NUM,"Retorno se incluiu o CR",nNccGerada)

									//Efetua a compensacao
									If lRetNCC
										
										StaticCall(	LOJXFUNC , LjInMovNCC	,;
													aNccItens, nMsDecimal	, cDocCred , nRecnoSE1	,;
													nNccUsada, nNccGerada	, SL1->L1_NUM )

										LjGrvLog(SL1->L1_NUM,"Retorno se conseguiu baixar a NCC")
									Else
										MsgStop(STR0193) //"Não foi possível realizar a inclusão do título do tipo CR referente a NCC"
									EndIf
							Else
								MsgStop(STR0194) //"Não foi possível realizar a inclusão da Nota de Crédito"
							EndIf
						
						EndIf

						LojSATImprimir(Decode64(aRetSAT[5]), cXML, cSerie, @cDocSat, @cSerieSat) //impressao do cupom

						If lValeTroca
							L701DCVTImp(Nil,cSerie,.t.) // IMPRESSAO VALE TROCA
						EndIf	
						
						cDoc := cDocSat

						aSatSL1 := {;
										 {"L1_DOC"	, cDoc	 },;
										 {"L1_SERIE", cSerie },;
										 {"L1_HORA"	, Time()},;
										 {"L1_KEYNFCE" , SubStr(aRetSAT[7],4,Len(aRetSAT[7]))	},;
										 {"L1_SERSAT" , cSerieSat	},;
									 	 {"L1_ESPECIE" , "SATCE"	};
									 }

						LjGrvLog( SL1->L1_NUM, "L1_DOC ", cDoc )
						npos := ASCAN( aSL1,{ |x| x[1] == "L1_DOC"} )
						aSL1[npos][2] := cDoc

						Lj7GeraSL("SL1", aSatSL1, .F.)

						DbSelectArea("SL2")
						If DbSeek(xFilial("SL2")+SL1->L1_NUM)
							While SL2->L2_FILIAL+SL2->L2_NUM == xFilial("SL2")+SL1->L1_NUM .AND. !SL2->(EOF())
	       						//Caso referencia ao campo ja se encontre no array aSL2, utilizo a posição encontrada
	       						If (nPos := Ascan( aSL2,{ |x| Alltrim(Upper(x[1])) == "L2_DOC"})) > 0
					        		aSL2[nPos][2] := cDoc
					       		Else
					        		aAdd(aSL2, { "L2_DOC" , cDoc })
					       		EndIf

		       					Lj7GeraSL( "SL2", aSL2, .F. )
		       					SL2->(DbSkip())
							EndDo
						EndIf

						lErroNFCe := .F.						

					Else
						lRet := .F.
						aRet[1] := lRet
						lErroNFCe := .T.

						
						//Em caso de erro na venda, retorno os dados da venda que foram gravados
						aSatSL1 := {;
										 {"L1_DOC"	, "" },;
										 {"L1_PDV"	, "" },;
										 {"L1_SERIE", "" },;
										 {"L1_TIPO",""},;
										 {"L1_NUMCFIS",""},;
										 {"L1_IMPRIME","1N"},;
										 {"L1_HORA",""},;
										 {"L1_KEYNFCE", ""	},;
										 {"L1_SERSAT" , ""	},;
									 	 {"L1_ESPECIE", ""	},;
									 	 {"L1_SITUA",""};									 	 
									 }
						
						aSL1[ASCAN( aSL1,{ |x| x[1] == "L1_DOC"} )][2] := ""

						Lj7GeraSL("SL1", aSatSL1, .F.)						

						//O tratamento para gravar a MH2 foi incluido dentro da função de envio do SAT
						//Desta forma este trecho deve ser retirado para nao chamar novamten a gravação do MH2
						//<Retirar depois de um tempo>
						If ExistFunc("LjGrvLogSAT") .And. !ExistFunc("SATValidCanc")
						    //Log SAT
							LjGrvLogSAT(;
										cSerie,;
										/*numero da venda*/,;
										/*chave da venda*/,;
										cXML,;
										/*xml retorno*/,;
										"VENDA",;
										"ERRO",;
										IIf( Len(aRetSAT) > 1 , aRetSAT[2], STR0210 ) + "-" + IIf( Len(aRetSAT) > 3 , DecodeUTF8(EncodeUTF8(aRetSAT[4])), STR0210); //"Erro inesperado"
										)
						EndIf

						If ExistFunc("LjGrvLog")
							LjGrvLog( SL1->L1_NUM, "SAT - Erro ",;
								IIf( Len(aRetSAT) > 1 , aRetSAT[2], STR0210) + "-" + IIf( Len(aRetSAT) > 3 , DecodeUTF8(EncodeUTF8(aRetSAT[4])), STR0210) ) //"Erro inesperado"
						EndIf

						/*
	        			aRet[2] - Codigo
	        			aRet[4] - Descrição
	        			*/
						//Não foi colocado em STFMESSAGE porque a mensagem pode ser grande e não será exibida por completo
						MsgAlert(cSiglaSat + " - Venda não realizada: "  + ;
						IIf( Len(aRetSAT) > 1 , aRetSAT[2], STR0210) + "-" + IIf( Len(aRetSAT) > 3 , DecodeUTF8(EncodeUTF8(aRetSAT[4])), STR0210) ) // Código de erro retornado pelo SAT #"Erro inesperado"
					EndIf
				EndIf

			EndIf
		EndIf

	    //Efetua a baixa NCC via WebService
	    If lMVLJPDVPA .AND. nNccUsada <> 0
			Lj7BxNccWS()
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³CRIACAO DE  NCC COM OS VALORES DOS DESCONTOS CONCEDIDOS³
		//³     PELO CENARIO DE VENDAS ATIVO/REGRAS DE DESCONTO.  ³
		//³				SOMENTE COM RELEASE 11.5 ATIVO			  ³
		//| 			  	PAF-ECF (SIGALOJA)			  		  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lCenVenda .AND. ExistFunc("LJSelIncTit")
			aDescNcc := LJGETCVAR()
  			If Len(aDescNcc) > 0
  				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³		EXECULTA FUNCAO LJSelIncTit QUE GERA TITULO		 ³
				//³		E VERIFICA SE EXECULTA VIA WEBSERVICE.           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				LJSelIncTit(aDescNcc,"SL1")
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Release 11.5 - Cartao Fidelidade  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lLjcFid .AND. lMVLJPDVPA .AND. lProcFidWs

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Grava recarga/inclusao de saldo em cartao fidelidade neste³
			//³ponto da venda quando for identificada que a gravacao sera³
			//³via Webservice. 											 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lRecFid
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Inclusão do saldo do cartao fidelidade - Recarga³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If	!Empty(cNumFid) .AND. !Empty(dDataFid) .AND. (nValRecFid > 0)
					Ca280Exec("CA280ISLD",cNumFid,dDataFid,nValRecFid,cDoc,cSerie,cLojaFid)
				EndIf
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualizacao do saldo do cartao fidelidade - Venda³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If	!Empty(cNumFid) .AND. (nValFid > 0)
					Ca280Exec("Ca280ASld",cNumFid,,,cDoc,cSerie,cLojaFid,,nValFid)
				Endif
			Endif

		EndIf
	Else

		If ExistBlock("FTVDGRT") .AND. lFtvdVer12
			ExecBlock( "FTVDGRT", .F., .F. )
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Release 11.5 - Controle de Formularios                 							              ³
		//³Novos parametros:																	          ³
		//³cDocFo - Nro do formulario informado pelo usuario no incio da venda (Controle de Formulario)   ³
		//³aBreakNota - Notas geradas a partir da venda quando o numero de itens de venda exceder o limite³
		//³Paises:Chile/Colombia - F1CHI		 					 						              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If !lEmiteNf .AND. (lEmitNFCe .Or. lIsPafNfce) .And. lMVLJGRVON .And. !lOnlyServ .AND. !lUseSAT .AND. !lIsVendaVP .And. !lIntegDef
			//Altera o registro pai para transmissão da NFC-e
			aNFCeSL1 := {	{"L1_DOC"	, cDoc	 },;
						 	{"L1_SERIE"	, cSerie },;
						 	{"L1_HORA"	, Time() } }

			Lj7GeraSL("SL1", aNFCeSL1, .F.)

			lErroNFCe := !Lj701CNFCe( 	SL1->L1_FILIAL	, SL1->L1_NUM	, SL1->L1_DOC	, SL1->L1_SERIE	,;
										cPDV			, lTefOk		, @cKeyNFCe		, @cDescErro	)
			cMsgErro := cDescErro	//Atribuo a mensagem de erro da transmissão da NFC-e
			If lErroNFCe
				lRet := .F.
				aRet[1] := lRet
			Else
				//Atualiza o campo L1_HORA e L1_EMISSNF
					
				If (npos := aScan( aSL1,{ |x| x[1] == "L1_HORA"} ) ) > 0
					aSL1[npos][2] := SL1->L1_HORA
				EndIf
				
					
				If (npos := aScan( aSL1,{ |x| x[1] == "L1_EMISNF"} ) ) > 0
					aSL1[npos][2] := SL1->L1_EMISNF
				EndIf				
				
			EndIf

			If lValeTroca
				L701DCVTImp(Nil,cDocSat,.T.) // IMPRESSAO VALE TROCA
			EndIf		

		ElseIf	 lUseSat .And. !lEmiteNf .And. !lOnlyServ
			cXML := LjSATXml()  // Gera XML

			LjGrvLog( SL1->L1_NUM, "SAT - Gerado XML ")
			If At("<det",cXML) <> 0

				Lj7GeraSL("SL1", {{"L1_SERIE", cSerie }}, .F.)

				If SuperGetMv("MV_VERSAT",,'0.06') >= '0.08'
					MsgAlert("Versão 0.08 ainda não homologada - Vigência 01/01/2017")
					aRetSAT := {}
				Else
					aRetSAT := LJSATComando({"12","EnviarDadosVenda",LJSATnSessao(),cPass,cXML})
				EndIf

				If Len(aRetSAT) > 1 .And. Val(aRetSAT[2]) == 6000 //retorno de sucesso

					If ExistFunc("LJSATRetDoc")
						aSATDoc := LJSATRetDoc(Decode64(aRetSAT[5]))  //retorna o doc e serie gerado no SAT

						cDoc := cDocSat	:= aSATDoc[1] 
						cSerieSat			:= aSATDoc[2]

						aSatSL1 :=	{	{ "L1_DOC"		, cDoc 		},;
										{ "L1_SERIE"	, cSerie 		},;
										{ "L1_ESPECIE", "SATCE"		},;
										{ "L1_SERSAT"	, cSerieSat	},;
										{ "L1_KEYNFCE", SubStr(aRetSAT[7],4,Len(aRetSAT[7])) },;
										{ "L1_SITUA"	, "T3"			} } //Consumiu o numero de DOC e Serie

						Lj7GeraSL("SL1", aSatSL1, .F.)
						aSatSL1 := {}

						LjGrvLog( SL1->L1_NUM, "SAT - Numeração do Doc e Serie do SAT", aSATDoc )

					EndIf

					LjGrvLog( SL1->L1_NUM, "SAT - Venda com sucesso " )

					LojSATImprimir(Decode64(aRetSAT[5]), cXML, cSerie, @cDocSat, @cSerieSat) //impressao do cupom

					If lValeTroca
						L701DCVTImp(Nil,cDocSat,.T.) // IMPRESSAO VALE TROCA
					EndIf	
			
					cDoc := cDocSat

					aSatSL1 := {;
									 {"L1_DOC"	, cDoc	 },;
									 {"L1_SERIE", cSerie },;
									 {"L1_HORA"	, Time()},;
									 {"L1_KEYNFCE" , SubStr(aRetSAT[7],4,Len(aRetSAT[7]))	},;
									 {"L1_SERSAT" , cSerieSat	},;
									 {"L1_ESPECIE" , "SATCE"	};
								 }

					LjGrvLog( SL1->L1_NUM, "L1_DOC ", cDoc )
					npos := ASCAN( aSL1,{ |x| x[1] == "L1_DOC"} )
					aSL1[npos][2] := cDoc

					Lj7GeraSL("SL1", aSatSL1, .F.)

					DbSelectArea("SL2")
					If DbSeek(xFilial("SL2")+SL1->L1_NUM)
						While SL2->L2_FILIAL+SL2->L2_NUM == xFilial("SL2")+SL1->L1_NUM .AND. !SL2->(EOF())
       						//Caso referencia ao campo ja se encontre no array aSL2, utilizo a posição encontrada
       						If (nPos := Ascan( aSL2,{ |x| Alltrim(Upper(x[1])) == "L2_DOC"})) > 0
				        		aSL2[nPos][2] := cDoc
				       		Else
				        		aAdd(aSL2, { "L2_DOC" , cDoc })
				       		EndIf

	       					Lj7GeraSL( "SL2", aSL2, .F. )
	       					SL2->(DbSkip())
						EndDo
					EndIf

				Else
					lRet := .F.
					aRet[1] := lRet
					lErroNFCe := .T.

					//O tratamento para gravar a MH2 foi incluido dentro da função de envio do SAT
					//Desta forma este trecho deve ser retirado para nao chamar novamten a gravação do MH2
					//Retirar depois de um tempo
					If ExistFunc("LjGrvLogSAT") .And. !ExistFunc("SATValidCanc")
						//Log SAT
						LjGrvLogSAT(;
							cSerie,;
							/*numero da venda*/,;
							/*chave da venda*/,;
						 	cXML,;
						 	/*xml retorno*/,;
						 	"VENDA",;
						 	"ERRO",;
						 	IIf( Len(aRetSAT) > 1 , aRetSAT[2], STR0210) + "-" + IIf( Len(aRetSAT) > 3 , cValToChar(DecodeUTF8(EncodeUTF8(aRetSAT[4]))), STR0210)) //"Erro inesperado."
					EndIf

					If ExistFunc("LjGrvLog")
						LjGrvLog( SL1->L1_NUM, "SAT - Erro ",;
							IIf( Len(aRetSAT) > 1 , aRetSAT[2], STR0210) + "-" + IIf( Len(aRetSAT) > 3 , DecodeUTF8(EncodeUTF8(aRetSAT[4])),STR0210 ) ) //"Erro inesperado."
					EndIf

	            /*
	            	aRet[2] - Codigo
	            	aRet[4] - Descrição
	            */
	            //Não foi colocado em STFMESSAGE porque a mensagem pode ser grande e não será exibida por completo
	            MsgAlert(cSiglaSat + " - Venda não realizada: "  + ;
       		 IIf( Len(aRetSAT) > 1 , aRetSAT[2], STR0210) + "-" + IIf( Len(aRetSAT) > 3 , DecodeUTF8(EncodeUTF8(aRetSAT[4])), STR0210) ) // Código de erro retornado pelo SAT # "Erro inesperado"

				EndIf

			EndIf
		ElseIf lEmiteNF .AND.lGE
			If ExistFunc("LjNFCeGE")
				LjNFCeGE(3)

				//resetamos as variaveis estaticas do fonte LOJXFUNG.PRW apos a impressão do termo
				LjxSetRGer()
				LjxSetRGar()
			Endif 
		EndIf

		If !lErroNFCe
			If !lAutoExC
				LjGrvLog(SL1->L1_NUM,"CHAMADA DA GRAVACAO DA NOTA")

				lRet := LjGrvTudo( 	.T.       	,lFinanceiro	,nNCCUsada  ,aNCCItens  ,;
             					  	nNCCGerada 	,aImpCheque		,nMoedaCor  ,@aRecnoSE1 ,;
				                   	aVlrAcres  	,aSL1	        ,aSL2		, cDoc		,;
			    	               	@lVendaCup 	,nNumItens		,nFrete		,nSeguro	,;
									nDespesa  	,cLQFrete		,aAcrFin	,NIL		,;
									cCgcCli   	,cNomeCli		,lNfManual	,@lExistNF  ,;
									@cDescErro  ,@cEspecNf		,cDocFo		,@aBreakNota,;
									@aNewNCC	,cTpGeraGdp		,nOpc		,nArredondar,;
									@lErroNFe 	,Len(aNSUVndTef) > 0)

				LjGrvLog(SL1->L1_NUM,"RETORNO DA GRAVACAO DA NOTA",lRet)

				If lErroNFe
					lRet := .F.
					aRet[1] := lRet
				EndIf
			Else

				lRet := LjGrvTudo( 	.T.       	,lFinanceiro	,nNCCUsada  ,aNCCItens  ,;
				                   	nNCCGerada 	,aImpCheque		,nMoedaCor  ,@aRecnoSE1 ,;
				                   	aVlrAcres  	,aSL1	        ,aSL2		, cDoc		,;
		    		               	@lVendaCup 	,nNumItens		,nFrete		,nSeguro	,;
									nDespesa  	,cLQFrete		,aAcrFin	,NIL		,;
									cCgcCli   	,cNomeCli		,lNfManual	,@lExistNF  ,;
									@cDescErro  ,@cEspecNf		,cDocFo		,@aBreakNota,;
									@aNewNCC	,cTpGeraGdp		,nOpc		,nArredondar)
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ponto de Entrada utilizado para impressão da NCC com o valor do saldo restante   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Substr(SuperGetMV("MV_USACRED"),1,1) == "S"
			If lLojR860A
				ExecBlock('LOJR860A',.F.,.F.,{ aNewNCC, aNCCItens , (nNCCUsada - nNCCGerada) })
			Endif
		Endif

	EndIf

	//Nota - A numeracao da Nota/Serie eh atribuida pela funcao LJGRVTUDO(), atualiza variaveis
	If lFtvdVer12 .Or. (!lFtvdVer12 .AND. ( (!lEmitNFCe .And. !lIsPafNfce) .Or. ( (lEmitNFCe .Or. lIsPafNfce) .And. lEmiteNF)))
		cSerie	:= SL1->L1_SERIE
		cDoc 	:= SL1->L1_DOC
		cPdv 	:= SL1->L1_PDV
	EndIf

	cEspecie := cEspecNf

	Lj7GrvMotDesc(cSerie , cDoc , IIf( lMVLJPDVPA .AND. (SL1->( ColumnPos( "L1_NUMORIG" ) ) > 0) , SL1->L1_NUMORIG , ""), "")  // (cSerie,cDoc,cNumOrc,cTipo)

	If nOpc == 4
		Lj7PesqAltMot( cSerie , cDoc , SL1->L1_NUM )
	EndIf


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Tendo Integracao com o TMK atualiza os campos da tabela SUA³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cMvTmkLoj == "S"
		If SL1->(ColumnPos("L1_NUMATEN"))>0
			DbSelectArea("SUA")
			SUA->(DbSetOrder(1))
			If SUA->(DbSeek(xFilial("SUA")+SL1->L1_NUMATEN))
				RecLock("SUA",.F.)
				REPLACE UA_OPER 	WITH "1"
				REPLACE UA_DOC  	WITH cDoc
				If !lFtvdVer12
					REPLACE UA_STATUS   WITH "NF"
				ElseIf lFtvdVer12
					REPLACE UA_STATUS   WITH "NF."
				EndIf
				REPLACE UA_SERIE  	WITH cSerie
				REPLACE UA_EMISNF 	WITH dDatabase
				REPLACE UA_VEND		WITH SL1->L1_VEND
				SUA->(MsUnlock())
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Encerra o atendimento na lista de contatos.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SU4")
			SU4->(dbSetOrder(4))	//U4_FILIAL+U4_CODLIG
			If SU4->(dbSeek(xFilial("SU4")+SL1->L1_NUMATEN)) .And. SU4->U4_STATUS <> "2"
				RecLock("SU4",.F.)
				REPLACE SU4->U4_STATUS WITH "2"	//Status de encerrado
				SU4->(MsUnlock())
			EndIf
		EndIf
	EndIf

	If !lVendaCup
		//"A emissão da Nota Fiscal foi cancelada. Será gerado um orçamento para ser finalizado posteriormente.","Emissão de Nota Fiscal Cancelada"
		MsgAlert(STR0083,STR0084)
		/*Tratamento para gravar os campos
		com os valores que tinham antes de
		passar pela função RecTrib ()  */
		
		DbSelectArea("SL2")
		DbSetOrder(1)
		DbSeek(xFilial("SL2") + cSeqTrans)
		While !Eof() .AND. xFilial("SL2") + cSeqTrans == SL2->L2_FILIAL + SL2->L2_NUM
			RecLock("SL2", .F.)
			If nMvLjTpDes <> 2
				REPLACE L2_VRUNIT  WITH L2_PRCTAB - Round((L2_VALDESC /	 L2_QUANT),MsDecimais(nMoedaCor))
			Else
				REPLACE L2_VRUNIT  WITH A410Arred(L2_PRCTAB - (L2_PRCTAB *(L2_DESC /100))  ,"LR_VLRITEM")
			EndIf
			REPLACE L2_VLRITEM WITH L2_VRUNIT * L2_QUANT
			REPLACE L2_VALPS2  WITH 0
			REPLACE L2_VALCF2  WITH 0
			REPLACE L2_BASEPS2 WITH 0
			REPLACE L2_BASECF2 WITH 0
			REPLACE L2_DESCPRO WITH 0
			REPLACE L2_VALFRE  WITH 0
			REPLACE L2_SEGURO  WITH 0
			REPLACE L2_DESPESA WITH 0
			MsUnLock()
			DbSkip()
		End
		Return .T.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se a Gravacao da venda nao foi executada com sucesso  ³
	//³o cupom fiscal deve ser cancelado e caso exista alguma³
	//³transaçao tef deve ser desfeita                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lRet
		LjGrvLog(SL1->L1_NUM,"PROBLEMA COM A GRAVACAO DA VENDA")
		If (lEmitNfce .Or. lIsPafNfce) .AND. !lEmiteNF
			cCancMsg := STR0174 //"Houve problemas na emissão da NFC-e"
		Else
			cCancMsg := STR0082 //"Erro na Gravação da Venda!"
		Endif
		Lj7CancVenda(	cCancMsg	, cDoc		, cSerie	, cPdv			,;
						.F.			, lTefOk	, @lExistNF	, @cDescErro	,;
						.T. 		,  Nil		, Nil		, @aTefBKP		,;
						@lTemTEFPend	)

		//Quando NFC-e, necessário finalizar a venda para cancelamento no TSS
		If !lEmitNFCe .And. !lIsPafNfce
			Return .F.
		EndIf
	EndIf

    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Grava movimento de venda perdida durante a finalizacao da venda ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lMVLJPDVPA .AND. !Empty(cDoc) .AND. !Empty(cSerie) .AND. lVendaPerdida .AND. ExistFunc("LA701GetVp")
		oMoviVp 	:= LA701GetVp() //OBTER OBJETO DE MOVIMENTO DE VENDA PERDIDA, ATIVO NO LOJA701
		If oMoviVp	<> NIL
			LA701GrvVp (oMoviVp,SL1->L1_NUMORC,cDoc,cSerie)
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Faz a gravacao do Log depois de ter gravado todas as tabelas referentes³
	//³a venda (SL1, SL2, SL4), para que nao haja perda dos dados da gravacao ³
	//³do SL4 com relacao ao TEF. BOPS: 86536                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lLog1 .AND. lLog4 .AND. nHandle >= 0
		nSize 		:= FSeek( nHandle, 0, 2 )
		cRBuffer 	:= Space( nSize )

		FSeek( nHandle, 0, 0 )
		FRead( nHandle, @cRBuffer, nSize )

		cRBuffer := Encript( cRBuffer, 1 )
		If !("#DADOSOK#" $ cRBuffer)
			cRBuffer := cRBuffer + "#DADOSOK#"
		EndIf

		FSeek( nHandle, 0, 0 )
		FWrite( nHandle, Encript( cRBuffer, 0 ) )

		LjGrLogT(	SL1->L1_NUM			, cNumCupom			, xNumCaixa()		, aTefDados			,;
					SL1->L1_DINHEIRO	, SL1->L1_CHEQUES	, SL1->L1_CARTAO	, SL1->L1_VLRDEBI	,;
					SL1->L1_CONVENI		, SL1->L1_VALES		, SL1->L1_FINANC	, SL1->L1_OUTROS	,;
					SL1->L1_DESCONT		, SL1->L1_DESCNF	, cNumPdv			, cSerie )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Nota fiscal eletronica Mexico             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If AliasIndic("MDL") .AND. cPaisLoc == "MEX"
		DBSelectArea("SF2")
		DBSetOrder(1)
		If DBSeek(XFilial("SF2") + SL1->L1_DOC + SL1->L1_SERIE + SL1->L1_CLIENTE + SL1->L1_LOJA)
			While lGrvPCFD
				LOJXGERCFD(lFiscal , lPergGrCFD , @aMsgCert)
				If !Empty(SF2->F2_NEXTDOC)

					If DBSeek(SF2->F2_FILIAL + SF2->F2_NEXTDOC + SF2->F2_SERIE + SF2->F2_CLIENTE + SF2->F2_LOJA)
						lGrvPCFD	:= .T.
						lPergGrCFD	:= .F.
					Else
						lGrvPCFD	:= .F.
					EndIf
				Else
					lGrvPCFD	:= .F.
				EndiF
			End
		LJXListFol(aMsgCert)
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Chama rotina para impressão da Nota Fiscal³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Quando estiver usando o usuario manual (28) significa que não deve imprimir factura...³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( lRet .AND. lEmiteNF ) .OR.  (lRet .AND.  ExistFunc("LjxBGetNf") .AND. LjxBGetNf()) .OR.  ;
		( lRet .AND. cPaisLoc <> "BRA" .AND. !lFiscal .AND. !LjProfile(28) .AND. (lAutoExC .OR. (!lAutoExC .AND. ;
		IIf(	cPaisLoc $ "MEX|PER" , ;
		 		IIf(cMV_LJIMPFA == "1", MsgYesNo(STR0041), IIf(cMV_LJIMPFA == "2", .T., .F.)) , ;
		 		MsgYesNo(STR0041) ) ) ) )						// "Deseja realizar a impressão da fatura de venda?"

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Monta array com informacoes para impressao nos detalhes da NF³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aDadosTefNf := {}

		If lTefOk .And. cTipTef == TEF_CLISITEF

			For nX := 1 to Len(oTef:aRetCartao)

				aAdd( aDadosTefNf , Array(7))

				aDadosTefNf[nX][1] := StoD(oTef:cData)				   	//"L4_DATATEF"
				aDadosTefNf[nX][2] := oTef:aRetCartao[nX]:cHoraTrans	//"L4_HORATEF"
				aDadosTefNf[nX][3] := oTef:aRetCartao[nX]:cNsuAutor	//"L4_DOCTEF"
				aDadosTefNf[nX][4] := oTef:aRetCartao[nX]:cAutoriza	//"L4_AUTORIZ"
				aDadosTefNf[nX][5] := oTef:aRetCartao[nX]:cDescAdm		//"L4_INSTITU"
				aDadosTefNf[nX][6] := oTef:aRetCartao[nX]:cNsuSitef	//"L4_NSUTEF"
				aDadosTefNf[nX][7] := oTef:aRetCartao[nX]:cTipCart		//"L4_TIPCART"

			Next nX

		EndIf

      	// Verifica se a especie do documento eh SPED
      	If AModNot(cEspecie)$"55,57" .Or. AllTrim(cEspecie) == "RPS" //RPS (Recibo Provisorio de Servico)
      		lSped := .T.
      	EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Monta array com informacoes para impressao nos detalhes da NF³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (ExistFunc("LjNfVldImp") .AND. LjNfVldImp()) .Or. LjNfUsaTef(SM0->M0_CGC) .Or. (lEmiteNF .And. (lEmitNFce .Or. lIsPafNfce)) //Chamada da funcao LjNfUsaTef() aqui exclusivamente p/ o cliente DALLAS RENT A CAR, p/ entrar neste IF e nao executar a impressao da Nota atraves da funcao LojR110
			LjMsgRun(STR0074,,{|| ExecBlock(GetMV("MV_SCRNOTA"),.F.,.F.,{SL1->L1_DOC,SL1->L1_SERIE,{},aDadosTefNf })}) //"Aguarde ... imprimindo nota fiscal..."
		ElseIf !(lSped) 	// nao executa quando for Nota Fiscal Eletronica
			If 	(cPaisLoc $ "CHI|COL" .OR. ( INFLocaliz() .AND. ExistFunc("LjxBGetNf") .AND. LjxBGetNf())) .AND. !LjProfile(28) .AND. !lJob
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Release 11.5 - Controle de Formularios e comprovante- F2CHI 			³
				//³Impresssao Localizada: Comprovante / Factura							³
				//³Paises:Chile/Colombia/Australia										³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				lImpNF := Lj7ImpLoc (aBreakNota,NIL,nOpc,.F.)
			ELseIf cPaisLoc == 'PER' //RESOLUCION DE SUPERINTENDENCIA Nº 007-99-SUNAT
				LjMsgRun(STR0074,,{|| ExecBlock(GetMV("MV_SCRNOTA"),.F.,.F.,{SL1->L1_DOC,SL1->L1_SERIE,{},aDadosTefNf })}) //"Aguarde ... imprimindo nota fiscal..."
			ElseIf !LjProfile(28)
				LjMsgRun(STR0074,,{|| lImpNF := LojR110( SL1->L1_DOC, SL1->L1_SERIE, aDadosTefNf ) } )	 	//"Aguarde ... imprimindo nota fiscal..."
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cancela a transacao TEF se a nota fiscal nao for impressa³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ValType(lImpNF) == "L"
			If !lImpNF .AND. lTefOk .AND. LjNfUsaTef(SM0->M0_CGC)
				If !lFtvdVer12
					Lj7CancVenda(STR0084, 	SL1->L1_DOC, 	SL1->L1_SERIE, 	/*cPdv*/"", .T., lTefOk) //"Emissão de Nota Fiscal Cancelada"
				ElseIf lFtvdVer12
					Lj7CancVenda(STR0084, 	SL1->L1_DOC, 	SL1->L1_SERIE, 	/*cPdv*/"", .T., lTefOk, @lExistNF	, @cDescErro)
				EndIf
			EndIf
		Else
			lImpNF := .T.
		EndIf
    EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Compensa os titulos RA com a NF gerada na entrega - POR|EUA  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (cPaisLoc$"EUA|POR" .OR. cPaisLoc$"MEX|COL") .AND. lLayAway
	   nTotalItem += Lj7T_ImpsV("1",2)
	   For nX := 1 to Len(aNumLay)
	      cNumLay    := AllTrim(aNumLay[nX])
		  nTotalLay  += a800Total(.T.)
	   Next nX
	   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	   //³ Compara o valor da venda e do Lay-Away para verIficar se tra-³
	   //³ ta de finalizacao total do Lay-Away                          ³
	   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   lLayTotal   := nTotalItem == nTotalLay .OR. !SuperGetMV("MV_LWPARC")
	   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	   //³ Chama a tela de compensacao quando entrega parcial ou o para-³
	   //³ metro MV_LWCPAUT = .F.(permite ou nao compensacao automatica ³
	   //³ na finalizacao do Lay-Away)                                  ³
	   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   If lCompensa
	      If !SuperGetMV("MV_LWCPAUT",,.T.) .OR. !lLayTotal
	         If Len(aRecnoSE1) > 0
			   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			   //³ Posiciona no titulo NF gerado pela entrega do Lay-Away	    ³
			   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	            SE1->(DbGoto(aRecnoSE1[1]))
		        a800Titulo(5,nOutros,aNumLay)
		     EndIf
		  Else
			 //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			 //³ Se for entrega total ja compensa os titulos de forma automatica   ³
			 //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		     If !a800CompAut(aNumLay)
		        Aviso(STR0031,STR0032+chr(13)+; //"Atencao!"###"Nao foi possivel fazer a compensacao dos titulos RA "
		        	  STR0033+chr(13)+;         //"gerados pelo Lay-Away. Fazer a compensacao manualmente atraves "
		              STR0034,{STR0005})        //"da rotina Compensacao Contas a Receber."###"Ok"
		     EndIf
		  EndIf
	   EndIf
    EndIf
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Aqui podemos fazer um tratamento para cada erro encontrado.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Len( aRet ) > 2 .AND. !Empty( aRet[3] ) .AND. !lErroCF .AND. !lShowMsgEr
		MsgStop( aRet[3] )
	EndIf

	If lErroCF
		// ### "Houve problemas na impressão do Cupom Fiscal."
		Lj7CancVenda(	STR0076	,	cDoc	,	cSerie	,	cPdv,;
					 	.T.		, 	lTefOk	,	Nil     ,  	Nil	,;
					 	Nil     , 	lErroCF	)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Tratamento para gravar os campos   ³
		//³com os valores que tinham antes de ³
		//³passar pela funcao RecTrib ()      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cPaisLoc == "BRA"
			DbSelectArea( "SL1" )
			DbSetOrder( 1 )
			DbSeek( xFilial( "SL1" ) + cSeqTrans )
			If SL1->( !Eof() ) .AND. xFilial( "SL1" ) + cSeqTrans == SL1->L1_FILIAL + SL1->L1_NUM
				RecLock( "SL1", .F. )
				REPLACE L1_VALBRUT WITH Lj7T_Total(2)
				REPLACE L1_VLRLIQ  WITH Lj7T_Total(2)
				MsUnLock()
			EndIf

			DbSelectArea( "SL2" )
			DbSetOrder( 1 )
			DbSeek( xFilial( "SL2" ) + cSeqTrans )
			While SL2->( !Eof() ) .AND. xFilial( "SL2" ) + cSeqTrans == SL2->L2_FILIAL + SL2->L2_NUM
				RecLock("SL2", .F.)
				REPLACE L2_VRUNIT  WITH L2_PRCTAB - Round( ( L2_VALDESC / L2_QUANT ),MsDecimais( nMoedaCor ) )
				REPLACE L2_VLRITEM WITH L2_VRUNIT * L2_QUANT
				REPLACE L2_VALPS2  WITH 0
				REPLACE L2_VALCF2  WITH 0
				REPLACE L2_BASEPS2 WITH 0
				REPLACE L2_BASECF2 WITH 0
				MsUnLock()
				DbSkip()
			End
		EndIF
		Return .F.
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Faz a impressao do cupom TEF e grava as informacoes do TEF nas tabelas SL1, SL2 e SL4 #TEFOK#³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lAutoExec .AND. !lRecebe .AND. lRet .AND. !lErroNFCe

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava a milhas do cupom para o cliente³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lUsaTef .AND. GetNewPar( "MV_TEFMILH", .F. ) .AND. cTipTEF $ "2;3;4"
       LOJA010T( "P", "AO", aRet )
	EndIf

	If Len(aTEFDados) > 0
		lTefOk := .T.
	Endif
	
	//Caso utilize o PBM executa rotina de impressão do Template
	If lUsaTef .And. ExistTemplate("DroVLImp") .And. ExistFunc("LJ7DadosVL") ;
	   .And. Len(aRetPbm) > 2 .And. aRetPbm[3] == 2
	   
		aPbmImp := ExecTemplate("DroVLImp",.F.,.F.,{2})
		LJ7DadosVL({aRetPbm[1],aRetPbm[2],0}) 
	Else
		LjGrvImpTEF(@lTefOk		, lCartao	, aRet		, @nSize	,;
					@cRBuffer	, nHandle	, @lAbtoAll	, @cAdminis	,;
			    	@oTef		, cSerie	, lLog1		, lLog4		,;
					@lErrCupTEF	, @lDscCupTef, aTEFDados, @lTemTefPend,;
					aNSUVndTef  )
	EndIf	

	// Se for faturamento e a nota foi impressa, confirma a transacao TEF
	If (!ValType(lImpNF) == "U") .AND. lImpNF .AND. LjNfUsaTef(SM0->M0_CGC) .AND. lTefOk .AND. !IsBlind() ;
		.Or. (Len( aPbmImp) > 0 .And. aPbmImp[1] == 0)

		If cTipTef == TEF_CLISITEF
			If Len( aPbmImp) > 0 .And. aPbmImp[1] == 0
				oTEF:FinalTrn(1)
			EndIf
			oTef:lImprimiu := .T.
			lTefOk := oTEF:lTefOk := .T.
		ElseIf cTipTef $ TEF_SEMCLIENT_DEDICADO + ";" + TEF_COMCLIENT_DEDICADO + ";" + 	TEF_DISCADO
			LOJA010T(  "F"   , "S"	  	, /*aDados*/		, /*lConsulta */  	,;
                   /*lImprime*/ , /*cFPagReceb*/ 	, /*lTemTEFPend*/	, /*lAbandonaTEF*/	,;
                   /*lTitulo*/	, /*aTefTmp*/		, /*lBaixa*/		, /*lSemRede*/		,;
                   /*cOrcamen*/	, /*lRelGer*/		, /*cMsgCupom */	, /*nVlrTotal*/		,;
                   /*cId800*/	, /*oWsTrn*/		, /*aDadosTrn*/		, /*lRecCel*/		,;
				   /*lTemTEFOk*/, .T.)
			lTefOk :=  .T.
		Else
			lTefOk := .T.
        Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se o campo LG_LOGTEF existe e verifica³
		//³se posicionou no registro                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If LJVerifSLG()
			If !Empty(SLG->LG_LOGTEF)
				RecLock("SLG",.F.)
				REPLACE SLG->LG_LOGTEF WITH ""
				SLG->(MsUnLock())
			Endif
		Else
			If File(GetClientDir() + "CLISITEF." + StrZero(oTEF:nIDTermina, 3) ) .And. oTef:lTefOk
				FErase( GetClientDir() + "CLISITEF." + StrZero(oTEF:nIDTermina, 3) )
			EndIf
		Endif
	EndIf
EndIf

//Envio da resposta fiscal para o integrador MFE utilizado no POS
//If lMFE .And. lLjRspFisc .And. Len(aNSUVndTef) > 0
//	LjRspFisc(aNSUVndTef,.T.,aIdPgtoMfe)
//	aIdPgtoMfe := {}
//EndIf	

//se for PAF-ECF, realiza o tratamento do troco, antes da venda subir para a retaguarda
If lMVLJPDVPA .AND. lHabTroco .AND. ExistFunc("LjGrvLiq")
	LjGrvLiq()
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ATENCAO: Atualizacoes que envolvem as Tabelas: SL1,SL2 e SL4 devem ser realizadas antes desse ponto				³
//³Atualiza Campo L1_SITUA para integração com Job(Loja1115/FRTA020) responsavel por subir a venda para Retaguarda	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lRecebe .AND. aRet[1] .AND. !lEmiteNF .AND. cPaisLoc == "BRA"
	RecLock("SL1",.F.)
	REPLACE L1_DOC WITH cDoc

	If cPaisLoc == "ARG"
		REPLACE L1_SERIE WITH Lj7SerArg()
	Else
		If Empty(L1_SERIE)
	   		SerieNfId("SL1",1,"L1_SERIE",dDataBase,LjEspecieNF(),LjGetStation("LG_SERIE"))		
	 	EndIf
	EndIf
	
	If lIsPafNfce
		REPLACE L1_SERPDV 	WITH LjGetStation("LG_SERPDV")		//Numero de fabricação do ECF
		REPLACE L1_KEYNFCE 	WITH cKeyNfce
	Else
		If !lEmitNfce
			REPLACE L1_SERPDV 	WITH LjGetStation("LG_SERPDV")		//Numero de fabricação do ECF
		ElseIf lEmitNFCe .AND. SL1->(ColumnPos("L1_KEYNFCE")) > 0 .AND. !lUseSat 
			REPLACE L1_KEYNFCE 	WITH cKeyNfce
		EndIf
	EndIf

	// caso estive usando V.A como pdv é gravado l1_situa como '00' para subir a venda so na retaguarda
	If lMVLJPDVPA
		REPLACE L1_SITUA 	WITH "00"
		REPLACE L1_OPERACA  WITH "C"
	ElseIf !lMVLJGRVON .AND. lProcBaixa .AND. SL1->L1_SITUA <> "OK"
		REPLACE L1_SITUA WITH "RX" //Quando Online, ou seja, conectado no server da Retaguarda, sinaliza que venda deve ser processada pelo GrvBatch
	EndIf

	MsUnlock()
	//Permitir "Startar" o Job após a gravação da Venda
	If !lMVLJGRVON .AND. !lMVLJPDVPA .AND. lRet
		If lMVLJGRVJB
	   		If !lAutoExec
		   		//Verifica vendas pendentes em aberto
		   		aOrcamentos := LJ7OrcPen()
		   		
		   		For nX := 1 To Len(aOrcamentos)
			   		//Executa a gravacao da venda em thread
			   		StartJob("ljGrvJob",GetEnvServer(),.F.,cEmpAnt,cFilAnt, aOrcamentos[nX])
				Next
			Else
				//Executa a gravacao da venda em thread
			   	StartJob("ljGrvJob",GetEnvServer(),.F.,cEmpAnt,cFilAnt, SL1->L1_NUM)
			EndIf 
		Else
			ConOut(STR0111)//"Deve estar configurado o job ljGrvBatch para integracao com as tabelas do ERP")
	    EndIf
    EndIf
EndIf
If !Empty(LOG_TEF)
	LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Finalização da Gravação Venda - ' + If( lRet, 'S', 'N' ))
EndIf

If lRet
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Controla o valor subtotal se o Tef ocorreu erro³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nValSubTot  := 0
EndIf

Lj7RestArea(aArea)

If( ExistFunc("LOJA0051") .And. SuperGetMV( "MV_LJILVLO",,"2" ) == "1")
	oLJCLocker:ReleaseLock( "LOJA701AILLock" )
	Sleep(300)
 	If !oLJCLocker:GetLock( "LOJA701AILLock" )
	 	If ModType(nModulo) == 'L'
			FinishLoja(.T.)
		EndIf
 		nModulo := 0 // Impede que o final rode o FinishLoja novamente.
 		DbCloseAll() // Fecha todas as tabela para que a carga possa ser efetuada.
		Final(STR0141)	// "O sistema será encerrado, pois foi solicitado a carga de dados nesse terminal."
	EndIF
Endif

Return lRet


/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³Lj7Pedido ºAutor  ³Vendas Clientes     º Data ³  24/09/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Faz as gravacoes no SL1 e SL2 que transforma o orcamento    º±±
±±º          ³em pedido                                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ExpL1 := Lj7Pedido()                                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ExpL1 - Indica se conseguiu ou nao fazer a gravacao         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP7                                                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Loja701                                                     º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Lj7Pedido( aDadosCF	, nTipo		, nHandle	, lTemTefPend	,;
					aTefBKP 	, lJob		, nFatorRes	, nFatorVen		,;
					lAlterOrc	, aProdAlter, cEspDoc	, cDocFo		,;
					nOpc		, cDocPed	, cSeriePed	, lTefManuPed	,;
					lDscCupTef	, aBkpTable	, lEmiteNF	, cTxtNFis		,;
					aDocReti	, nVlrAcrsFi )
Local lRet 			:= .T.											// Retorno da Funcao
Local aRetCNF		:= {.T., {"", ""}} 								// Array com o retorno da funcao Lj7ImpCNF()
Local aArquivos 	:= {}											// Array com o retorno da funcao Lj7GeraOrc()
Local aArqAux2		:= {}											// Array auxiliar
Local aLojas		:= {}											// Array com as lojas que podem ser feitas as reservas
Local aSL1			:= {}											// Array com os dados do SL1
Local aSL2			:= {}											// Array com os dados do SL2
Local aSL4			:= {}											// Array com os dados do SL4
Local aOrcRetira	:= {}											// Array com Orcamentos Retira
Local nI			:= 0											// Auxiliar do For
Local nX 			:= 0											// Auxiliar do For
Local nY			:= 0											// Auxiliar do For
Local nPos 			:= 0											// Posicao da loja reservada no array aLojas
Local nSize			:= 0											// Tamanho da linha do LOG txt
Local nVlrEntrada	:= 0											// Valor de Entrada
Local nConta		:= 0											// Auxiliar do For
Local nPos1			:= 0 											// Posiciona o array de produtos
Local nPos2			:= 0 											// Posiciona o array de produtos
Local cRBuffer		:= ""											// Buffer com conteudo da linha do log txt
Local cNumPai    	:= 0											// Numero do registro no SL1 do "pedido"
Local cSerie		:= LjGetStation( "LG_SERIE" )					// Serie que estah cadastrada na estacao
Local lCartao 		:= .F.											// Flag de controle se as parcelas sao TEF
Local lTefOk		:= .F.											// Flag de controle do TEF
Local lLog1       	:= SubStr(LJGetProfile("LOGERRO"),1,1) == "S"	// Tem Log de Erro
Local lLog4         := SubStr(LJGetProfile("LOGERRO"),4,1) == "S"	// Log de Recuperacao, grava as parcelas
Local cSeqTrans		:= ""											// Tratamento da sequencia do TEF
Local cLojaLocal	:= ""											// Loja local no Cadastro de Lojas
Local aAuxaPgtos	:= {}											// Array auxiliar baseado no aPgtos
Local nAuxNcc		:= 0											// NCC
Local aAuxNcc		:= 0											// Array com os item NCC
Local nNccAux    	:= 0											// NCC usada
Local aAcrFin		:= {}											// Array para armazenar o valor do acrescimo financeiro proporcional por item
Local aAreaL1Pai	:= {}											// Pega a Area posicionada no Orcamento Pai do SL1
Local aAreaL2Pai	:= {}											// Pega a Area posicionada no Orcamento Pai do SL2
Local aAreaL4Pai	:= {}											// Pega a Area posicionada no Orcamento Pai do SL4
Local aAreaL1Filhos	:= {}											// Pega a Area apos geracao dos Filhos do SL1
Local aAreaL2Filhos	:= {}											// Pega a Area apos geracao dos Filhos do SL2
Local aAreaL4Filhos	:= {}											// Pega a Area apos geracao dos Filhos do SL4
Local lVendErro		:= .F.											// Indica se ocorreu algum erro na Venda
Local lLJ7058		:= ExistBlock("LJ7058")							// Se existe o PE LJ7058. Esse ponto de entrada tem como objetivo permitir que o cliente crie uma única OS para todo o pedido, evitando a quebra da OS pelo parâmetro MV_LJTPPED
Local nValRes		:= 0											// Valor dos itens com reserva
Local lGE			:= ExistFunc("LjUP104OK") .AND. LjUP104OK()		// Validação do Conceito Garantia Estendida
Local cMvLjTGar		:= SuperGetMV("MV_LJTPGAR",,"GE")              	// Define se é tipo GE
Local nVlrGar  		:= 0  											// Valor da garantia
Local cCodProGar	:= ""                                           // Produto Garantia.
Local lAutoExC		:= IsBlind()									// Verifica se a rotina sera executada via execauto ou nao
Local lCalcIPI      := .T.											// Verifica se calcula valor de IPI
Local cTpGeraGdp	:= GDP_NO						              	// Informa como sera gerada Guia de Despacho a partir do pedido de venda.
Local nItens		:= 0											// Total de itens da venda
Local cDocPai 		:= ""											// Numero do documento do orcamento pai
Local cSeriePai		:= ""											// Serie do documento do orcamento pai
Local lImpCNFLoc	:= .F.											// Indica que sera impresso o comprovante nao fiscal
Local lLstPre    	:= SuperGetMV("MV_LJLSPRE",.F.,.F.) .AND. IIf(ExistFunc("LjUpd78Ok"),LjUpd78Ok(),.F.) //Lista de Presentes - Ativa
Local lVerLojLst    := .F.                                          // Variavel que verifica se existe loja cadastrada.
Local nCont			:= 0											// Contador utilizado contagem do SL2
Local nPosDTEF		:= 0 											// Posicao de D TEF pendente
Local aRelGar 		:= {}              								// Array do Relatório de Garantia
Local aRelGer 		:= {}               							// Array do Relatório Gerencial
Local cImpRGer  	:= SuperGetMV("MV_RELGART",,"U_LOJR600A") 		// Nome do funcao que imprime relatorio gerencial
Local lAvCred		:= .T. 											// Variavel que controla analise de credito para o pedido.
Local nValPIS		:= 0											// Valor total do PIS
Local nValCSLL		:= 0											// Valor total do CSLL
Local nValCOFI		:= 0											// Valor total do COFINS
Local nValINSS		:= 0											// Valor total do INSS
Local nValIRRF		:= 0											// Valor total do IRRF
Local nBasePIS    	:= 0											// Base de calculo do PIS
Local nBaseCSLL   	:= 0											// Base de calculo do CSLL
Local nBaseCOFI   	:= 0											// Base de calculo do COFINS
Local nBaseINSS   	:= 0											// Base de calculo do INSS
Local nBaseIRRF   	:= 0											// Base de calculo do IRRF
Local lTefAbort		:= .F.											// Se o Tef foi cancelado dentro da lj7Pedido. Verificação p/ não chamar TEF pela segunda vez .
Local nReserva 		:= "" 											// Posicao da reserva dentro do array
Local aArea1		:= {}
Local aArea2		:= {}
Local aArea3		:= {}
Local aAreaSM0		:= {}
Local aTimeUf		:= {}
Local lTefMult		:= SuperGetMV("MV_TEFMULT", ,.F.) 				// Identifica se o cliente utiliza múltiplas transacoes TEF
Local nFrete		:=	0											// VALOR DO FRETE
Local aRecnoFin		:= {} 											// Guarda o Recno dos registros financeiros gerados da venda.
Local cNumTit 		:= ""
Local cE1NumPE 		:= ""
Local aNSUVndTef	:= {}
Local aRetMFilhos	:= {}											// Retorno da função responsável por montar array com os orçamentos filhos
Local aRetTef		:= {}											//Retorno da função responsável por efetuar o TEF
Local aTaxJuros 	:= {0,0,0,0}
Local cTpFrete 		:= "" 											// Tipo do Frete
Local cB1M996		:= "" 											// Informacao do Campo do Cadastro de Produtos (Configurado no parametro MV_B1M996) utilizado para identificar PIS/Cofins para pessoa juridica de direito Publico. Art. 7, Lei 9718(SRF).
Local cSitua		:= ""
Local aPedidos		:= {}											// Informações dos pedidos a serem gerados
Local nSeconds 		:= 0 											// Armazena segundos inicial
Local nRetImp		:= 0											// Controle Impressao
Local lIntegDef	    := If(Type("lAutoExec") == "L", lAutoExec, .F.) .And. FWHasEAI("LOJA701",, .T., .T.) .AND. IIF( ExistFunc("Lj701GtInD") , Lj701GtInD(), IsInCallStack("LOJI701"))  //Integracao via Mensagem Unica
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local lEmitNfce	    := LjEmitNFCe()		// Sinaliza se utiliza NFC-e
Local aRetPbm       := {}	//Retorno das informações retornadas do PBM Funcional Card
Local aPbmImp       := {}	//Informações da impressão do PBM

Default nHandle 	:= -1											// Handle do arquivo
Default lJob		:= .F.											// IdentIfica se a rotina e' chamada via JOB ou nao
Default nFatorRes	:= 1
Default nFatorVen	:= 1
Default lTefManuPed	:= .F.
Default lAlterOrc   := .F.
Default aProdAlter  := {}
Default cDocFo		:= ""
Default nOpc		:= 3
Default cDocPed		:= ""
Default cSeriePed  	:= ""
Default lDscCupTef	:= .F.
Default aBkpTable	:= {}
Default	lEmiteNF	:= .F.
Default	cTxtNFis 	:= ""
Default aDocReti	:= {}
Default nVlrAcrsFi  := 0 

LjGrvLog("LJ7PEDIDO" , "ID_INICIO")

/* Fluxo da Rotina LJ7Pedido  

Pedido Início
	
	01 - Realiza a operação TEF	
	
	02 - Monta os orçamentos filhos	
			
	03 - Recalcula impostos, descontos, rateios ,arredondamentos

	04 - Atualiza as informações do SL1/SL2 e SL4 do registro pai	
	
		Início Transação 1
		|
	05 -  | Grava orçamentos filhos	
		|
		Fim Transação 1	
			
		Início Transação 2
		|
	06 -  | Grava/finaliza/Imprime Orçamentos retira	
		|
		Fim Transação 2	
		 
	07 - Realiza a impressão dos comprovantes não fiscais e pega numeração do pedido 
	
	08 - Atualiza numeração dos pedidos nos registro Pai e filhos	 
	
		 Início Transação 3
		 |
	09 -   | Geração dos pedidos de vendas		
	10 -   | Geração do financeiro da venda pedido
		 |
		 Fim Transação 3
	
	11 -  | Realiza estorno da rotina no caso de erro em algum dos processos.	

Pedido Fim
		
*/

//Exibição da tela para consulta dos produtos reservados pela Funcional Card
If ExistTemplate("DroVLVen") .And. ExistFunc("LJGDadosVL")
	aRetPbm := LJGDadosVL()
	If Len(aRetPbm) > 2 .And. Len(aRetPbm[2]) > 0 .And. ExistFunc("LJ7DadosVL")
		ExecTemplate("DroVLVen",.F.,.F.,{aRetPbm[3],aRetPbm[2],aRetPbm[1],SL1->L1_NUM})
		LJ7DadosVL() 
	EndIf	
EndIf	


aRetAdmTef := {} //Reinicializa o array

cNumPai		:= SL1->L1_NUM //Grava os dados da reserva antes da impressao do cupom fiscal

//Se não for recuperação do Pedido/Financeiro "P3|P4|P5" 
If  !(AllTrim(SL1->L1_NSO) $ "P3|P4|P5")

	//Chile - Guia de Despacho - F2CHI Verificar no orcamento PAI como sera gerada a Guia	
	//De Despacho, de acordo com o tipo de entrega de cada item da venda.	
	If lCFolLocR5 .AND. cPaisLoc == "CHI"	
		cTpGeraGdp := Lj7ChkGdp( IIf( lJob , SL1->L1_NUM , M->LQ_NUM) , lJob )
	EndIf
	
	nFrete := SL1->L1_FRETE+SL1->L1_DESPESA+SL1->L1_SEGURO // Caso venha do Front
	
	If lJob				
		cSeqTrans := SL1->L1_NUM
		
		lCalcIPI  := .F.
		
		//Quando for o JOB INTEGRACAO_ERP, a array aAuxaPgots   
		//devera ser alimentado atraves da tabela SL4           
		LJ7aAuxPgtos( @aAuxaPgtos)
		aPgtos 	   := aClone(aAuxaPgtos)
		nAuxNcc    := 0
		aAuxNcc	   := {}
	    nNccAux	   := 0
	Else
		cSeqTrans  := M->LQ_NUM
		nAuxNcc	   := nNccUsada
		aAuxNcc	   := aNccItens
		nNccAux	   := nNccGerada
	EndIf
	
	// Abre a tela para para pedir os dados dos cheque / financiadora
	If !Lj7InfPgtos( nTipo		, NIL, NIL, lJob,;
					 aAuxaPgtos,@aTaxJuros )
	
		If !lJob
			If !Empty(LOG_TEF)
				LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', 'Transf. Orçamento em Pedido - N')
			EndIf
		EndIf
		lTelaTefPed := .T.
		Return .F.
	EndIf
	
	//Se o ponto de entrada LJ7058 existir, significa que o cliente irá criar a ordem  
	//de serviço para todo o pedido. Essa criação não pode ser feita pelo módulo padrão,   
	//pois entregas e montagens em endereços diferentes não pode ser agendado no field service.
	//Esse ponto de entrada foi criado específicamente para a Etna, pois ela trata o agendamento da OS de modo customizado. 
	If lLJ7058 .AND. !lFtvdVer12
		LjGrvLog("ORC_PAI_" + AllTrim(SL1->L1_NUM),"Antes da execução do P.E. LJ7058")
		ExecBlock( "LJ7058", .F., .F. )
		LjGrvLog("ORC_PAI_" + AllTrim(SL1->L1_NUM),"Depois da execução do P.E. LJ7058")
	EndIf
	
	//Limpamos o L1_SITUA, pois o orcamento pai somente pode ser "T1" ate a geracao dos filhos.
	//Ja que se houver qualquer erro nessa funcao, a transacao sera desarmada, o pai continuara como "T1",
	//pois o orcamento ficara em aberto e nenhum orcamento filho sera gerado
	If (lEmitNFCe .Or. lIsPafNfce) .AND. SL1->L1_SITUA $ "T1|T2|T3"
		cSitua := ""
	Else
		cSitua := SL1->L1_SITUA
	EndIf
	
	If SL1->(Reclock( "SL1", .F. ))
		Replace SL1->L1_TIPO with "P"
		Replace SL1->L1_SITUA with cSitua
		SL1->( MsUnlock() )
	EndIf
	
	//Verifica se a Venda é Originada de Integração
	If SL1->L1_ORIGEM == "N"
		lIntegDef := .T.
	Endif 
	
	//Verifica se o Pedido não foi finalizado orretamente para fazer estorno
	If AllTrim(SL1->L1_NSO) $ "P0|P1|P2" .AND. Len(aOrcFilDel) > 0
		Lj7DelOrc(aOrcFilDel)
		aOrcFilDel := {}
	EndIf

	Lj7GeraSL("SL1",{{"L1_NSO",""}},.F.)
	
	// 1 - Realiza a operação TEF
	If lRet .AND. !lJob
		aRetTef := Lj7PedTEF(	@aTefBKP		, @lTemTefPend	, @lTefAbort	, @aNSUVndTef,;
								@lTefManuPed	, @lCartao )
		lTefOk := aRetTef[1]	//TEF realizado com sucesso?
		If !aRetTef[2]	//Continua o processo da função LJ7Pedido
			lRet := .F.
		EndIf
	EndIf
	
	nSeconds := Seconds() // Armazena segundos inicial apos o TEF
	
	// 2 - Monta os orçamentos filhos
	If lRet
		aRetMFilhos := LJ7MFilhos(	@cLojaLocal	, lJob			, @aRelGer		, @aRelGar	,;
									@cB1M996	, @cImpRGer		, aProdAlter	, lAlterOrc	,;
									@nValRes	, cTpGeraGdp	, @lImpCNFLoc	, @aBkpTable,;
									aAuxaPgtos	, @nFatorVen	, @nFatorRes		, @lVendErro,;
									aTaxJuros	, nFrete		)
		If aRetMFilhos[1]
			aArqAux2 := aClone(aRetMFilhos[2])
		Else	
			lRet := .F.
		EndIf
	EndIf
	
	//Guarda area registro Pai
	aAreaL1Pai	:= SL1->(GetArea())
	aAreaL2Pai	:= SL2->(GetArea())
	aAreaL4Pai	:= SL4->(GetArea())
	
	//P0 - Antes do início das Transações
	Lj7GeraSL("SL1",{{"L1_NSO","P0"}},.F.)
	
	// 4 - Atualiza as informações do SL1 / SL2 e SL4 do registro Pai
	If lRet
		Lj7AtuPed(	lJob		, aRetCNF	, @cDocPed	, @cSeriePed	,;
					cTpGeraGdp	, @cDocPai	, @cSeriePai, lTefOk		,;
					aNSUVndTef	, @lAvCred	, cLojaLocal, lTefManuPed)
	EndIf			
	
	//P1 - Transação 1
	Lj7GeraSL("SL1",{{"L1_NSO","P1"}},.F.)	
	If lRet
		LjGrvLog(cNumPai,"Início transação 1")
	
		// 5 - Grava orçamentos filhos	
		LjGrvLog(cNumPai,"Gravando orcamentos filhos")
		
		Begin Transaction 
			bOldError := ErrorBlock( {|x| LjVerIfErro(x) } ) 
			Begin Sequence
				lRet := LJ7GrvFilh( aArqAux2	, @aArquivos, @lJob		, cTpGeraGdp,;
									cDocPai		, cSeriePai	, aRetCNF	, cImpRGer	,;
									lVendErro	, lAlterOrc	, cNumPai	, lAvCred	,;
									@aOrcRetira	, @aPedidos	, cLojaLocal, cDocPed	,;						
                        			cSeriePed)			
			Recover
				lRet := .F. 
				DisarmTransaction()
			End Sequence
			ErrorBlock( bOldError )						
		End Transaction
		LjGrvLog(cNumPai,"Fim transação 1 RETORNO : ",lRet)
		//Guarda Area apos geracao dos Filhos
		aAreaL1Filhos	:= SL1->(GetArea())
		aAreaL2Filhos	:= SL2->(GetArea())
		aAreaL4Filhos	:= SL4->(GetArea())
	EndIf	
		
	// 6 - Pega Numeração dos pedidos
	If lRet
		//Restauro a area da venda original(Pai)
		RestArea(aAreaL1Pai)
		RestArea(aAreaL2Pai)
		RestArea(aAreaL4Pai)	
	
		aRetCNF := lj7ImpPed(	lTefOk	, lJob		, nFatorRes	, lImpCNFLoc,;
							nOpc 	, @cTxtNFis	)
							
		LjGrvLog(cNumPai,"Depois da impressao do comprovante ",aRetCNF)
		
		If lLog1 .AND. lLog4 .AND. nHandle >= 0
			nSize 		:= FSeek( nHandle, 0, 2 )
			cRBuffer 	:= Space( nSize )
		
			FSeek( nHandle, 0, 0 )
			FRead( nHandle, @cRBuffer, nSize )
		
			cRBuffer := Encript( cRBuffer, 1 )
			If !("#DADOSOK#" $ cRBuffer)
				cRBuffer := cRBuffer + "#DADOSOK#"
			EndIf
		
			FSeek( nHandle, 0, 0 )
			FWrite( nHandle, Encript( cRBuffer, 0 ) )
		
			LjGrLogT(	SL1->L1_NUM			, aRetCNF[2][1]		, xNumCaixa()		, NIL				,;
						SL1->L1_DINHEIRO	, SL1->L1_CHEQUES	, SL1->L1_CARTAO	, SL1->L1_VLRDEBI	,;
						SL1->L1_CONVENI		, SL1->L1_VALES		, SL1->L1_FINANC	, SL1->L1_OUTROS	,;
						SL1->L1_DESCONT		, SL1->L1_DESCNF	, aRetCNF[2][2]		, cSerie )
		EndIf
	
		If !aRetCNF[1]
			Aviso( STR0007, STR0014, {STR0005} ) //"Atenção"###"Houve erros na impressão do comprovante de venda. VerIfique a impressora."###"Ok"
			LjGrvLog(M->LQ_NUM, 'Erro na impressao do comprovante de venda.' )
			Return .F.
		EndIf
		
		If lJob
			aRetCNF[2][1] := SL1->L1_DOCPED
			aRetCNF[2][2] := SL1->L1_PDV
		EndIf
		cDocPed := aRetCNF[2][1]
		
		If cPaisLoc <> 'BRA' .AND. Empty(aRetCNF[2][2])
			aSequencia	:= {}
		 	LjxDNota(LjGetStation("LG_SERIE"), 1, .F., 1, @aSequencia, nil, nil, 1, 999, .F., "", Nil)
			cDocPed		:= aSequencia[1][2]
		EndIf
	
	EndIf	
	
	If lRet
		//P2 - Transação 2 
		//Restauro a area da venda original(Pai)
		RestArea(aAreaL1Pai)
		RestArea(aAreaL2Pai)
		RestArea(aAreaL4Pai)	
		LjGrvLog(cNumPai,"Início transação 2 fator :", nFatorVen)
		Lj7GeraSL("SL1", { {"L1_NSO" , "P2"	} } , .F.)
		
		//Restauro a area da venda filho
		RestArea(aAreaL1Filhos)
		RestArea(aAreaL2Filhos)
		RestArea(aAreaL4Filhos)
	
		// 8 - Grava/finaliza Orcamentos retira	
		bOldError := ErrorBlock( {|x| LjVerIfErro(x) } ) 
		Begin Sequence
			lRet := LJ7GrvReti( aOrcRetira 	, lJob 		 , lEmiteNF    		,cNumPai   	,;
								aDadosCF	, nHandle 	 , @lTemTEFPend 	,nFatorRes 	,;
								nFatorVen   , lTefOk     , @lDscCupTef  	,lTefAbort 	,;
								nValRes     , aAreaL1Pai , aAreaL1Filhos  	,cTpGeraGdp ,;
								cEspDoc     , cDocFo     , aArquivos		,@aDocReti  ,; 
								lCartao	)

			
			//Guarda Area apos geracao do Filho Retira
			aAreaL1Filhos	:= SL1->(GetArea())
			aAreaL2Filhos	:= SL2->(GetArea())
			aAreaL4Filhos	:= SL4->(GetArea())
			
			//Restauro a area do SL1, SL2, SL4 da venda original(Pai), necessario para geracao do SE1
			RestArea(aAreaL1Pai)
			RestArea(aAreaL2Pai)
			RestArea(aAreaL4Pai)	
								
			If lRet				
				// 7 - Atualiza numeracao pedido registro Pai e filhos
				Lj7GeraSL("SL1",{{"L1_SITUA","P3"}},.F.)
				Lj7GeraSL("SL1",{{"L1_NSO","P3"}},.F.)
			
				Lj7AtuNum(	lJob 		, aRetCNF 	, @cDocPed , @cSeriePed , ;
							aOrcRetira	, aPedidos	) 
							
				RestArea(aAreaL1Pai)
				RestArea(aAreaL2Pai)
				RestArea(aAreaL4Pai)				
			EndIf						
		Recover
			lRet := .F. 
		End Sequence
		ErrorBlock( bOldError )						
	
		LjGrvLog(cNumPai,"Fim transação 2 , retorno : ",lRet)								
	EndIf
	
	// 9 - Impressão TEF
	//Se for TEF_DISCADO, verificamos o conteudo da variavel lDscCupTef,
	//pois o comprovante TEF ja pode ter sido impresso na funcao Lj7GrvVenda
	If lRet .AND. !lJob .AND. lUsaTef .AND. !lDscCupTef
		//Caso utilize o PBM executa rotina de impressão do Template
		If ExistTemplate("DroVLImp") .And. ExistFunc("LJ7DadosVL") ;
	   	   .AND. cTipTef == TEF_CLISITEF .And. Len(aRetPbm) > 2 .And. aRetPbm[3] == 2
	   
			aPbmImp := ExecTemplate("DroVLImp",.F.,.F.,{2})
			LJ7DadosVL({aRetPbm[1],aRetPbm[2],0}) 
			
			If Len( aPbmImp) > 0 .And. aPbmImp[1] == 0
				oTEF:FinalTrn(1)
			EndIf				
		
		ElseIf LJXVERTEF(.F.)	
			Lj701ImpTr(nHandle,@lTemTEFPend) //Aguarde... Impressão do Tef
			LjGrvLog(cNumPai,"Impressao do comprovante TEF ",lTemTEFPend)
			Lj7GeraSL("SL1",{{"L1_NSO","P4"}},.F.)
		Endif		
			
	EndIf

	
	// 6 - Realiza a impressão dos comprovantes dos Pedidos
	If lRet
		// Imprime
		If !Empty(cTxtNFis)
			nRetImp := 1
			While nRetImp <> 0
				nRetImp := INFTexto(cTxtNFis)
		
				If nRetImp <> 0
					If !MsgYesNo("Não foi possível imprimir o comprovante, tentar novamente?")
						nRetImp := 0
					EndIf
				Else
					cTxtNFis := ""	
				EndIf
			End
		EndIf
		Lj7GeraSL("SL1",{{"L1_NSO","P5"}},.F.)		
	EndIf	
	
	//Restauro a area do SL1, SL2, SL4 da venda original(Pai)
	RestArea(aAreaL1Pai)
	RestArea(aAreaL2Pai)
	RestArea(aAreaL4Pai)	
	
	//Em caso de Erro Estorna Pedidos caso tenha efetuado alguma gravação
	If !lRet
		Lj7EstPed(	cNumPai , lJob , aOrcRetira	, aPedidos	, ; 
					lTefOk 	)
	EndIf
Else	
	//Guarda area registro Pai
	aAreaL1Pai	:= SL1->(GetArea())
	aAreaL2Pai	:= SL2->(GetArea())
	aAreaL4Pai	:= SL4->(GetArea())
	
	//Guarda Area apos geracao do Filho Retira
	aAreaL1Filhos	:= SL1->(GetArea())
	aAreaL2Filhos	:= SL2->(GetArea())
	aAreaL4Filhos	:= SL4->(GetArea())
	
	Lj7GeraSL("SL1",{{"L1_SITUA","P3"}},.F.)
	
	//Reimpressão TEF
	If  AllTrim(SL1->L1_NSO) $ "P3"
		If lRet .AND. !lJob .AND. LJXVERTEF(.F.) .AND. lUsaTef .AND. !lDscCupTef
			MsgAlert("Será aberta a Rotina Administrativa do TEF para reimpressão do conprovante.")
			If GetAPOInfo("LOJXTEF.PRW")[4] >= Ctod("30/06/2017")
				IF(LJProfile(17), oTEF:Operacoes("REIMP_MENU",{}),)
			Else
				IF(LJProfile(17), oTEF:Operacoes("GERENCIAIS",{}),)
			EndIf
		EndIf
	EndIf	
	
	
	If  AllTrim(SL1->L1_NSO) $ "P3P4"
	
		aRetCNF := lj7ImpPed(	lTefOk	, lJob		, nFatorRes	, lImpCNFLoc,;
								nOpc 	, @cTxtNFis	)
	
		// Realiza a impressão dos comprovantes dos Pedidos
		If lRet
			// Imprime
			If !Empty(cTxtNFis)
				nRetImp := 1
				While nRetImp <> 0
					nRetImp := INFTexto(cTxtNFis)
			
					If nRetImp <> 0
						If !MsgYesNo("Não foi possível imprimir o comprovante, tentar novamente?")
							nRetImp := 0
						EndIf
					Else
						cTxtNFis := ""	
					EndIf
				End
			EndIf
			
		EndIf
		
	EndIf	
	
	Lj7GeraSL("SL1",{{"L1_NSO","P5"}},.F.)
	
	aAuxNcc := {}
	
	aPedidos := Lj7RecupPed(cNumPai , @nAuxNcc , @aAuxNcc , @nNccAux)
	aNccItens := aAuxNcc
	lRet := .T.

EndIf

//P3 - Transação 3
If lRet
	LjGrvLog(cNumPai,"Início transação 3")
	Begin Transaction
		bOldError := ErrorBlock( {|x| LjVerIfErro(x) } )
		Begin Sequence
			
			// 10 - Geração dos pedidos de vendas	
			If lRet
				lRet := LJ7GPedVen(aPedidos)
			EndIf
		
			// 11 - Geracao do financeiro da venda pedido 
			LjGrvLog(cNumPai,"Antes da geracao do financeiro da venda pedido")
			If lRet
			
				If !lJob
					LjGrvLog( M->LQ_NUM ,'Gera SE1 / SE5')
				EndIf
			
				If !lMVLJPDVPA
					//Restauro a area do SL1, SL2, SL4 da venda original, necessario para geracao do SE1
					RestArea(aAreaL1Pai)
					RestArea(aAreaL2Pai)
					RestArea(aAreaL4Pai)
				EndIf
				If !(lVendErro) .AND. !(lMVLJPDVPA)
			
					If cPaisLoc == "BRA" .And. MaFisFound("NF")
						//Valor do CSLL/IRRF
						If lIntegDef //Integracao mantem valor de impostos enviados no xml				
							//Valor total do PIS / COFINS / CSLL
							nValPIS  := IIF(ValType(M->LQ_VALPIS) == "N", M->LQ_VALPIS, 0)	 		
							nValCOFI := IIF(ValType(M->LQ_VALCOFI) == "N", M->LQ_VALCOFI, 0)
							
							nValCSLL := IIF(ValType(M->LQ_VALCSLL) == "N", M->LQ_VALCSLL, 0)
							nValIRRF := IIF(ValType(M->LQ_VALIRRF) == "N", M->LQ_VALIRRF, 0)
							
							//Base de calculo do PIS / COFINS / CSLL
							nBasePIS  := nBasePis
							nBaseCOFI := nBaseCofi
							nBaseCSLL := nBaseCsll
							nBaseIRRF := nBaseIrrf 
						Else			
							//Valor total do PIS / COFINS / CSLL
							nValPIS  := MaFisRet(Nil, "NF_VALPIS")
							nValCSLL := MaFisRet(Nil, "NF_VALCSL")
							nValCOFI := MaFisRet(Nil, "NF_VALCOF")
			
							//Base de calculo do PIS / COFINS / CSLL
							nBasePIS  := MaFisRet(Nil, "NF_BASEPIS")
							nBaseCOFI := MaFisRet(Nil, "NF_BASECOF")
							nBaseCSLL := MaFisRet(Nil, "NF_BASECSL")
						
							//Valor do IRRF
							nValIRRF  := MaFisRet(Nil, "NF_VALIRR")
							nBaseIRRF := MaFisRet(Nil, "NF_BASEIRR")
						EndIf
						
						//Valor do INSS
						nValINSS  := MaFisRet(Nil, "NF_VALINS")
						nBaseINSS := MaFisRet(Nil, "NF_BASEINS")
					EndIf
			
					lRet := LjGrvFin( !lJob 	, NIL		, nAuxNcc	, aAuxNcc	,;
				    	     	      nNccAux	, Nil		, Nil 		, Nil		,;
				    	     	      nValPIS	, nValCSLL	, nValCOFI	, Nil 		,;
				    	     	      Nil		, Nil		, Nil		, Nil 		,;
				    	     	      Nil		, nBasePIS 	, nBaseCOFI , nBaseCSLL ,;
				    	     	      Nil 	 	, Nil 		, cB1M996   , nValINSS  ,;
				    	     	      nValIRRF  , nBaseINSS , nBaseIRRF , Nil		,;
				    	     	      Nil       , Nil       , @aRecnoFin, Len(aNSUVndTef) > 0)
				    	     
				     LjGrvLog(cNumPai,"Depois da geracao do financeiro da venda pedido")
			    EndIF
				
				//Restauro a area do SL1, SL2, SL4 da geracao dos pedidos, para continuar o processo
				If !lMVLJPDVPA
					RestArea(aAreaL1Filhos)
					RestArea(aAreaL2Filhos)
					RestArea(aAreaL4Filhos)
				EndIf
				LjGrvLog(cNumPai,"Filhos gerados com sucesso")
			
			EndIf
		
			If lRet
				//Verifica se tem o Ponto de Entrada que permite modificar a numeracao do tiulo da venda
				If ExistBlock("LJNumTit") .And. Len(aRecnoFin) > 0
					aArea1 := GetArea()
					aArea2 := SE1->(GetArea())
					aArea3 := SEF->(GetArea())
			
					cNumTit 	:= aRecnoFin[1][2]
					
					LjGrvLog("LJ7PEDIDO" , "Antes da Chamada do Ponto de Entrada: LJNumTit",{ SuperGetMV("MV_LJE1NUM",,"1"), cNumTit })
					cE1NumPE 	:= ExecBlock( "LJNumTit", .F., .F., { SuperGetMV("MV_LJE1NUM",,"1"), cNumTit } )
					LjGrvLog("LJ7PEDIDO" , "Apos a Chamada do Ponto de Entrada:LJNumTit")
					
					If !Empty(cE1NumPE)
						cE1NumPE := PadR(cE1NumPE,TamSX3("E1_NUM")[1])
					Else
						cE1NumPE := cNumTit
					EndIf
					
					If cNumTit <> cE1NumPE
						For nX := 1 To Len(aRecnoFin)
							If aRecnoFin[nX][1] == "SE1
								SE1->(DbGoTo(aRecnoFin[nX][3]))
								RecLock("SE1",.F.)
								SE1->E1_NUM := cE1NumPE
								SE1->(MsUnLock())
							ElseIf aRecnoFin[nX][1] == "SEF
								SEF->(DbGoTo(aRecnoFin[nX][3]))
								RecLock("SEF",.F.)
								SEF->EF_TITULO := cE1NumPE
								SEF->(MsUnLock())
							EndIf
						Next nX
					EndIf
					
					RestArea(aArea3)
					RestArea(aArea2)
					RestArea(aArea1)
				EndIf
			EndIf

		Recover
			lRet := .F.
			DisarmTransaction()
		End Sequence
		ErrorBlock( bOldError )	
	End Transaction
	LjGrvLog(cNumPai,"Fim transação 3")
	
	//Vai p orcamento Pai para gravar Status final
	RestArea(aAreaL1Pai)
	If lRet
		Lj7GeraSL("SL1",{{"L1_NSO" , "POK"	 }},.F.)

		If lMVLJPDVPA
			Lj7GeraSL("SL1",{{"L1_SITUA" , "00" }},.F.)
		Else
			Lj7GeraSL("SL1",{{"L1_SITUA" , "FR" }},.F.)
		EndIf
	Else
		Lj7GeraSL("SL1", { {"L1_SITUA" , "ER"},{"L1_ERGRVBT" , "Lj7Pedido - Erro geração Pedido/Financeiro. Venda já finalizada."} } , .F.)
				
		If !lJob
			//Retorna True pois o erro foi no pedido/financeiro e a venda já foi finalizada fica ER para correcao manual nesta estapa do projeto.
			//apenas se não for job pois o Job ainda tem o controle de transacao habilitado
			lRet := .T.			
		EndIf
	EndIf
	
	//VOLTA AREA FILHOS
	RestArea(aAreaL1Filhos)
	RestArea(aAreaL2Filhos)
	RestArea(aAreaL4Filhos)

EndIf	

/*
	Atenção não adicionar rotinas fora da Transação
 	Apos Gravação do Financeiro pois em casos de erro não existe estorno
 	para a mesma fora da transação. 
*/
//Chamada da Função IntegDef para dispara a rotina de Rastreamento
//de pedido.
If lIntegDef .AND. FWHasEAI("MATA410B",.T.,, .T.)
	LjGrvLog("LJ7PEDIDO" , "Chamada IntegDef - MATA410B.")
	FwIntegDef("MATA410B",,,, "MATA410B")
Endif

LjGrvLog(cNumPai,'Finalização da Geração do Pedido - ' + If( lRet, 'S', 'N' ) )
LjGrvLog("LJ7PEDIDO" , "Tempo total geração do pedido: " + AllTrim(Str(Seconds() - nSeconds) ) + " segundos.")
LjGrvLog("LJ7PEDIDO" , "ID_FIM")

Return lRet 

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³Lj7GeraSL ºAutor  ³Vendas Clientes     º Data ³  28/08/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Faz a gravacao dos arquivos                                 º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Loja701                                                     º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Lj7GeraSL( cAlias, aArray, lAppend, lUnlock )
Local cOldAlias := Alias()
Local lRet	    := .T.
Local nX        := 0

//Variaveis para o tratamento dos campos memo do projeto lista de presentes
Local nPosMsmLPre	:= 0	//Codigo da mensagem do Comprador
Local nPosMsgLPre	:= 0	//Mensagem do Comprador
Local nPosRemLPre	:= 0	//Codigo da mensagem do Remetente
Local nPosRevLPre	:= 0	//Mensagem do Remetente

//Variaveis para tratamento de Registro deletado no PAF-ECF
Local lDeleted  	:= .F. 													//Sinaliza que registro deverá ser gravado como deletado, exigência da legislação PAF-ECF
Local cPafMd5		:= ""													//Chave de Validação PAF-ECF
Local nPosPafMd5	:= 0													//Posicao do PAFMD5, somente possui conteudo quando armazenado no BD
Local lNfPafEcf	  	:= LjNfPafEcf(SM0->M0_CGC)								//Se habilitado CNPJ PAF-ECF

Default lAppend 	:= .F.
Default lUnlock 	:= .T.

DbSelectArea(cAlias)

//Variaveis para o tratamento dos campos memo do projeto lista de presentes
If cAlias == "SL2"
	nPosMsmLPre	:= aScan(aArray,{|x| Alltrim(x[1]) == "L2_MSMLPRE"})
	nPosMsgLPre	:= aScan(aArray,{|x| Alltrim(x[1]) == "L2_MSGLPRE"})
	nPosRemLPre	:= aScan(aArray,{|x| Alltrim(x[1]) == "L2_REMLPRE"})
	nPosRevLPre	:= aScan(aArray,{|x| Alltrim(x[1]) == "L2_REVLPRE"})
EndIf

Begin Transaction

lRet := RecLock(cAlias, lAppend)
If lRet
	For nX := 1 To Len(aArray)
		//As posicoes dos campos MEMO nao serao atualizados por aqui
   		If ((aArray[nX, 1]) <> REG_DELETED) .OR. !lNfPafEcf
			If nX <> nPosMsmLPre .AND. nX <> nPosMsgLPre .AND. nX <> nPosRemLPre .AND. nX <> nPosRevLPre
				&(aArray[nX, 1]) := aArray[nX, 2]
			EndIf
		Else
			lDeleted := .T.
		EndIf
	Next nX

	If cAlias == "SL1" 
		nPosSerie	:= aScan(aArray,{|x| Alltrim(x[1]) == "L1_SERIE"})	
		If nPosSerie > 0 
			SerieNfId("SL1",1,"L1_SERIE",dDataBase,LjEspecieNF(), aArray[nPosSerie, 2] )
		EndIf
	EndIf
	
	If cAlias == "SL2" 		
		nPosSerie	:= aScan(aArray,{|x| Alltrim(x[1]) == "L2_SERIE"})	
		If nPosSerie > 0 
			SerieNfId("SL2",1,"L2_SERIE",,,,SL1->L1_SERIE)			
		EndIf	
	EndIf

	//PAF-ECF: Grava deletado quando item tiver sido armazenado na base
	If lNfPafEcf
		If lDeleted

			If cAlias == "SL2"
				SL2->L2_VENDIDO := "N" //Sinaliza que item foi cancelado no momento que gerou o orçamento/dav
			EndIf

			DbDelete()
	    EndIf

	    //PAF-ECF: Gera chave de validação PAF, coloquei aqui para não precisar editar L1, o campo L1_VLRTOT só é atualizado nesse momento
	    If cAlias == "SL1"
	    	cPafMd5 		:= LjxPAFMD5(cAlias)
	    	SL1->L1_PAFMD5 	:= cPafMd5
	    ElseIf cAlias == "SL2"
	    	cPafMd5 		:= LjxPAFMD5(cAlias, SL1->L1_NUMORC)
	    	SL2->L2_PAFMD5 	:= cPafMd5
	    EndIf
	EndIf

	DbCommit()
	If lUnlock
		MsUnLock()
	EndIf
	//Atualiza os campos da mensagem do convidado
	If nPosMsmLPre > 0 .AND. nPosMsgLPre > 0
		//Caso a mensagem esteja em branco e o codigo preenchido exclui o SYP
		If Empty(aArray[nPosMsgLPre, 2]) .AND. !Empty(aArray[nPosMsmLPre,2])
			MSMM(SL2->L2_MSMLPRE,,,,2,,,"SL2","L2_MSMLPRE")
		ElseIf !Empty(aArray[nPosMsgLPre, 2])
			MSMM(SL2->L2_MSMLPRE,,,aArray[nPosMsgLPre, 2],1,,,"SL2","L2_MSMLPRE")
		EndIf
	EndIf

	//Atualiza os campos da mensagem do convidado
	If nPosRemLPre > 0 .AND. nPosRevLPre > 0
		//Caso a mensagem esteja em branco e o codigo preenchido exclui o SYP
		If Empty(aArray[nPosMsgLPre, 2]) .AND. !Empty(aArray[nPosMsmLPre,2])
			MSMM(SL2->L2_REMLPRE,,,,2,,,"SL2","L2_REMLPRE")
		ElseIf !Empty(aArray[nPosMsgLPre, 2])
			MSMM(SL2->L2_REMLPRE,,,aArray[nPosRevLPre, 2],1,,,"SL2","L2_REMLPRE")
		EndIf
	EndIf
EndIf

End Transaction

DbSelectArea(cOldAlias)
Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³Lj7GeraOrcºAutor  ³Vendas Clientes     º Data ³  24/09/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Monta os arrays para a gravacao do orcamento                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ExpA1 := LJ7GeraOrc( ExpA2 )                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ExpA1 - Array contendo:                                     º±±
±±º          ³        [1] - .T./.F. Se consegiu ou nao fazer a gravacao   º±±
±±º          ³        [2] - Numero do orcamento gerado                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpA2 - Array unidimensional contendo os numeros dos itens  º±±
±±º          ³        (L2_ITEM) que deverao gerar os orcamentos           º±±
±±º          ³        Exemplo: {01,02,04}                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºObservacao³O SL1 deve estar posicionado no orcamento pai (pedido)      º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³LJ7Pedido  (Loja701)                                        º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Lj7GeraOrc( aItens		, lJob		, aAuxaPgtos	, cEntrega	,;
					 lAlterOrc	, nFatorVen	, nFatorRes		, lLastOrc	,;
					 nCredito	, aSL4Total	)

Local aArea			:= Lj7GetArea({"SL1","SL2","SL4"})			// GetArea
Local aRet 			:= {}										// Array com retorno
Local aSL1			:= {}										// Campos SL1
Local aSL2			:= {}										// Campos SL2
Local aSL4			:= {}										// Campos SL4
Local aSL4Aux		:= {}										// Auxiliar para o array aSL4
Local nX 			:= 0										// Contador de For
Local nY			:= 0										// Contador de For
Local nVlrFSD		:= 0										// Valor
Local nVlrTotSl4	:= 0										// Valor total do SL4
Local nVlrOrcam 	:= 0 										// Valor do orcamento
Local nVlrOrcSFr	:= 0
Local nValMerc		:= 0										// Valor da Mercadoria
Local nValorTotal	:= 0										// Valor total
Local nVlrBrIcms	:= 0										// Valor ICM
Local nVlrIcmsRet	:= 0										// Valor retencao
Local nVlrTBrIcms	:= 0										// Valor total ICMS
Local nVlrTIcmsRet	:= 0										// Valor total retencao
Local nVlrIcms		:= 0										// ICMS
Local nVlrIpi		:= 0										// Valor IPI
Local nVlrIss		:= 0										// Valor ISS
Local nVlrDescPro	:= 0										// Valor produto
Local lGravaImps	:= .F.										// Grava imposto
Local cNumDoc	    := Space(TamSx3("L1_DOC")[1])				// L1_DOC
Local cNum 		    := Space(TamSx3("L1_NUM")[1])				// L1_NUM
Local cStatus	    := Space(TamSx3("L1_STATUS")[1])			// L1_STATUS
Local nAuxRotina	:= 0										// Rotina
Local nAuxNcc		:= 0										// NCC
Local nDecsAux		:= 2										// Numero de casas decimais
Local cMvSimb1		:= SuperGetMv("MV_SIMB1")	// Simbolo da moeda principal
Local nVlrFre		:= 0
Local nVlrSeg		:= 0
Local nVlrDes		:= 0
Local nVlrTotDes	:= 0         								// Valor total do desconto
Local aTesImpInf	:= {} 										//Dados da TES
Local nImp			:= 0                                        //Contador
Local lGE 			:= LjUP104OK()	 	// Validação do Conceito Garantia Estendida
//Tratamento para eCommerce
Local lECommerce	:= SuperGetMV("MV_LJECOMM",,.F.) .And. SL1->( ColumnPos("L1_ECFLAG") > 0 ) .And. (SL1->L1_ECFLAG == "1")
//Grava o valor do acrescimo separado da parcela
Local aIcmJr		:= {}
Local lVerEmpres    := Lj950Acres(SM0->M0_CGC)				    	// Verifica as filiais da trabalharam com acrescimento separado
Local nPropItem		:= 0												// Variavel que leva o fator da proporção do valor do item no total da venda.
Local nTotal		:= SL1->L1_VLRTOT + SL1->L1_FRETE + SL1->L1_SEGURO + SL1->L1_DESPESA	// Total da Venda
Local nTotSemFre	:= SL1->L1_VLRTOT 
Local nPosSL4		:= 0												// Posicao Forma de Pagamento
Local nTotOrc		:= 0	//Total do Orçamento/Venda a ser rateado
Local nTotSL4		:= 0	//Total dos Pagamentos
Local nDifSL4		:= 0	//Diferença entre Orçamento/Venda e pagamentos
Local lUseSAT 	    := IIF(ExistFunc("LjUseSat"),LjUseSat(),.F.)	//Utiliza SAT
Local nNccProp		:= 0    // Valor da NCC proporcional ao valor do orçamento filho
Local nValFSD       := SL1->L1_FRETE + SL1->L1_SEGURO + SL1->L1_DESPESA
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lEmitNfce		:= LjEmitNFCe()		// Sinaliza se utiliza NFC-e
Local nPropFSD		:= 0

Default lJob			:= .F.
Default aAuxaPgtos  	:= {}
Default cEntrega  		:= ""										//1=Retira Posterior / <branco> ou 2=Retira / 3=Entrega
Default lAlterOrc   	:= .F.
Default nFatorVen		:=	1 																			// Fator reserva
Default nFatorRes		:=	1 																			// Fator reserva
Default lLastOrc		:= .F.												// Flag ultimo Orcamento
Default nCredito		:= 0												// Totalizador Credito
Default aSL4Total		:= {}												// Totalizador Pagamentos

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Campo L2_ENTREGA vazio é item de Retira ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(cEntrega)
	cEntrega := "2"
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gera o array aSL1                                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SL1")
For nX := 1 to FCount()
	aAdd( aSL1, { Trim(FieldName(nX)), FieldGet(nX) } )
Next nX

aSL1[aScan(aSL1,{|x|x[1]=="L1_FILRES" })][2]	:= cFilAnt
aSL1[aScan(aSL1,{|x|x[1]=="L1_ORCRES" })][2]	:= SL1->L1_NUM
aSL1[aScan(aSL1,{|x|x[1]=="L1_NUM"    })][2]	:= cNum
aSL1[aScan(aSL1,{|x|x[1]=="L1_DINHEIR"})][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_CHEQUES"})][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_CARTAO" })][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_VLRDEBI"})][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_CONVENI"})][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_VALES"  })][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_FINANC" })][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_OUTROS" })][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_ENTRADA"})][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_DOCPED" })][2]	:= cNumDoc
aSL1[aScan(aSL1,{|x|x[1]=="L1_STATUS" })][2]	:= cStatus
If cEntrega <> "2"
	aSL1[aScan(aSL1,{|x|x[1]== "L1_DOC"		})][2]	:= cNumDoc
	If lEmitNFCe .Or. lIsPafNfce
		/* Limpamos o L1_SITUA, pois orcamentos filhos nao podem ser "T1" (gravacao do orcamento),
		pois eles somente sao gerados se a venda for finalizada com sucesso */
		aSL1[aScan(aSL1,{|x|x[1] == "L1_SITUA"})][2] := ""
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Quando carrega os dados para aSl1 os campos estao preenchidos             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lAlterOrc
	aSL1[aScan(aSL1,{|x|x[1]=="L1_PDV" })][2]	:= ""
	aSL1[aScan(aSL1,{|x|x[1]=="L1_OPERADO" })][2]	:= ""
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona o SL2 para gerar o array aSL2                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SL2")
SL2->(DbSetOrder(1))
For nX := 1 to Len( aItens )
	If SL2->(DbSeek(xFilial("SL2")+SL1->L1_NUM+aItens[nX]))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona o SF4                                                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SF4->(DbSetOrder(1))
		SF4->(DbSeek(xFilial("SF4")+SL2->L2_TES))

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Faz o tratamento dos campos do SL2                                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aAdd( aSL2, {} )
		For nY := 1 to FCount()
			aAdd( aSL2[Len(aSL2)], { FieldName(nY), FieldGet(nY) } )
		Next nY
		nVlrBrIcms 	+= SL2->L2_BRICMS
		// VerIfica se agrega solidario. (Se o valor do imposto incide ou nao no total da venda)
		If SF4->F4_INCSOL <> "N"
			nVlrTBrIcms 	+= SL2->L2_BRICMS
		EndIf
		nVlrIcmsRet	+= SL2->L2_ICMSRET
		// VerIfica se agrega solidario. (Se o valor do imposto incide ou nao no total da venda)
		If SF4->F4_INCSOL <> "N"
			nVlrTIcmsRet	+= SL2->L2_ICMSRET
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Acumula as variaveis para a gravacao do SL1                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nVlrIss		+= SL2->L2_VALISS
		nVlrIpi		+= SL2->L2_VALIPI
		nVlrIcms	+= SL2->L2_VALICM
		// Checa o SF4->F4_INCSOL - Agrega solidario (se inclui o valor do imp.solidario no total da venda)
		If SF4->F4_INCSOL <> "N"
			nVlrOrcam 	+= SL2->L2_VLRITEM + SL2->L2_ICMSRET
		Else
			nVlrOrcam 	+= SL2->L2_VLRITEM
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Release 11.5 - Localizacoes - F2CHI                   ³
		//³Somar o total de impostos quando for executado via Job³
		//³Paises: Chile / Colombia                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cPaisLoc$"CHI|COL" .AND. lJob
			nTotImpIt	:= 0
			aTesImpInf  := TesImpInf(SL2->L2_TES)
		   	For nImp := 1 to Len(aTesImpInf)
		    	If aTesImpInf[nX][3] == "1"  //Incide na NF
		     		nTotImpIt  += SL2->(FieldGet(ColumnPos("L2_"+Substr(aTesImpInf[nX][2],4,7))))
		      	EndIf
		   	Next nX
			nVlrOrcam 	+= nTotImpIt
		EndIf

		nValorTotal	+= SL2->L2_VLRITEM
		nValMerc	+= SL2->L2_PRCTAB * SL2->L2_QUANT
		nVlrDescPro	+= SL2->L2_DESCPRO
		nVlrFre		+= SL2->L2_VALFRE
		nVlrSeg		+= SL2->L2_SEGURO
		nVlrDes		+= SL2->L2_DESPESA

		//Vincula o item do pedido filho ao item do PAI
		aSL2[nX][aScan(aSL2[nX],{|x|x[1]=="L2_ITESC6"})][2]   := SL2->L2_ITEM
    EndIf
Next nX

LjGrvLog(SL1->L1_NUM,"LOGFRET - Total Frete+Seguro+Despesa",nVlrFre+nVlrSeg+nVlrDes)

If !lJob
	nVlrTotDes := nVlrDescPro
ElseIf  lECommerce
	nVlrDescPro := SL1->L1_DESCONT
	nVlrOrcam -= nVlrDescPro
EndIf

// Alterando os valores especIficos para a loja destino
If AllTrim(SL1->L1_TPFRET) $ "CF"  // CIF FOB
	nVlrFSD := IIf (!lMVLjPdvPa  .Or. lECommerce, nVlrFre + nVlrSeg + nVlrDes, SL1->L1_FRETE + SL1->L1_SEGURO + SL1->L1_DESPESA)
EndIf

aSL1[aScan(aSL1,{|x|x[1]=="L1_FILRES" })][2]	:= cFilAnt
aSL1[aScan(aSL1,{|x|x[1]=="L1_ORCRES" })][2]	:= SL1->L1_NUM
aSL1[aScan(aSL1,{|x|x[1]=="L1_NUM"    })][2]	:= Space(TamSx3("L1_NUM")[1])
aSL1[aScan(aSL1,{|x|x[1]=="L1_DINHEIR"})][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_CHEQUES"})][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_CARTAO" })][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_VLRDEBI"})][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_CONVENI"})][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_VALES"  })][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_FINANC" })][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_OUTROS" })][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_ENTRADA"})][2]	:= 0
aSL1[aScan(aSL1,{|x|x[1]=="L1_DESCONT"})][2]	:= nVlrDescPro
aSL1[aScan(aSL1,{|x|x[1]=="L1_FRETE" })][2]		:= nVlrFre
aSL1[aScan(aSL1,{|x|x[1]=="L1_SEGURO"})][2]		:= nVlrSeg
aSL1[aScan(aSL1,{|x|x[1]=="L1_DESPESA"})][2]	:= nVlrDes
		
If lJob
	nFatorVen := nVlrOrcam / SL1->L1_VLRLIQ
	nFatorRes := nVlrOrcam / SL1->L1_VLRLIQ

	nAuxRotina 	:= 3
	nDecsAux   	:= MsDecimais(1)
	aPgtos     	:= aClone(aAuxaPgtos)
	If !Empty(SL2->L2_ENTREGA) .And. AllTrim(SL2->L2_ENTREGA) $ "1|3"
		nAuxNcc	   := 	Round((SL1->L1_CREDITO * nFatorRes), nDecsAux )
	Else
		nAuxNcc	   := 	Round((SL1->L1_CREDITO * nFatorVen), nDecsAux )
	EndIf
	aSL1[aScan(aSL1,{|x|x[1]=="L1_CREDITO"})][2] := nAuxNcc
Else
	nAuxRotina	:= nRotina
	nAuxNcc		:= nNccUsada
	nDecsAux	:= nDecimais
EndIf

//Incrementa totalizador de credito para conferencia
nCredito += nAuxNcc

//Verifica se necessario arredondar Credito
If cPaisLoc == "BRA" .And. lJob .And. lLastOrc
	If SL1->L1_CREDITO > nCredito
		aSL1[aScan(aSL1,{|x|x[1]=="L1_CREDITO"})][2]	+= (SL1->L1_CREDITO - nCredito)
	ElseIf nCredito > SL1->L1_CREDITO
		aSL1[aScan(aSL1,{|x|x[1]=="L1_CREDITO"})][2]	-= (nCredito - SL1->L1_CREDITO)
	EndIf
EndIf

If cPaisLoc <> "BRA" .AND. !(nAuxRotina == 4 .AND. !Empty(SL1->L1_ORCRES)) .And. MaFisFound("NF") 
	aSL1[aScan(aSL1,{|x|x[1]=="L1_VLRTOT" })][2]	:=	If(!lJob,( MaFisRet(,"NF_TOTAL") - Lj7T_DescV(2) - nVlrFSD) ,SL1->L1_VLRTOT)
	aSL1[aScan(aSL1,{|x|x[1]=="L1_VALBRUT"})][2]	:=	If(!lJob,( MaFisRet(,"NF_TOTAL") - Lj7T_DescV(2) - nVlrFSD ),SL1->L1_VALBRUT)
	aSL1[aScan(aSL1,{|x|x[1]=="L1_VLRLIQ" })][2]	:=  If(!lJob,nValorTotal + nVlrFSD - nVlrTotDes + nVlrTIcmsRet,SL1->L1_VLRLIQ)
	lGravaImps := .T.
EndIf

If cPaisLoc = "BRA"
	aSL1[aScan(aSL1,{|x|x[1]=="L1_VLRTOT" })][2]	:= nValorTotal + nVlrTIcmsRet + nVlrIpi
	aSL1[aScan(aSL1,{|x|x[1]=="L1_VLRLIQ" })][2]	:= nValorTotal + nVlrFSD + nVlrTIcmsRet + nVlrIpi
	aSL1[aScan(aSL1,{|x|x[1]=="L1_VALBRUT"})][2]	:= nValorTotal + nVlrFSD + nVlrTIcmsRet + nVlrIpi
Endif

aSL1[aScan(aSL1,{|x|x[1]=="L1_VALMERC"})][2]	:= nValMerc
aSL1[aScan(aSL1,{|x|x[1]=="L1_VALICM" })][2]	:= nVlrIcms
aSL1[aScan(aSL1,{|x|x[1]=="L1_VALIPI" })][2]	:= nVlrIpi
aSL1[aScan(aSL1,{|x|x[1]=="L1_VALISS" })][2] 	:= nVlrIss
aSL1[aScan(aSL1,{|x|x[1]=="L1_BRICMS" })][2] 	:= nVlrBrIcms
aSL1[aScan(aSL1,{|x|x[1]=="L1_ICMSRET"})][2] 	:= nVlrIcmsRet

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Alterando os valores especIficos para a loja destino                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := 1 to Len( aSL2 )
	aSL2[nX][aScan(aSL2[nX],{|x|x[1]=="L2_NUM"})][2]    := Space(TamSx3("L2_NUM")[1])
	aSL2[nX][aScan(aSL2[nX],{|x|x[1]=="L2_ITEM"})][2]   := FR271BPegaIT(nX)
	aSL2[nX][aScan(aSL2[nX],{|x|x[1]=="L2_LOJARES"})][2]:= Space(TamSx3("L2_LOJARES")[1])
Next nX

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta o array aSL4  /  Faz o rateio dos valores das parcelas             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SL4")
SL4->(DbSetOrder(1))
SL4->(DbSeek(xFilial("SL4")+SL1->L1_NUM))
While !SL4->(Eof()) .AND. SL4->L4_FILIAL+SL4->L4_NUM  == xFilial("SL4")+SL1->L1_NUM .AND. Empty(SL4->L4_ORIGEM)
	Aadd(aSL4Aux , Array(6) )
	nX	:= Len(aSL4Aux)
	aSL4Aux[nX][1] := SL4->L4_DATA
	aSL4Aux[nX][2] := SL4->L4_VALOR
	aSL4Aux[nX][3] := SL4->L4_FORMA
	aSL4Aux[nX][4] := 0 
	aSL4Aux[nX][5] := 0

	If cPaisLoc == "BRA"
		aSL4Aux[nX][6] := NIL
		
		//Armazena array totalizador
		If lJob
			If aScan(aSL4Total, {|x| x[1] == SL4->L4_FORMA}) == 0
				aAdd(aSL4Total, {SL4->L4_FORMA, SL4->L4_VALOR, 0})
			EndIf
		EndIf
	Else
		aSL4Aux[nX][6] := SL4->L4_MOEDA
	EndIf

	//Grava o valor do acrescimo separado da parcela
	If (lVerEmpres .OR. (SuperGetMV("MV_LJICMJR",,.F.) .AND. cPaisLoc == "BRA"))
		aAdd(aIcmJr ,{ "L4_ACRSFIN", SL4->L4_ACRSFIN})
	Endif

	nVlrTotSl4 += SL4->L4_VALOR
	SL4->(DbSkip())
End

nVlrOrcSFr := nVlrOrcam

// Adiciona o valor do frete para a correta impressao do cupom fiscal quando for venda com Retira e Reserva e não for PDVPAF
nVlrOrcam += IIf ((!lMVLjPdvPa .AND. !lJob)  .Or. lECommerce, nVlrFSD,0)

//Variavel que leva o fator da proporção do valor do item no total da venda.
nPropItem := (SL2->L2_VLRITEM + SL2->(L2_VALFRE+L2_SEGURO+L2_DESPESA)/SL1->L1_VLRTOT)

// Adiciona o valor do frete para a correta impressao do cupom fiscal quando for venda com Retira e Reserva vindo do Front
If lJob 
	If (SL2->L2_ENTREGA $ "1|3") //Esses tipos de entrega devem conter valor de FSD
		nVlrOrcam += (nVlrFre + nVlrSeg + nVlrDes)
	EndIf
Else
	//Calcula o Total da Venda para calcular arredondamento
	If !lGravaImps
		nTotOrc := nVlrOrcam  //Total do Orçamento/Venda a ser rateado
	Else
		nTotOrc := MaFisRet(,"NF_TOTAL")
	EndIf
	
    /* Para o calculo do rateio da NCC não considero o valor 
    de FSD senão o rateio sai errado nos filhos da reserva */
	nNccProp := Round((nAuxNcc / nTotSemFre) * nVlrOrcSFr , nDecsAux )		
EndIf

// Proporcionaliza os valores
For nX := 1 to Len(aSL4Aux)
	If !lJob
		
		If cEntrega $ "1|3"
			aSL4Aux[nX][4] := NoRound( aSL4Aux[nX][2] / nTotal, 18 ) 		// FATOR DA FORMA DE PAGAMENTO
		Else
			nPropFSD := NoRound(nValFSD / Len(aSL4Aux) , 18) 				//Valor de Frete em cada Parcela
			nPropFSD := nPropFSD / aSL4Aux[nX][2]
			nPropFSD := aSL4Aux[nX][2] * nPropFSD
			aSL4Aux[nX][2] := aSL4Aux[nX][2] - nPropFSD 					//removo o percentual de frete de cada parcela
			aSL4Aux[nX][4] := NoRound( aSL4Aux[nX][2] / nTotSemFre, 18 )	// FATOR DA FORMA DE PAGAMENTO
		EndIf
		
		If !lGravaImps
			If cEntrega $ "1|3"
				aSL4Aux[nX][5] := Round( nVlrOrcam * aSL4Aux[nX][4], nDecsAux )
			Else
				aSL4Aux[nX][5] := Round( nVlrOrcSFr * aSL4Aux[nX][4], nDecsAux )
			EndIf
		Else
			aSL4Aux[nX][5] := NoRound( MaFisRet(,"NF_TOTAL") * aSL4Aux[nX][4], nDecsAux )
		EndIf
		nTotSL4 += aSL4Aux[nX][5]//Sumariza o Total dos Pagamentos
	Else
		// Caso venha do Front
		If !lGravaImps
			//Recalcula Fatores do Orcamento novamente
			nFatorVen := nVlrOrcam / SL1->L1_VLRLIQ 
			nFatorRes := nVlrOrcam / SL1->L1_VLRLIQ 

			If !Empty(SL2->L2_ENTREGA) .And. AllTrim(SL2->L2_ENTREGA) $ "1|3"
				aSL4Aux[nX][5] := Round( aSL4Aux[nX][2] * nFatorRes, nDecsAux )
			Else
				aSL4Aux[nX][5] := Round( aSL4Aux[nX][2] * nFatorVen, nDecsAux )
			EndIf

			//Incrementa totalizador
			If cPaisLoc == "BRA" .And. lJob
				nPosSL4 := aScan(aSL4Total,{|x| x[1] == aSL4Aux[nX][3]})

				If nPosSL4 > 0
					aSL4Total[nPosSL4][3] += Round( aSL4Aux[nX][2] * nFatorRes, nDecsAux )
				EndIf
			EndIf
		Else
			aSL4Aux[nX][5] := NoRound( MaFisRet(,"NF_TOTAL") * aSL4Aux[nX][4], nDecsAux )
		EndIf
	EndIf
Next nX

/* Para calcular a diferença de valores com NCC não posso
considerar o valor contendo frete, pois a ncc foi calculada 
sem incluir valor de FSD */
If !lJob .And. !(cEntrega $ "1|3")
	nTotOrc :=	nVlrOrcSFr
EndIf 

If nTotOrc > nNccProp  // Caso a NCC seja maior que a venda não deve haver calculo de diferenca
	//Verifica se eh necessario fazer arredondamento
	If cPaisLoc == "BRA" .And. lJob .And. lLastOrc
		For nX := 1 To Len(aSL4Total)
			If aSL4Total[nX][2] > aSL4Total[nX][3]
				aSL4Aux[nX][5] += aSL4Total[nX][2] - aSL4Total[nX][3]
			ElseIf aSL4Total[nX][3] > aSL4Total[nX][2]
				If aSL4Aux[nX][5] > ( aSL4Total[nX][3] - aSL4Total[nX][2] ) //Tratamento para não gerar valor negativo
					aSL4Aux[nX][5] -= aSL4Total[nX][3] - aSL4Total[nX][2]
				EndIf
			EndIf
		Next nX
	ElseIf !lJob .AND. ABS( nTotOrc - (nTotSL4 + nNccProp) ) >= (1/(10**nDecsAux)) //Arredondamento para Venda Assistida
		nX := Len(aSL4Aux)
		nDifSL4 := nTotOrc - nTotSL4 - nNccProp
		//Verifica uma parcela válida para lançar diferença se for desconto
		If  nDifSL4 < 0
			Do While nX >= 1
					nDifSL4 := nTotOrc - nTotSL4 - nNccProp
					If !lGravaImps .and. aSL4Aux[nX][5] > Abs( Round(nDifSL4, nDecsAux  ))
						Exit
					ElseIf aSL4Aux[nX][5] > Abs( NoRound( nDifSL4, nDecsAux ) )
						Exit
					EndIf
				nX--
			EndDo
		EndIf

		If nX < 1  //Caso não atenda nenhuma das condiçoes acima jogo a diferenca na ultima parcela.
			nX := Len(aSL4Aux) 
		EndIf

		If !lGravaImps
			aSL4Aux[nX][5] += Round( nDifSL4, nDecsAux )
		Else
			aSL4Aux[nX][5] += NoRound( nDifSL4, nDecsAux )
		EndIf
	EndIf	
EndIf 

If nTotOrc  < nNccProp  // Caso a NCC seja maior que os valor dos itens O Valor a ser gravado devera ser o valor dos itens para nao gerar erro no NFCE
	nNccProp := nTotOrc 
EndIf

// Grava os valores do aSL4
If Len(aSL4Aux) > 0
	For nX := 1 to Len(aSL4Aux)
		aAdd( aSL4, {} )
		aAdd( aSL4[Len(aSL4)], { "L4_FILIAL"  ,xFilial("SL4") } )
		aAdd( aSL4[Len(aSL4)], { "L4_DATA"    ,aSL4Aux[nX][1] } )
		aAdd( aSL4[Len(aSL4)], { "L4_VALOR"   ,aSL4Aux[nX][5] } )
		aAdd( aSL4[Len(aSL4)], { "L4_FORMA"   ,aSL4Aux[nX][3] } )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Faz a gravacao desses campos direto do aPgtos pois a funcao Lj7GeraOrc   ³
		//³ foi chamada antes da gravação desses campos no SL4                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !IsMoney(aPgtos[Len(aSL4)][3])
			If Trim(aPgtos[Len(aSL4)][3]) == "CH"
				aAdd( aSL4[Len(aSL4)], { "L4_ADMINIS"	, aPgtos[Len(aSL4)][4][04] } )
				aAdd( aSL4[Len(aSL4)], { "L4_NUMCART"	, aPgtos[Len(aSL4)][4][07] } )
				aAdd( aSL4[Len(aSL4)], { "L4_AGENCIA"	, aPgtos[Len(aSL4)][4][05] } )
				aAdd( aSL4[Len(aSL4)], { "L4_CONTA"		, aPgtos[Len(aSL4)][4][06] } )
				aAdd( aSL4[Len(aSL4)], { "L4_RG"		, aPgtos[Len(aSL4)][4][09] } )
				aAdd( aSL4[Len(aSL4)], { "L4_TELEFON"	, aPgtos[Len(aSL4)][4][10] } )
				aAdd( aSL4[Len(aSL4)], { "L4_COMP"		, aPgtos[Len(aSL4)][4][08] } )
				aAdd( aSL4[Len(aSL4)], { "L4_TERCEIR"	, aPgtos[Len(aSL4)][4][12] } )
				aAdd( aSL4[Len(aSL4)], { "L4_NOMECLI"	, aPgtos[Len(aSL4)][4][14] } )
			Else
				If Len(aPgtos[Len(aSL4)][4]) >= 5
					aAdd( aSL4[Len(aSL4)], { "L4_ADMINIS"	, aPgtos[Len(aSL4)][4][05] } )
					aAdd( aSL4[Len(aSL4)], { "L4_NUMCART"	, aPgtos[Len(aSL4)][4][04] } )
				EndIf
			EndIf
		EndIf
		If cPaisLoc <> "BRA"
		   aAdd( aSL4[Len(aSL4)], { "L4_MOEDA"   ,aSL4Aux[nX][_MOEDA] } )
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Grava o valor do acrescimo separado da parcela ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (lVerEmpres .OR. (SuperGetMV("MV_LJICMJR",,.F.) .AND. cPaisLoc == "BRA"))
			aAdd( aSL4[Len(aSL4)], aIcmJr[nX] )
		EndIf

	Next nX
Else
	aAdd( aSL4, {} )
	aAdd( aSL4[Len(aSL4)], { "L4_FILIAL"  ,xFilial("SL4") } )
	aAdd( aSL4[Len(aSL4)], { "L4_DATA"    ,dDataBase } )
	aAdd( aSL4[Len(aSL4)], { "L4_VALOR"   ,0 } )
	aAdd( aSL4[Len(aSL4)], { "L4_FORMA"   ,cMVSimb1 } )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Limpa DAV de orçamento filho  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lJob .AND. SL1->(ColumnPos("L1_NUMORC")) > 0
	aSL1[aScan(aSL1,{|x|x[1]=="L1_NUMORC"})][2] := ''
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ gravação do valor de credito proporcionalizado  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lJob .AND. SL1->(ColumnPos("L1_CREDITO")) > 0
	aSL1[aScan(aSL1,{|x|x[1]=="L1_CREDITO"})][2] := nNccProp
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta array de retorno      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aRet := { aSL1, aSL2, aSL4 }

Lj7RestArea( aArea )
Return aRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³ Funo    ³ LJ701AtCartao ³ Autor ³Vendas Clientes³ Data ³ 15/06/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descrio ³ Atualiza a descrição da administradora de cartões em uma  ³±±
±±³           ³ transação TEF quando é selecionado um cartão e passado    ³±±
±±³           ³ outro.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso       ³ Venda Assistida.                                          ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function LJ701AtCartao()
Local nI 	  		:= 0		//controle de loop
Local cCartao 		:= ""
Local lFound  		:= .F.
Local xRet			:= Nil
Local lRetLJ7022 	:= .F.
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida

//-- Se o array aTefMult for maior que zero não preciso fazer a alteração por aqui, pois será feito na gravação do SL4.
If Len(aTefMult) > 0
	Return .T.
EndIf

For nI := 1 To Len(aPgtos)
	If !lFtvdVer12
		If ExistBlock("LJ7022")
			lRetLJ7022 := .F.
			xRet := ExecBlock("LJ7022", .F., .F.)
			If ValType(xRet) == "L"
				lRetLJ7022 := xRet
			ElseIf ValType(xRet) == "A"
				lRetLJ7022 := xRet[1]
			EndIf
		EndIf
		If Alltrim(aPgtos[nI,03]) $ _FORMATEF .AND. ! ( If( lRetLJ7022, ;
		                                                  Upper(Alltrim(aTefDados[01,08])) $ Upper(Alltrim(SubStr(aPgtos[nI,04,05], 7))), ;
		                                                  Upper(Alltrim(SubStr(aPgtos[nI,04,05], 7))) == Upper(Alltrim(aTefDados[01,08])) ) )

			cCartao := aPgtos[nI,04,05]
			lFound  := .T.
			Exit
		EndIf
	ElseIf lFtvdVer12
		If Alltrim(aPgtos[nI,03]) $ _FORMATEF .AND. ! ( If( ExistBlock("FTVD7022") .AND. ExecBlock("FTVD7022", .F., .F.), ;
	                                                  Upper(Alltrim(aTefDados[01,08])) $ Upper(Alltrim(SubStr(aPgtos[nI,04,05], 7))), ;
	                                                  Upper(Alltrim(SubStr(aPgtos[nI,04,05], 7))) == Upper(Alltrim(aTefDados[01,08])) ) )

			cCartao := aPgtos[nI,04,05]
			lFound  := .T.
			Exit
		EndIf

	EndIf
Next nI

If lFound
	SAE->(DbSetOrder(1))
	SAE->(DbSeek(xFilial("SAE")))
	While ! SAE->(EOF())
		If Upper(Alltrim(aTefDados[01,08])) == Upper(Alltrim(Left(SAE->AE_DESC, 16)))
			Exit
		EndIf
		SAE->(DbSkip())
	End

	If ! SAE->(EOF())
		aEval(aPgtos, { |x| If( x[03] $ _FORMATEF .AND. x[04,05] == cCartao, ;
		                         x[04,05] := SAE->AE_COD + " - " + SAE->AE_DESC, .T. ) })
	EndIf
EndIf

Return .T.

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³Lj7RecTribºAutor  ³Vendas Clientes     º Data ³  10/21/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Recalculo dos valores totais para atualizacao do orcamento  º±±
±±º          ³e rateio dos itens                                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºOBSERVACAO³Devido a essa funcao ser chamada para recalculo dos orcamen-º±±
±±ºIMPORTANTE³tos que sao finalizados pela funcao "Finaliza Venda" e tam- º±±
±±º          ³bem pela funcao que finaliza os orcamentos gerados pela     º±±
±±º          ³rotina de reservas/pedido, os valores como totais, descontosº±±
±±º          ³acrescimos, devem sempre ser lidos dos arquivos e nao da    º±±
±±º          ³memoria.                                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP7                                                        º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Lj7RecTrib( aVlrAcres	, nDescTotal, nFreDesSeg, cLQFrete	,;
							lJob		, lEmiteNf	, nVlrAcrsFi, aAcrFin	,;
							nValRes  	, nDescontFi, nOpc      , aTaxJuros	,;
							nTotICM	, aDadosCNeg,	nTotImpNCM , 	 nTotVLRNCM , ;
							nTotImpFED	, nTotImpEST,	nTotImpMUN)

Local nVlrDescTot  	:= nDescTotal								// Valor total do desconto
Local nVlrSubTot   	:= 0                                     	// Valor do Subtotal
Local lCondNeg     	:= ( Trim( SL1->L1_CONDPG ) == "CN" )    	// VerIfica se eh condicao negociada
Local nPos         	:= 0                                	    // Posicao do produto nos itens do MatxFis
Local nPerDescFin  	:= 0                                     	// Percentual do desconto financeiro
Local nPerAcrs  	:= 0                                     	// Percentual do acrescimo financeiro
Local nPercProduto 	:= 0                                     	// Valor em percentual do produto sobre o valor total
Local nVlrNegoc    	:= 0                                     	// Valor da taxa - condicao negociada
Local nVlUnit      	:= 0					                    // Valor do Item
Local nAcumVlRat   	:= 0                                	    // Valor acumulado do desconto para que seja
Local nVlrTot 	   	:= 0										// Valor total da venda
Local nSomItens    	:= 0										// Valor da soma dos itens para possiveis rateios
Local aSL1 			:= {}										// Array para gravar as informacoes no SL1
Local aItens		:= {}										// Array auxiliar para controlar os arredondamentos
Local nVlrNCCUnit	:= 0										// Valor da NCC "por item"
Local nVlrDesc		:= 0 										// Valor referente ao desconto financeiro
Local nVlrAcrs		:= 0 										// Valor referente ao acrescimo financeiro
Local nVlrIPI		:= 0										// Valor referente ao IPI
Local nValIPI		:= 0										// Valida IPI
Local nDescTot		:= 0										// Valor do Desconto Total
Local nDescItens	:= 0										// Soma os descontos aplicados nos itens
Local nAuxVlrTot	:= 0										// Variavel auxiliar para o Valor Total
Local nDesct		:= 0										// Acumula desconto proporcional para testar arredondamento
Local nDIfDesc		:= 0										// DIferenca do desconto proporcional
Local nDecVrUnit 	:= TamSx3("L2_VRUNIT")[2]					// Qde de casas decimais no campo L2_VRUNIT
Local nItens		:= 0										// Quantidade de Itens para Rateio
Local nQtdItens		:= 0										// Quantidade de Itens da Venda
Local lPremio       := .F.										// Informa se o item do orcamento faz parte de algum tipo de bonIficacao
Local lDescPg		:= Val(SL1->L1_TIPODES) == 1				// Se o Desconto foi aplicado antes da Condicao de Pgto.
Local nAuxNcc		:= 0										// NCC
Local nDecsAux		:= 2										// Numero de casas decimais
Local lCalcFin		:= (SuperGetMv("MV_CALCFIN",,"M")== "F")  	// Variavel para controle do parametro MV_CALCFIN = [F]inanciado
Local lAtuDesc		:= .T.                                      // Atauliza o valor do desconto
Local nTotItens     := 0										// Valor total dos itens
Local nSomaAux		:= 0 										// soma do acrescimo rateado
Local nVlrSomAcr	:= 0
Local nVrSomIt		:= 0
Local nMvLjTpDes	:= SuperGetMv( "MV_LJTPDES", , 0 )
Local lVerEmpres    := Lj950Acres(SM0->M0_CGC)					// Verifica as filiais da trabalharam com acrescimento separado
Local nSomAcrRnd	:= 0										// Soma acresimos arredondados
Local nSomItRnd		:= 0										// Soma itens arredondados
Local nAcrDifere	:= 0										// Diferenca dos arredondamentos do acrescimo (nSomaAux - nSomAcrRnd)
Local nItDifere		:= 0 										// Diferenca dos arredondamentos dos itens (LJ7Total() - nSomItRnd)
Local lDistrPrCi	:= .F.										// Define o modo de distribuicao da diferença nas parcelas - de cima para baixo ou ao contrario
Local lOrcFilVen   	:= .F.										// Define se o orcamento for RETIRA mas foi gerado de um orçamento PAI contendo RESERVA e RETIRA
Local nDesFinDif    := 0                                        // Diferenca no valor do desconto financeiro
Local nSomDesFin    := 0                                        // Soma do desconto financeiro
Local lVAssConc		:= LjVassConc()								// Indica se o cliente utiliza a Vda Assistida Concomitante
Local nValSol		:= 0										// Guarda o valor do ICMS ST do item
Local lCpoTotImp	:= SL2->(ColumnPos("L2_TOTIMP")) > 0        // Verifica a existencia do campo de Total de Imposto NCM/NBS
Local lCpoImpEnt	:=	.F.									       // Verifica a existencia dos campos de Impostos por Ente de Tributacao, lei 12741 lei dos impostos
Local lCpoAliqImp 	:= SB1->(ColumnPos("B1_IMPNCM")) > 0        // Verifica a existencia do campo de Aliq. de Imposto NCM/NBS
Local lCpoAliqSBZ 	:= SBZ->(ColumnPos("BZ_IMPNCM")) > 0        // Verifica a existencia do campo de Aliq. de Imposto NCM/NBS
Local lBImport		:= .F.
Local xB1ImpNcm		:= Nil 		   							   // variavel que controla o retorno da função AlqLei2741
Local aAlqLeiTr		:= {}  		       							   // array com valores da  aliquota retornado pela função fiscal (Lei transparência) 1-Aliq Total|2-Aliq Federal|3-Aliq Estadual|4-Aliq Municipal
Local aArea			:= {}
Local aGrupTrib		:= {} 										// Array para o grupo de tributação caso lHabNovoArred = .T.
Local lEmitNfce		:= LjEmitNFCe()		// Sinaliza se utiliza NFC-e
Local lHabNovoArred := If(!lJob .AND. !lEmitNfce,GetPvProfString("Arredondamento","Habilita","0",GetClientDir() + "SIGALOJA.INI") == "1", .F.) //Verifica se utiliza o novo arredondamento
Local lValIgual		:= .T.
Local nPercTotal	:= 0                                        //Percentual total do desconto
Local nVlrDescFi	:= 0										//Percentual do desconto financeiro
Local nDiferencaIt  := 0                                        //Diferença do item
Local nDescItem 	:= 0 										//Desconto do item
Local nVlrItem 		:= 0										//Valor do Item
Local nPosAux 		:= 0
Local nDifGrupo 	:= 0
Local nMaior 		:= 0
Local nValMaior		:= 0
Local nBasMAliq 	:= 0
Local nTotAliqs		:= 0
Local nAliquota		:= 0
Local nAliqRed		:= 0
Local cSitTrib		:= ""
Local cTpSolCf 		:= ""
Local lBuscaImp		:=  ExistFunc("lj7BuscaImp")
Local lAlqLei2741	:=  ExistFunc("AlqLei2741")
Local cMvFisCTrb	:= SuperGetMV("MV_FISCTRB",,"1")              // Define se é tipo GE
Local cMvFisAlCT	:= SuperGetMV("MV_FISALCT",,"3")              // Define se é tipo GE
Local lMvFisFRas	:= SuperGetMV("MV_FISFRAS",,"T")              // Define se é tipo GE
Local nNewTotIcm	:= 0
Local nRestAcres	:= 0
Local nDifAcres		:= 0
Local nItem			:= 0
Local lGE			:= LjUP104OK()	// Validação do Conceito Garantia Estendida
Local cCodProGar	:= ""                                           // Produto Garantia
Local nVlrGar 		:= 0                                  			// Valor da garantia
Local cMvLjTGar		:= SuperGetMV("MV_LJTPGAR",,"GE")              // Define se é tipo GE
Local lEntrega		:= .F.											// verifica se a venda tem alguma entrega
Local nVlrEntIt		:= 0											// valor do acrescimo por item
Local nDifValSol	:= 0											// diff do ICMS Solidario, quando ha alteracao na BC (acrescimo ou desconto)
Local nTotValSol	:= 0											// usado no calculo de diferenca da venda abaixo (nItDifere)
Local nAuxJur		:= 0											// valor auxiliar para calculo de juros
Local lMvLjJurCc	:= .F.											// Verifica se o juros da administradora esta ativo
Local cFilReserva	:= ''											//Filial de reserva, quando utilizado reserva em outra filial
Local nL1VALBRUT 	:= 0
Local nNFTotal		:= 0
Local nLj7TDescV	:= 0
Local lMaSUFRAMA	:= .F.
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento para eCommerce       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lECommerce 	:= SuperGetMV("MV_LJECOMM",,.F.) .And. SL1->( ColumnPos("L1_ECFLAG") > 0 ) .And. (SL1->L1_ECFLAG == "1")
Local cNumLote		:= ""                                           //LR_NRLOTE
Local cLoteCtl      := ""	                                        //LR_LOTECTL
Local nVlAcresUnit  := 0 										    // Valor de acrescimo financeiro por unidade do item .
Local nCent			:= 0.01
Local nCount		:= 0
Local lTemArred		:= .F.
Local lRatFrete		:= .F.											// Indica se há rateio de frete (somente nos casos de L2_ENTREGA ser 1,3
Local nLastDesp := 0 //Ultimo registro de despesas
Local nFreteSl2 := 0	//Frete SL2
Local nSegurSl2 := 0	//Seguro SL2
Local nDespeSl2 := 0 //Despesa SL2		
Local nTotFrete := 0 //Totalizador frete
Local nTotSegur := 0 //Totalizador seguro
Local nTotDespe := 0 //Totalizador despesa
Local nQtdEntre := 0 //Quantidade entrega
Local nBaseAcr	:= 0	//indica o valor base para calculo do acréscimo financeiro
Local lIntegDef	:= If(Type("lAutoExec") == "L", lAutoExec, .F.) .And. FWHasEAI("LOJA701",, .T., .T.) .AND. IIF( ExistFunc("Lj701GtInD") , Lj701GtInD(), IsInCallStack("LOJI701"))  //Integracao via Mensagem Unica
Local nPosTotFed	:= 0 //Posicao do campos Imposto Federal - Lei da Transparencia
Local nPosTotEst	:= 0 //Posicao do campos Imposto Estadual - Lei da Transparencia
Local nPosTotMun	:= 0 //Posicao do campos Imposto Municipal - Lei da Transparencia
Local nValAcrs    	:= 0 //Valor do Acrescimo financeiro
Local lFisFound 	:= MaFisFound("NF")
Local nAcresProp    := 0
Local lUseSAT 		:= IIF(ExistFunc("LjUseSat"), LjUseSat(), .F.)
Local nDescPropT    := 0 //Valor total do desconto proporcionalizado
Local nAItValIpi	:= 0
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local lL2FECP		:= SL2->(ColumnPos("L2_ALQFECP") > 0 .AND. ColumnPos("L2_VALFECP") > 0)
Local lL2FECPST     := SL2->(ColumnPos("L2_ALQFCST") > 0 .AND. ColumnPos("L2_VFECPST") > 0)

Default aVlrAcres	:= {}											// Devera conter o valor do acrescimo por item (proporcionalizado)
Default cLQFrete	:= ""											// Recebe conteudo do campo LQ_TPFRETE 1- CIf 2- FOB
Default nFreDesSeg	:= 0											// Frete + Seguro + Despesas
Default lJob		:= .F.
Default lEmiteNF	:= Iif(lFtvdVer12,.T.,.F.)						// Se esta emitando nota ou cupom
Default nVlrAcrsFi  := 0 											// variavel para calculo de juros sobre valor financiado
Default aAcrFin		:= {}											// array para calculo de juros sobre valor financiado proporcional ao item
Default nValRes 	:= 0
Default nDescontFi 	:= 0
Default nOpc		:= 0											// Tipo de operacao
Default aTaxJuros	:= {0,0,0,0}									//Recebe a porcentagem de juros da administradora
Default nTotICM		:= 0
Default aDadosCNeg	:= {}
DEFAULT nTotImpNCM	:= 0
DEFAULT nTotImpFED	:= 0
DEFAULT nTotImpEST	:= 0
DEFAULT nTotImpMUN	:= 0
DEFAULT nTotVLRNCM 	:= 0

lCpoImpEnt := SL2->(FieldPos("L2_TOTFED")) > 0 .AND. ;
				SL2->(FieldPos("L2_TOTEST")) > 0 .AND. ;
				SL2->(FieldPos("L2_TOTMUN")) > 0       // Verifica a existencia do campo de Total de Imposto NCM/NBS

//Valida se pode usa Taxa Administrativa por Cartão de Crédito
If SuperGetMv("MV_LJJURCC",NIL,.F.) .AND. (aTaxJuros[1] > 0)
	lMvLjJurCc := .T.
EndIf

If Type("nNccUsada") <> "N"
	nNccUsada := 0
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciono os registros e faco o calculo do acrescimo/desconto para     ³
//³a condicao de pagamento selecionada ou acrecimo                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lCondNeg
	DbSelectArea( "SE4" )
	SE4->(DbSetOrder( 1 ))
	SE4->(DbSeek( xFilial( "SE4" ) + SL1->L1_CONDPG ))

	nPerDescFin	:= E4_DESCFIN                                    	//Valor do desconto financeiro
	nPerAcrs   	:= E4_ACRSFIN                                    	//Valor do acrescimo financeiro
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ VerIfica se houve acrescimo por fator financeiro ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SL1->L1_FATOR > 0
		nPerAcrs := ((SL1->L1_FATOR - 1) * 100)
		If nPerAcrs < 0
			nPerAcrs := 0
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se trabalhar com o conceito de acrescimo separado, ³
	//³nao grava o acrescimo no valor do cupom, pois o    ³
	//³mesmo sera gravado no Contas a receber (SE1)       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lVerEmpres .OR. !ChkIncICMS()
		nPerAcrs := 0
	Endif

	//Realiza o calculo do valor do desconto Financeiro, caso existir desconto na condicao de pagamento e o valor ainda nao estiver calculado "nDescontFi"
	//Calcula o valor do Desconto Financeiro, baseando-se no percentual.
	If nPerDescFin > 0 .And. nDescontFi == 0 .And. lFisFound
		nNFTOTAL := MaFisRet(,"NF_TOTAL")
		
		If !lJob
			nLj7TDescV := iif(ExistFunc("LjNewCalSol") .And. LjNewCalSol(),0,Lj7T_DescV(2))
		Else
			nLj7TDescV := iif(ExistFunc("LjNewCalSol") .And. LjNewCalSol(),0,SL1->L1_DESCONT)
		EndIf
	
		If nMvLjTpDes <> 2
            If nNccUsada <= (nNFTOTAL - nLj7TDescV)
                nDescontFi := NoRound( ( ( nNFTOTAL - nLj7TDescV ) * nPerDescFin) / 100, nDecVrUnit )
            EndIf
		Else
          	If nNccUsada <= (nNFTOTAL - nLj7TDescV)
          		nDescontFi := A410Arred( ( ( nNFTOTAL - nLj7TDescV - nNccUsada ) * nPerDescFin) / 100, "D2_DESCON" )
          	EndIf
        EndIf
	EndIf
Else
	nPerAcrs	:= SL1->L1_JUROS
		If !ChkIncICMS()
			nPerAcrs	:= 0
	EndIf
EndIf

If nDescTotal == Nil
	If !lJob
		nVlrDescTot := IIf(lVAssConc, SL1->L1_DESCONT - nDescontFi, Lj7T_DescV(2))
	ElseIf lECommerce
		nVlrDescTot := IIf(lVAssConc, SL1->L1_DESCONT - nDescontFi, 0)
	Else
		nVlrDescTot := SL1->L1_DESCONT - nDescontFi
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Pega o valor total da venda                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nOpc == 4
	nVlrTot	:= If(!lJob,Round(Lj7T_Total( 2 )-nDescontFi, nDecimais),SL1->L1_VLRTOT)
Else
	nVlrTot	:= If(!lJob,Round(Lj7T_Total( 2 ), nDecimais),SL1->L1_VLRTOT)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Retiro o SubTotal da Venda. Se for finalizacao da venda de um orcamento³
//³filho pega o valor da funcao Lj7or finalizacao da venda de um orcamento³
//|Soma o valor do desconto ao valor total porque o desconto ja foi       |
//|aplicado ao campo L1_VLRTOT.                                           |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(SL1->L1_ORCRES)
	nVlrSubTot   := SL1->L1_VLRTOT + SL1->L1_DESCONT
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza o Valor Total da Venda no caso de o aCols possuir produtos com e sem reserva ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nVlrTot		 := SL1->L1_VLRTOT + NoRound((SL1->L1_JUROS * SL1->L1_VLRTOT)/100,nDecVrUnit)
ElseIf nValSubTot > 0
	nVlrSubTot := Round(Lj7T_SubTotal( 2 ),nDecimais)
Else
	If lFisFound
		nVlrSubTot   := MaFisRet(,"NF_TOTAL")
	EndIf
EndIf

/* Obtemos o valor base que sera usado para calculo do acrescimo financeiro.
 Isso e necessario, pois o acrescimo nao leva em 
 consideracao Frete/Despesa/Seguro/ICMS-ST entre outros*/
If lFisFound
	nBaseAcr := MaFisRet(,"NF_VALMERC") + MaFisRet(,"NF_VALIPI") - MaFisRet(,"NF_DESCONTO") 
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciono no 1 item do orcamento para efetuar o rateio dos calculos    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SL2")
SL2->( DbSetOrder(1) )
SL2->( DbSeek(xFilial("SL2") + SL1->L1_NUM) )

nQtdItens  := 0
nTotItens  := 0

While !SL2->(Eof()) .AND. xFilial("SL2") + SL1->L1_NUM == SL2->L2_FILIAL + SL2->L2_NUM

	lPremio		:= !Empty(SL2->L2_PREMIO)
	
   	If !lPremio
		nSomItens += SL2->L2_VLRITEM + SL2->L2_VALFRE
		nItens ++			// Quantidade de Itens para Rateio
	EndIf

	Aadd(aItens, {	SL2->(Recno()),;          	// [01] Numero do Registro
					SL2->L2_ITEM,;             	// [02] Item da Venda
					SL2->L2_QUANT,;            	// [03] Quantidade
					SL2->L2_VRUNIT,;			// [04] Valor Unitario
					SL2->L2_VLRITEM,;			// [05] Valor do Item
					If(lJob,SL2->L2_DESCPRO,0),;							// [06] Desconto proporcional ao Item
					NoRound((nPerDescFin	*   (SL2->L2_VLRITEM - nVlrDescTot))/100, TamSx3("L2_VALDESC")[2]),;		// [07] Valor do Desconto Financeiro
					0,;							// [08] Valor do Acrescimo Financeiro
					NIL,; 	 	              	// [09] Posicao livre para suo
					lPremio,;					// [10] Premiacao?
					SL2->L2_PRCTAB,;			// [11] Preco de Tabela
					SL2->L2_TES,;				// [12] TES do produto
					SL2->L2_PRODUTO,;			// [13] Codigo do Produto
					SL2->L2_VALDESC,;			// [14] desconto Item
					SL2->L2_VALIPI ,;			// [15] Valor do IPI
					SL2->L2_ENTREGA,;			// [16] Entrega
					0,;							// [17] Total de Impostos NCM/NBS
					SL2->L2_NLOTE,;            	// [18] Lote
					SL2->L2_LOTECTL,;			// [19] LoteCtl
					0,;							// [20] Valor de Imposto Federal
					0,;							// [21] Valor de Imposto Estadual
					0,; 						// [22] Valor de Imposto Municipal
					lTemArred,;				// [23] Indica se sofreu arredondamento ou nao
					SL2->L2_VALFRE} )			// [24] Valor do Frete

	If SL2->L2_PREMIO <> "1"
		nDescItens += SL2->L2_VALDESC
	ElseIf !lJob
		nDescItens += SL2->L2_VALDESC
    EndIf

	nQtdItens := nQtdItens + 1
	nTotItens += (SL2->L2_PRCTAB * SL2->L2_QUANT) - (SL2->L2_VALDESC + SL2->L2_DESCPRO)

	SL2->(DbSkip())
End

If lJob
	//Recalcula a funcao fiscal
	LjRecalFis(	aItens		, lJob	, lEmiteNF	, nQtdItens,;
				nTotItens	)
				
	If lFisFound .And. !MaFisRet(,"NF_SUFRAMA")
		nVlrSubTot   := MaFisRet(,"NF_TOTAL")
	EndIf
	nVlrNegoc := nVlrTot - ( nVlrSubTot - nVlrDescTot )
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Quando este orcamento nao for RESERVA mas foi gerado de um orçamento PAI contendo³
//³ RESERVA e RETIRA, deve ser tratado de forma diferenciado am alguns calculos      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lJob .AND. !lMvLjPdvPa .AND. SL1->L1_RESERVA = 'S' .AND. ;
	!EMPTY(SL1->L1_FILRES + SL1->L1_ORCRES) .AND. EMPTY(SL1->L1_PEDRES)
    lOrcFilVen := .T.
EndIf

If lEmitNfce	// Caso seja filho nao deve somar o valor de acrescimo pois já foi somado no pai 
	If lOrcFilVen
		nVlrTot	:= SL1->L1_VLRTOT
		If nPerAcrs > 0	
			nTotItens  += nVlrAcrsFi 	
			nBaseAcr   := nTotItens 			
		EndIf		
	EndIf	
EndIf

If lJob
	nAuxNcc	   := 0
	nDecsAux   := MsDecimais(1)
Else
	nAuxNcc	   := nNccUsada
	nDecsAux   := nDecimais
EndIf

If lFtvdVer12 .AND. nTotICM > 0
	nNFTotal := MaFisRet(,"NF_TOTAL")
EndIf

Lj7Arred(1) // limpa array statico da função de arredondamento
nDiferencaIt:= 0
aArea		:= GetArea()

LjGrvLog(SL1->L1_NUM,"VALOR DE DESCONTO NO TOTAL",nVlrDescTot )

DbSelectArea( "SB1" )
SB1->( DbSetOrder(1) )	//B1_FILIAL+B1_COD

For nPos := 1 to nQtdItens
	xB1ImpNcm := 0
	If SB1->(DbSeek(xFilial("SB1") + aItens[nPos][__PRODUTO] ))
		If lCpoTotImp .AND. lCpoAliqImp    // se existir o campo de aliquota de imposto NCM/NBS
			// nova funcionalidade disponibilizada pelo Fiscal
			If lAlqLei2741

				cNumLote := ""
				cLoteCtl := ""

				If !lJob
					cNumLote := M->LR_NLOTE
					cLoteCtl := M->LR_LOTECTL
				ElseIf Len(aItens[nPos]) > __NLOTE
					cNumLote := aItens[nPos,__NLOTE]
					cLoteCtl := aItens[nPos,__LOTECTL]
				EndIf

				If MaFisFound("IT", nPos)
					xB1ImpNcm := AlqLei2741(SB1->B1_POSIPI,SB1->B1_EX_NCM,Alltrim(MaSBCampo("CODISS")),SA1->A1_EST,SA1->A1_COD_MUN,aItens[nPos][__PRODUTO],nPos,cNumLote,cLoteCtl,cMvFisCTrb,cMvFisAlCT,lMvFisFRas)
				EndIf

			Else
				// mantem o legado Loja
				// Busca na SBZ
				If lCpoAliqSBZ
					xB1ImpNcm := RetFldProd(SB1->B1_COD,"B1_IMPNCM","SB1")
				EndIf

				If  xB1ImpNcm ==0
					xB1ImpNcm := SB1->B1_IMPNCM
				ENdIf

   				If xB1ImpNcm ==0  .AND. lBuscaImp
					If Empty(Alltrim(MaSBCampo("CODISS"))) // eh produto
	    				If !Empty(SB1->B1_POSIPI)
	    					lBImport	:= !(SB1->B1_ORIGEM $ ' 0345')	// se nao for nacional ( Manual IBPT )
	    				 	xB1ImpNcm	:= lj7BuscaImp(SB1->B1_POSIPI,.F.,lBImport,SB1->B1_EX_NCM)
	    				EndIf
	    			Else                    // eh servico
                     lBImport    := !(SB1->B1_ORIGEM $ ' 0345')  // se nao for nacional ( Manual IBPT )
                     xB1ImpNcm   := lj7BuscaImp(,.T.,lBImport,, SB1->B1_COD)
	    			EndIf
	    		EndIf
			EndIf

			If ValType(xB1ImpNcm) == "N"
				aAlqLeiTr := {xB1ImpNcm,0,0,0}
			ElseIf Len(xB1ImpNcm) == 2
               aAlqLeiTr := {xB1ImpNcm[1],0,0,0,xB1ImpNcm[2],0,0,0}	
			Else	
				aAlqLeiTr := aClone(xB1ImpNcm)
			EndIf
               		
    		If Len(aAlqLeiTr) == 4 .OR. !(cMvFisAlCT == "3" .AND. cMvFisCTrb == "2")
    		   If Len(aItens[nPos]) > 15
                  aItens[nPos][__TOTIMP]      :=  aAlqLeiTr[1]  // Soma das aliquotas Federal, Estadual e Municipal
                  aItens[nPos][__TOTIMPFED]   :=  aAlqLeiTr[2]  // Aliquota Federal
                  aItens[nPos][__TOTIMPEST]   :=  aAlqLeiTr[3]  // Aliquota Estadual
                  aItens[nPos][__TOTIMPMUN]   :=  aAlqLeiTr[4]  // Aliquota Municipal
              Else
                  aAdd(aItens[nPos], aAlqLeiTr[1]) // Soma das aliquotas Federal, Estadual e Municipal
                  aAdd(aItens[nPos], aAlqLeiTr[2]) // Aliquota Federal
                  aAdd(aItens[nPos], aAlqLeiTr[3]) // Aliquota Estadual
                  aAdd(aItens[nPos], aAlqLeiTr[4]) // Aliquota Municipal
              EndIF    		
    		ElseIf Len(aAlqLeiTr) == 8 //Por conta de alteração feita pelo Fiscal nos fontes FISXFUN e SPEDNFE, caso o array aAlqLeiTr contenha posição da 5 a 8, logo nestas posicoes ja estiram os valores dos impostos calculados 
    			If Len(aItens[nPos]) > 15
    				aItens[nPos][__TOTIMP]		:=  aAlqLeiTr[5]  // Soma das aliquotas Federal, Estadual e Municipal
    				aItens[nPos][__TOTIMPFED]	:=  aAlqLeiTr[6]  // Aliquota Federal
    				aItens[nPos][__TOTIMPEST]	:=  aAlqLeiTr[7]  // Aliquota Estadual
    				aItens[nPos][__TOTIMPMUN]	:=  aAlqLeiTr[8]  // Aliquota Municipal
    			Else
    				aAdd(aItens[nPos], aAlqLeiTr[5]) // Soma das aliquotas Federal, Estadual e Municipal
    				aAdd(aItens[nPos], aAlqLeiTr[6]) // Aliquota Federal
    				aAdd(aItens[nPos], aAlqLeiTr[7]) // Aliquota Estadual
    				aAdd(aItens[nPos], aAlqLeiTr[8]) // Aliquota Municipal
    			EndIF
    		EndIf	
		EndIf
	EndIf

	//proporcao do Item
	nPercProduto	:= ((aItens[nPos][__VLRITEM] + aItens[nPos][__FRETE]) / nSomItens) * 100
	/*
	Se for Condicao Negociada e a opcao "Calcula o Juros incluindo o valor de Entrada?"
	estiver desabilitada, rateamos o valor da entrada de acordo com o valor do item.
	*/
	If !Empty( aDadosCNeg ) .AND. !aDadosCNeg[1][7]
		nVlrEntIt := Round( (aDadosCNeg[1][3] * ((aItens[nPos][__VLRITEM]) / nSomItens)), nDecsAux )
	EndIf

	If	!lHabNovoArred
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³VerIfica a proporcao ref. a cada item da venda                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ				
		nDescPropT := (nVlrDescTot / nTotItens) *  aItens[nPos][__VLRITEM]
		
		If nMvLjTpDes <> 2
        	If !lOrcFilVen 
        		nVlUnit := aItens[nPos][__PRCTAB] - Round((nDescPropT + aItens[nPos][__DESCITEM]) / aItens[nPos][__QUANT], nDecVrUnit)
        	Else
        		nVlUnit := (aItens[nPos][__PRCTAB] - (aItens[nPos][__DESCITEM] /aItens[nPos][__QUANT])) - ((aItens[nPos][__PRCTAB] - (aItens[nPos][__DESCITEM] /aItens[nPos][__QUANT])) * (Lj7T_DescP(2) /100)) 
        	EndIf	                         
        Else                
            If !lOrcFilVen
            	nVlUnit := aItens[nPos][__PRCTAB] - A410Arred((nDescPropT + aItens[nPos][__DESCITEM]) / aItens[nPos][__QUANT], "LR_VLRITEM")
            Else
        		nVlUnit := (aItens[nPos][__PRCTAB] - (aItens[nPos][__DESCITEM] /aItens[nPos][__QUANT])) - ((aItens[nPos][__PRCTAB] - (aItens[nPos][__DESCITEM] /aItens[nPos][__QUANT])) * (Lj7T_DescP(2) /100))
        	EndIf
        EndIf
		
		nValIPI	:= (aItens[nPos][__VALIPI] / aItens[nPos][__QUANT])

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ4ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³VerIfica a proporcao ref. a NCC utilizada (a NCC nao deverah entrar no ³
		//³calculo de juros do montante restante.)                                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nVlrNCCUnit := Round((nAuxNcc * nPercProduto) / 100, nDecsAux)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Checa se o desconto total foi efetuado antes ou depois de informada a  ³
		//³condicao de pagamento. Para os casos de arredontamento da venda.       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !aItens[nPos][__PREMIO]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Faco a proporcao do desconto no total para cada item da venda          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If aItens[nPos][__DESCPRO] == 0
				aItens[nPos][__DESCPRO] := A410Arred((nVlrDescTot * nPercProduto) / 100,"LR_VLRITEM") 
			EndIf

			If !lOrcFilVen .AND. (lDescPg .OR. AllTrim(SL1->L1_TIPODES) == "0")
				nVlUnit := aItens[nPos][__PRCTAB] - (nDescPropT + aItens[nPos][__DESCITEM]) / aItens[nPos][__QUANT]
			EndIf
		EndIf

		//Incluir no array de acrescimo o item da venda
		Aadd(aVlrAcres, 0)

		If nPerDescFin > 0
			//Calcula o Desconto Financeiro que sera aplicado no Item
			aItens[nPos][__DESCFIN]	:= Lj7Arred (2,2,( ( aItens[nPos][__VRUNIT] * aItens[nPos][__QUANT]) / nSomItens) * nDescontFi )
			nVlUnit := (((nVlUnit * aItens[nPos][__QUANT]) - aItens[nPos][__DESCFIN]) / aItens[nPos][__QUANT])
			If lFtvdVer12 .AND. nTotICM > 0		//Se existir algum item que tenha dedução de ICMS (F4_AGREG="R")
				If MaFisRet(nPos,"IT_DEDICM") > 0
					MaFisAlt("IT_DESCONTO",aItens[nPos][__DESCFIN],nPos)
					nNewTotIcm += MaFisRet(nPos,"IT_DEDICM")
				EndIf
			EndIf
		ElseIf nPerAcrs > 0 .OR. lMvLjJurCc
			If lCalcFin
				aItens[nPos][__ACRSFIN]	:= NoRound(((nVlrAcrsFi / SL1->L1_VLRTOT) * (nVlUnit * aItens[nPos][__QUANT])), nDecVrUnit)
				nVlUnit     			+= NoRound(((nVlrAcrsFi / SL1->L1_VLRTOT) * nVlUnit), nDecVrUnit)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Alimenta o array de acrescimo proporcional ao item³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aAdd(aAcrFin, aItens[nPos][__ACRSFIN])
			Else
				If (SL1->L1_TIPOJUR == 1) .OR. lMvLjJurCc
					nValAcrs := ((((nVlUnit + nValIPI) - (nVlrEntIt/aItens[nPos][__QUANT])) * aItens[nPos][__QUANT]) * nPerAcrs) / 100                                                            
                    aItens[nPos][__ACRSFIN] := Lj7Arred(2,3,nValAcrs)
                    nVlUnit += nValAcrs / aItens[nPos][__QUANT] 

					If lMvLjJurCc
						//Incidencia da Taxa de Juros para precaver caso haja Acréscimo financeiro proveniente da forma de pagamento
						nAuxJur := NoRound(((aTaxJuros[2] / SL1->L1_VLRTOT) * (nVlUnit * aItens[nPos][__QUANT])), nDecVrUnit)

						aItens[nPos][__ACRSFIN] += nAuxJur

						//Pega o valor da variavel auxiliar pois aItens[x][8] já contem o acrescimo anterior e pode causar erro reaplicando o valor sobre nVlUnit
						nVlUnit	+= NoRound( nAuxJur / aItens[nPos][__QUANT], nDecVrUnit )

						//Soma o juros do cartão nesta variável pois se houver o acrescimo financeiro da forma haverá
						//subtração dos juros e os dados serão gravados errados.
						If nVlrAcrsFi > 0
							nVlrAcrsFi	+= nAuxJur
						EndIf
					EndIf

				ElseIf Type("aAcrescimo") == "A"
					aItens[nPos][__ACRSFIN]	:= Lj7Arred (2,3,  ( (aAcrescimo[1] * nPercProduto)  / 100))
					nVlUnit	+= ( ( aAcrescimo[1] / aItens[nPos][__QUANT] * nPercProduto ) / 100 )
					If lFtvdVer12 .AND. nTotICM > 0		//Se existir algum item que tenha dedução de ICMS (F4_AGREG="R")
						If MaFisRet(nPos,"IT_DEDICM") > 0
							MaFisAlt("IT_DESCONTO",-aItens[nPos][__ACRSFIN],nPos)
							nNewTotIcm += MaFisRet(nPos,"IT_DEDICM")
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Checa se o desconto total foi efetuado antes ou depois de informada a  ³
		//³condicao de pagamento. Para os casos de arredontamento da venda.       ³
		//³VerIfica tbem se ha desconto financeiro para efetuar a proporcionaliza-³
		//³cao                                                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Val(SL1->L1_TIPODES) == 2 .AND. (Lj7T_Subtotal(2) - Lj7T_Total(2) > 0) .AND. !aItens[nPos][__PREMIO]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Faco a proporcao do desconto no total para cada item da venda          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aItens[nPos][__DESCPRO]	:= Round(((nVlrDescTot * nPercProduto) / 100),nDecVrUnit)
			nVlUnit := (aItens[nPos][__VRUNIT] * aItens[nPos][__QUANT] - aItens[nPos][__DESCPRO]) / aItens[nPos][__QUANT]
		EndIf
		
		If lFisFound .And. MaFisRet(nPos, "IT_DESCZF") > 0
            nVlUnit -= MaFisRet(nPos, "IT_DESCZF") / aItens[nPos][__QUANT]
        EndIf
        
	    If nVlUnit <> aItens[nPos][__VRUNIT]

			//Atualiza o Valor Total do Item e atualiza a matriz de acrescimo
			aItens[nPos][__VLRITEM]	:= A410Arred(nVlUnit * aItens[nPos][__QUANT],"D2_TOTAL")
			
			nVlUnit := A410Arred(nVlUnit,"L2_VRUNIT")

			//Atualiza o Valor Unitario do Item
			aItens[nPos][__VRUNIT] := nVlUnit
		Else
			nVlUnit := A410Arred(nVlUnit,"L2_VRUNIT")
		EndIf
		
		If	lFisFound .And. !lCalcFin .And. MaFisRet(nPos,"IT_VALSOL") > 0 .And.;
		 	!(Posicione("SF4", 1, xFilial("SF4") + aItens[nPos][__TES], "F4_INCSOL") $ "A,N,D")
		 	                                                                             
			nAcresProp := 0
			
            //Calcula Acrescimo proporcional do icms solidario	            
            If nVlrAcrsFi > 0 .And. nPerAcrs > 0
                nAcresProp := Lj7Arred(2, 3, MaFisRet(nPos,"IT_VALSOL") * nPerAcrs / 100)
	        EndIf
	        
	        aItens[nPos][__VLRITEM] += nAcresProp
        EndIf

		//Acumula total dos Itens
		nAcumVlRat	+= aItens[nPos][__VLRITEM]

		//Acumula total do Desconto Proporcional
		nDesct	+= aItens[nPos][__DESCPRO] + aItens[nPos][__DESCFIN]

		aVlrAcres[Len(aVlrAcres)] := aItens[nPos][__ACRSFIN]
	Else

		If nSomItens >= nVlrDescTot
			nPercTotal	:=  NoRound( ((nVlrDescTot + nDescontFi ) / nSomItens) * 100 , nDecsAux )
			nVlrDescFi	:=	Round( (( nDescontFi ) / nSomItens) * 100 , nDecsAux )
		Else
			nPercTotal	:=  NoRound( ((nVlrDescTot + nDescontFi ) / nVlrDescTot) * 100 , nDecsAux )
			nVlrDescFi	:=	Round( (( nDescontFi ) / nVlrDescTot) * 100 , nDecsAux )
		EndIf

		nDescPropT := (nVlrDescTot / nTotItens ) *  aItens[nPos][__VLRITEM]
		
		If !lOrcFilVen
			nDescItem	:= Lj7Arred(2,2,((aItens[nPos][__VRUNIT] * aItens[nPos][__QUANT]) * (Lj7T_DESCP(2) /100)))  
		Else 
			nDescItem	:= Lj7Arred(2,2,(nVlrDescTot / nTotItens)  * ( aItens[nPos][__VLRITEM] + aItens[nPos][__VALIPI] - nVlrEntIt  ),"L2_DESCPRO")	 
		EndIf 
		
		nVlrDescFi	:= Round( aItens[nPos][__VLRITEM] * ( nVlrDescFi / 100 ) , nDecsAux)
		nVlUnit := aItens[nPos][__PRCTAB] - A410Arred((nDescPropT + aItens[nPos][__DESCITEM]) / aItens[nPos][__QUANT], "LR_VLRITEM")
		nValIPI		:= aItens[nPos][__VALIPI] / aItens[nPos][__QUANT]

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³VerIfica a proporcao ref. a NCC utilizada (a NCC nao deverah entrar no ³
		//³calculo de juros do montante restante.)                                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nVlrNCCUnit := Round((nAuxNcc * ((aItens[nPos][__VLRITEM]) / nSomItens) ), nDecsAux)

		If !aItens[nPos][__PREMIO]
			aItens[nPos][__DESCPRO]:= Lj7Arred(2,1,(nDescItem - nVlrDescFi))
			If !lOrcFilVen .AND. (lDescPg .OR. AllTrim(SL1->L1_TIPODES) == "0")
				nVlUnit := ((((aItens[nPos][__PRCTAB] - (aItens[nPos][__DESCITEM] / aItens[nPos][__QUANT])) * aItens[nPos][__QUANT]) - aItens[nPos][__DESCPRO]) / aItens[nPos][__QUANT])
			EndIf
		EndIf

		//Incluir no array de acrescimo o item da venda
		Aadd(aVlrAcres, 0)

		If nPerDescFin > 0
			//Calcula o Desconto Financeiro que sera aplicado no Item
			aItens[nPos][__DESCFIN]	:= Lj7Arred(2,2, nVlrDescFi )
			nVlUnit := (((nVlUnit * aItens[nPos][__QUANT]) - aItens[nPos][__DESCFIN]) / aItens[nPos][__QUANT])
		ElseIf nPerAcrs > 0 .OR. lMvLjJurCc
			If lCalcFin
				aItens[nPos][__ACRSFIN]	:= Round(((nVlrAcrsFi / SL1->L1_VLRTOT) * (nVlUnit * aItens[nPos][__QUANT])), nDecsAux)
				nVlUnit 				+= Round(((nVlrAcrsFi / SL1->L1_VLRTOT) * nVlUnit), nDecVrUnit)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Alimenta o array de acrescimo proporcional ao item³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aAdd(aAcrFin, aItens[nPos][__ACRSFIN])
			Else
				If (SL1->L1_TIPOJUR == 1) .OR. lMvLjJurCc

					nVlAcresUnit  := ((((nVlUnit + nValIPI) - (nVlrEntIt/aItens[nPos][__QUANT])) * nPerAcrs) / 100)  
					aItens[nPos][__ACRSFIN] := A410Arred((( nVlrAcrsFi * ( aItens[nPos][__VLRITEM] + aItens[nPos][__VALIPI] - nVlrEntIt )) / (nBaseAcr-nVlrEntIt)),"L2_VALACRS") 
					nVlUnit+= nVlAcresUnit

					If lMvLjJurCc
						//Incidencia da Taxa de Juros para precaver caso haja Acréscimo financeiro proveniente da forma de pagamento
						nAuxJur := Lj7Arred (2,3,((( (nVlUnit + nValIPI) - (nVlrEntIt/aItens[nPos][__QUANT]) - (nVlrNCCUnit/aItens[nPos][__QUANT]) ) * aItens[nPos][__QUANT]) * aTaxJuros[1]) / 100)

						//Pega o valor da variavel auxiliar pois aItens[x][8] já contem o acrescimo anterior e pode causar erro reaplicando o valor sobre nVlUnit
						aItens[nPos][__ACRSFIN]	+= nAuxJur

						//Soma o juros do cartão nesta variável pois se houver o acrescimo financeiro da forma haverá
						//subtração dos juros e os dados serão gravados errados.
						If nVlrAcrsFi > 0
							nVlrAcrsFi	+= nAuxJur
						EndIf

						If  aItens[nPos][__QUANT] > 1
							nVlUnit+= Round( (((nVlUnit + nValIPI) - (nVlrEntIt/aItens[nPos][__QUANT]) - (nVlrNCCUnit/aItens[nPos][__QUANT])) * aTaxJuros[1] ) / 100 ,nDecVrUnit)
	 					Else
		 					nVlUnit += nAuxJur
		 				EndIf
		 			EndIf

				ElseIf Type("aAcrescimo") == "A"
					aItens[nPos][__ACRSFIN]	:= Lj7Arred (2,3,  ( (aAcrescimo[1] * nPercProduto)  / 100))
				   	nVlUnit	+= ((aAcrescimo[1] / aItens[nPos][__QUANT] * nPercProduto)  / 100)
				EndIf
			EndIf
		EndIf

		If nDescItem > 0
			//Faz os posicionamentos para que seja possível pegar a Situação Tributária do Item ( função lj7SitTrib )

			DbSelectArea( "SB0" )
			DbSetOrder(1)
			SB0->(DbSeek(xFilial("SB0")+SB1->B1_COD))

			DbSelectArea( "SF4" )
			DbSetOrder(1)
			SF4->(DbSeek(xFilial("SF4") + aItens[nPos][__TES] ))

			cSitTrib	:= ""	// Limpa somente cTrib pois só ela será utilizada abaixo
			Lj7Strib( @cSitTrib, @nAliquota, @nAliqRed, cTpSolCf, nPos )

			nPosAux := aScan(aGrupTrib,{|x| AllTrim(x[1]) == AllTrim(cSitTrib)})
			If nPosAux == 0
				aAdd(aGrupTrib, {})
				nPosAux :=	Len (aGrupTrib)
				aAdd (aGrupTrib[nPosAux], cSitTrib					)	 	   	// Tipo Tributacao
				aAdd (aGrupTrib[nPosAux], aItens[nPos][__VLRITEM]	)	 	   	// Valor do item
				aAdd (aGrupTrib[nPosAux], nPos						)	 	   	// Posicao do item
				aAdd (aGrupTrib[nPosAux], nVlUnit					)	 	   	// Valor Maior
				aAdd (aGrupTrib[nPosAux], nDescItem					)	 	   	// Desconto do Grupo
				aAdd (aGrupTrib[nPosAux], nDescItem					)	 	   	// Desconto somando por item
				aAdd (aGrupTrib[nPosAux], aItens[nPos][__ITEM] 	)		 	// Item do Grupo
				aAdd (aGrupTrib[nPosAux], aItens[nPos][__QUANT]	)	 	   	// Desconto somando por item
			Else
				If nVlUnit > aGrupTrib[nPosAux][4]
					aGrupTrib[nPosAux][3] := nPos
					aGrupTrib[nPosAux][4] := nVlUnit
					aGrupTrib[nPosAux][7] := aItens[nPos][__ITEM]
				EndIf
				aGrupTrib[nPosAux][2] += aItens[nPos][__VLRITEM]
				aGrupTrib[nPosAux][5] := NoRound(aGrupTrib[nPosAux][2]*(nPercTotal/100),nDecsAux)  // Desconto no grupo
				aGrupTrib[nPosAux][6] += nDescItem													// Desconto por item
			EndIf
			nDiferencaIt += nDescItem
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Checa se o desconto total foi efetuado antes ou depois de informada a  ³
		//³condicao de pagamento. Para os casos de arredontamento da venda.       ³
		//³VerIfica tbem se ha desconto financeiro para efetuar a proporcionaliza-³
		//³cao                                                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Val(SL1->L1_TIPODES) == 2 .AND. (Lj7T_Subtotal(2) - Lj7T_Total(2) > 0) .AND. !aItens[nPos][__PREMIO]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Faco a proporcao do desconto no total para cada item da venda          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aItens[nPos][__DESCPRO]	:= Round( nDescItem - nVlrDescFi ,nDecVrUnit)
		  	nVlUnit := ((nVlUnit * aItens[nPos][__QUANT]) - aItens[nPos][__DESCPRO]) / aItens[nPos][__QUANT]
		EndIf
		
		If lFisFound .And. MaFisRet(nPos, "IT_DESCZF") > 0
            nVlUnit -= MaFisRet(nPos, "IT_DESCZF") / aItens[nPos][__QUANT]
        EndIf
        
        If nMvLjTpDes == 2
            nVlUnit := A410Arred(nVlUnit,"L2_VRUNIT")
        EndIf
        
        If nVlUnit <> aItens[nPos][__VRUNIT]									
			//Atualiza o Valor Unitario do Item
			aItens[nPos][__VRUNIT] := nVlUnit
            
            If nMvLjTpDes <> 2
                //Atualiza o Valor Total do Item
                aItens[nPos][__VLRITEM]	:= nVlUnit * aItens[nPos][__QUANT]
	        Else	    		    		    	
                //Atualiza o Valor Total do Item
                lTemArred				:= .F.
                aItens[nPos][__VLRITEM]	:= Lj7Arred (2,4, (nVlUnit * aItens[nPos][__QUANT]),@lTemArred)
                aItens[nPos][__ARRED]	:= lTemArred
            EndIf
		EndIf
			    
		//Acumula total dos Itens
		nAcumVlRat	+=	aItens[nPos][__VLRITEM]

		//Acumula total do Desconto Proporcional
		nDesct		+=	nDescItem

		// Atualiza a matriz de acrescimo.
		aVlrAcres[Len(aVlrAcres)] := aItens[nPos][__ACRSFIN]

	EndIf
Next nPos

LjGrvLog(SL1->L1_NUM,"NOVO ARREDONDAMENTO ",lHabNovoArred )

If	lHabNovoArred .AND. (nDesct > 0) .and. !lEmitNfce

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³O ECF faz o calculo por grupo de aliquotas , esse loop vai comparar ³
	//³se o desconto aplicado nos itens corresponde ao grupo de aliquotas  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lValIgual := .T.
	For nPos := 1 to Len(aGrupTrib)
		nDifGrupo :=  aGrupTrib[nPos][5] - aGrupTrib[nPos][6]
		If nDifGrupo > 0

			nPosAux	:= aScan(aItens,{|x| AllTrim(x[2]) == AllTrim(aGrupTrib[nPos][7])}) // Procura o item de acordo com a posição
			If nPosAux > 0

				nVlrItem  := aItens[nPosAux][__VLRITEM] - nDifGrupo
				nDescItem := aItens[nPosAux][__DESCPRO] + nDifGrupo

				aItens[nPosAux][__VRUNIT] := ( nVlrItem / aGrupTrib[nPos][8])
				aItens[nPosAux][__VLRITEM]:= nVlrItem
				aItens[nPosAux][__DESCPRO]:= nDescItem
			EndIf

			nDiferencaIt  += nDifGrupo
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se todos os grupos de aliquotas sao iguais³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aGrupTrib) == 1
			lValIgual := .F.
		ElseIf Len(aGrupTrib) > nPos .AND. lValIgual
			If aGrupTrib[nPos][2] <> aGrupTrib[nPos + 1][2]
				lValIgual := .F.
			EndIf
		EndIf
	Next nPos

	nDiferencaIt := (nVlrDescTot + nDescontFi) - nDiferencaIt

	If nDiferencaIt > 0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Inicializa as variaves com o primeiro grupo de aliquotas³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nMaior 		:= 1
		nValMaior   := aGrupTrib[1][2]
		nBasMAliq 	:= 0
		nTotAliqs	:= 0

		If lValIgual .AND. Len(aGrupTrib) > 1
			If aScan(aGrupTrib,{|x| "T" $ x[1] }) > 0
				For nPos := 1 to Len(aGrupTrib)
					If "T" $ aGrupTrib[nPos][1]
						If Val(Substr( aGrupTrib[nPos][1] ,2,2)) > nBasMAliq
							nBasMAliq 	:= Val(Substr( aGrupTrib[nPos][1] ,2,2))
							nMaior 		:= nPos
						EndIf
						nTotAliqs++
					EndIf
				Next

				If nTotAliqs == 1
					nMaior := aScan(aGrupTrib,{|x| "T" $ x[1] })
				EndIf

			ElseIf aScan(aGrupTrib,{|x| "F" $ x[1] }) > 0
				nMaior := aScan(aGrupTrib,{|x| "F" $ x[1] })
			ElseIf aScan(aGrupTrib,{|x| "I" $ x[1] }) > 0
				nMaior := aScan(aGrupTrib,{|x| "I" $ x[1] })
			ElseIf aScan(aGrupTrib,{|x| "N" $ x[1] }) > 0
				nMaior := aScan(aGrupTrib,{|x| "N" $ x[1] })
			EndIf

		Else
			For nPos := 1 to ( Len(aGrupTrib) - 1 )
				If nValMaior < aGrupTrib[nPos + 1][2]
					nMaior 		:= nPos + 1
					nValMaior   := aGrupTrib[nPos + 1][2]
				EndIf
		    Next nI
		EndIf

	    nPosAux := aGrupTrib[nMaior][3]

		nDescItem 	:= aItens[nPosAux][__DESCPRO] + nDiferencaIt
		nVlrItem   	:= aItens[nPosAux][__VLRITEM] - nDiferencaIt

		aItens[nPosAux][__VRUNIT] := ( nVlrItem / aItens[nPosAux][__QUANT])
		aItens[nPosAux][__VLRITEM]:= nVlrItem
		aItens[nPosAux][__DESCPRO]:= nDescItem

		//Acumula total dos Itens
		nAcumVlRat	:= nAcumVlRat - nDiferencaIt

		//Acumula total do Desconto Proporcional
		nDesct	:= 0
		Aeval( aItens, { |x| nDesct+= x[__DESCPRO] } )
	EndIf
EndIf

RestArea( aArea )

For nPos := 1 to Len(aVlrAcres)
	nSomaAux += aVlrAcres[nPos]
Next nPos

If nVlrAcrsFi > 0
	If (lFtvdVer12 .AND. nTotICM == 0) .OR. !lFtvdVer12
		nVlrSomAcr := nVlrAcrsFi - nSomaAux
	ElseIf lFtvdVer12
		nVlrAcrsFi += nNewTotIcm - nTotICM
		nVlrSomAcr := nVlrAcrsFi - nSomaAux
	EndIf
Else
	If nOpc == 4
		nVlrSomAcr := NoRound(nSomaAux, nDecimais) - nSomaAux
	Else
		nVlrSomAcr := nVlrAcrsFi - nSomaAux
	EndIf
EndIf

//Soma no ultimo item, o residuo que restou do acrescimo.
If (Abs(nVlrSomAcr) <= (1/(10 ** nDecsAux))) .Or. (nVlrAcrsFi > 0 .And. nVlrSomAcr <> 0)
	aVlrAcres[Len(aVlrAcres)] += nVlrSomAcr
	aItens[Len(aItens)][__ACRSFIN] := NoRound( ( aItens[Len(aItens)][__ACRSFIN] + nVlrSomAcr ), nDecVrUnit )
	nSomaAux += nVlrSomAcr
EndIf

If nVlrAcrsFi > 0 .AND. Lj7T_DescV(2) == 0
	For nPos := 1 to Len(aItens)
		nVrSomIt += (aItens[nPos][__VLRITEM] + aItens[nPos][__VALIPI])
	Next nPos

	If nVlrAcrsFi > 0 .AND. lFisFound .AND. MaFisRet(,"NF_VALSOL") > 0
		nDifValSol := LjDifVlSol("NF_DESCONTO", -nVlrAcrsFi)
		nValSol := If(ExistFunc("Lj7IcmsSol"),Lj7IcmsSol(),MaFisRet(,"NF_VALSOL")) + nDifValSol
	EndIf

	//o valor do ICMS Solidario nao pode ser considerado como acrescimo financeiro
	nVlrSomAcr := Lj7T_Total(2) - (nVrSomIt + nValSol + Lj7CalcFrete(lJob .OR. lOrcFilVen) )

	If nVlrSomAcr <> 0				// Valor da dif entre o total na tela e o somado do rateado no aItens
		nDifAcres := nVlrSomAcr  	// Copia o valor do acrescimo
		If Abs(nVlrSomAcr) > nCent .AND. nDifAcres <= 0.10 	// Se a diferenca for maior que 1 centavo e dentro do limite de protecao de 10 cents
			If nDifAcres < 0		// Se a diferenca for para baixo tira do VlrItem
				nCent := -0.01
			EndIf

			While nDifAcres <> 0 .AND. nCount < 10 		// Tira 1 centavo de cada vez , limitado a 5(protecao)
				nPos := aScan(aItens,{|x|x[__ARRED]}) 	// Procura um item que teve arredondamento
				If nPos > 0 .AND. nDifAcres <> 0		// Se encontrou algum que teve arredondamento
					aItens[nPos][__VLRITEM] := A410Arred(aItens[nPos][__VLRITEM] +nCent,"D2_TOTAL",nMoedaCor)
					aItens[nPos][__VRUNIT]  := aItens[nPos][__VLRITEM] / aItens[nPos][__QUANT]
					aItens[nPos][__ARRED]	:= .F.
					nDifAcres := nDifAcres - nCent
				EndIf
				nCount++
			End
		EndIf
		// Se a diferenca for de 1 cent ou ainda sobrar do rateio de cima joga no ultimo item
		If nDifAcres > 0 .AND. nDifAcres <= 0.10	// Consideramos q se dif for maior q 10 cents nao deve ajustar, pois provavlemente deve ser um problema	e nao uma diferen
			nPos := aScan(aItens,{|x|x[__ARRED]}) 	// Procura algum que foi arredondado para truncar
			If nPos = 0
				nPos := Len(aItens)				// Se nao achar vai no ultimo mesmo
			EndIf
			aItens[nPos][__VLRITEM] := A410Arred( aItens[nPos][__VLRITEM] + nDifAcres,"D2_TOTAL",nMoedaCor)
			aItens[nPos][__VRUNIT]  := aItens[nPos][__VLRITEM] / aItens[nPos][__QUANT]
		EndIf
		nAcumVlRat += nVlrSomAcr
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calcula a dIferenca³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nDIfDesc := (nVlrDescTot + nDescontFi ) - nDesct

LjGrvLog(SL1->L1_NUM,"DIFERENÇA DE DESCONTO",nDIfDesc)
LjGrvLog(SL1->L1_NUM,"VALOR DE DESCONTO",nVlrDescTot)

If (nVlrDescTot == nDifDesc) .AND. nVlrDescTot > 0 .AND. lJob
	nDifDesc := 0
	lAtuDesc := .F.
	nDescTot := nVlrDescTot
EndIf

If nDIfDesc <> 0 .AND. Abs(nDIfDesc) <= (500/(10**(4)))   //Diferenças maiores de 0,05  não será rateada
	lDistrPrCi := nDIfDesc <= (2 / (10 ** nDecsAux))
	nPos := IIf (lDistrPrCi, nItens, 1)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Distribui a dIferenca entre os itens ate que a mesma seja³
	//³eliminada                                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	While !(nDIfDesc == 0) .AND. (nPos > 0 .And. nPos <= nItens)
		If !aItens[nPos][__PREMIO]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Caso o sistema esteja utilizando 2 casas decimais e a dIferença seja menor    ³
			//³do que isso (por exemplo: 0,008 nao deve proporcionalizar, pois dara dIferenca³
			//³no momento da impressao, e com isso ocorrera erro.                            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nDIfDesc >= (1 / (10 ** nDecsAux))
				If NoRound((aItens[nPos][__VLRITEM] - nDIfDesc) / aItens[nPos][__QUANT], nDecsAux) < (1 / (10 ** nDecsAux))
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Se o valor do item e' pequeno faz o ajuste deixando 1 centavo no VrUnit³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aItens[nPos][__VRUNIT] := (1 / (10 ** nDecVrUnit))

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Subtrai da variavel somente a dIferenca que sera ajustada aqui.³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nDIfDesc -= (aItens[nPos][__VLRITEM] - (aItens[nPos][__VRUNIT] * aItens[nPos][__QUANT]))

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Adiciona ao desconto proporcional a dIferenca que foi utilizada aqui.³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aItens[nPos][__DESCPRO] += (aItens[nPos][__VLRITEM] - (aItens[nPos][__VRUNIT] * aItens[nPos][__QUANT]))

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Recalcula o valor total do item de acordo com o VrUnit*Qtd³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aItens[nPos][__VLRITEM] := (aItens[nPos][__VRUNIT] * aItens[nPos][__QUANT])
				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Se o valor do item permite entao faz o ajuste total                    ³
					//³Soma a dIferenca no desconto desse item porque o ajuste sera feito aqui³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aItens[nPos][__DESCPRO] += nDIfDesc

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Se aumentou o desconto entao diminui o valor do item na mesma proporcao³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !(lEmitNfce .And. lOrcFilVen)	 
						aItens[nPos][__VLRITEM] -= nDIfDesc
						nAcumVlRat -= nDIfDesc
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Recalcula o valor unitario do item de acordo com o VrTotItem/Qtd³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						aItens[nPos][__VRUNIT] := NoRound(aItens[nPos][__VLRITEM] / aItens[nPos][__QUANT], nDecVrUnit)
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Como toda a dIferenca foi utilizada entao zera a variavel para sair do laco (while)³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nDIfDesc := 0
				EndIf
			Else // Se a Diferença for negativa
				nDIfDesc := Abs(nDIfDesc) // transf. em absoluto pois o valor será diminuido do desconto e acrescido ao vlr item

				If NoRound((aItens[nPos][__VLRITEM] - nDIfDesc) / aItens[nPos][__QUANT], nDecsAux) < (1 / (10 ** nDecsAux))
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Se o valor do item e' pequeno faz o ajuste deixando 1 centavo no VrUnit³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aItens[nPos][__VRUNIT] := (1 / (10 ** nDecVrUnit))

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Subtrai da variavel somente a dIferenca que sera ajustada aqui.³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nDIfDesc -= (aItens[nPos][__VLRITEM] - (aItens[nPos][__VRUNIT] * aItens[nPos][__QUANT]))

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Adiciona ao desconto proporcional a dIferenca que foi utilizada aqui.³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aItens[nPos][__DESCPRO] += (aItens[nPos][__VLRITEM] - (aItens[nPos][__VRUNIT] * aItens[nPos][__QUANT]))

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Recalcula o valor total do item de acordo com o VrUnit*Qtd³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aItens[nPos][__VLRITEM] := (aItens[nPos][__VRUNIT] * aItens[nPos][__QUANT])
				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Se o valor do item permite entao faz o ajuste total                    ³
					//³Soma a dIferenca no desconto desse item porque o ajuste sera feito aqui³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aItens[nPos][__DESCPRO] -= nDIfDesc    //aItens[nPos][__DESCPRO] += nDIfDesc

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Se aumentou o desconto entao diminui o valor do item na mesma proporcao³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aItens[nPos][__VLRITEM] += nDIfDesc    //aItens[nPos][__VLRITEM] -= nDIfDesc
					nAcumVlRat += nDIfDesc                 //nAcumVlRat -= nDIfDesc
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Recalcula o valor u'nitario do item de acordo com o VrTotItem/Qtd³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aItens[nPos][__VRUNIT] := NoRound(aItens[nPos][__VLRITEM] / aItens[nPos][__QUANT], nDecVrUnit)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Como toda a dIferenca foi utilizada entao zera a variavel para sair do laco (while)³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nDIfDesc := 0
				EndIf
			EndIf
		EndIf
		IIf (lDistrPrCi, nPos --, nPos ++)
	End
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inclui o valor do Frete,Seguro e Despesas na variavel nAcumVlRat       ³
//³Se lOrcFilVen for TRUE o Frete deve vir do SL1 e nao da Memoria		  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nAcumVlRat += Lj7CalcFrete(lJob .OR. lOrcFilVen)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inclui o valor do IPI na variavel nAcumVlRat                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nAcumVlRat += If( lFisFound, MafisRet(,"NF_VALIPI"), 0 )
nAcumVlRat := A410Arred(nAcumVlRat,"D2_TOTAL",nMoedaCor)

If nAcumVlRat < nVlrTot
	nValSol		:= MaFisRet(,"NF_VALSOL")
	nAuxVlrTot	:= nVlrTot

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se o valor acumulado for dIferente do valor total, verIfica antes no SL4 se o orcamento nao eh com reserva³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea("SL4")
	SL4->( DbSetOrder(1) )	//L4_FILIAL+L4_NUM+L4_ORIGEM
	SL4->( DbSeek(xFilial("SL4")+SL1->L1_NUM) )
	nVlrTot := 0
	While SL4->(!Eof()) .AND. SL4->L4_FILIAL + SL4->L4_NUM == xFilial("SL4") + SL1->L1_NUM
		nVlrTot	+= SL4->L4_VALOR
		SL4->( DbSkip() )
	End

	//Caso haja juros da taxa administrativa soma pois ele ainda não foi somada nas parcelas com isso
	//gera a subtração do valor dos juros sobre o valor
	If lMvLjJurCc
		nVlrTot	+=	aTaxJuros[2]
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se o valor continuar a ser menor, mantem o valor TOTAL do retorno da funcao Lj7T_Total() ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If nAcumVlRat < (nVlrTot - nValSol)
    	nVlrTot := nAuxVlrTot
    EndIf

	nDIferenca 	:= NoRound( (nVlrTot+nNccUsada - nAcumVlRat - nValSol) / nQtdItens, nDecsAux)
	nResto 		:= ( (nVlrTot+nNccUsada - nAcumVlRat - nValSol) - (nDIferenca * nQtdItens))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Compara o valor do item*qtde baseado no SL2 com o valor gerado na soma do aCols (Arredondado), ³
	//³se dIferente faz o ajuste do arredondamento.                                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nPos := 1 to nQtdItens
   		If !aItens[nPos][__PREMIO] .AND. aItens[nPos][__VLRITEM] <> Round(aItens[nPos][__VRUNIT] * aItens[nPos][__QUANT], nDecsAux)
			aItens[nPos][__VLRITEM] += nDIferenca
			nAcumVlRat += nDIferenca
			If nResto > 0
				aItens[nPos][__VLRITEM]	+= 0.01
				nResto 			-= 0.01
			EndIf
			aItens[nPos][__VRUNIT] := NoRound(aItens[nPos][__VLRITEM] / aItens[nPos][__QUANT], nDecVrUnit)
		EndIf
	Next nPos
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Arredonda o acrescimo dos itens, do mesmo modo que sera gravado na MatxFis	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lJob
	For nPos = 1 To Len(aItens)
		nValSol := 0
		//Posiciona TES para verIficar se a apuracao eh pelo bruto ou liquido
		DbSelectArea("SF4")
		SF4->( DbSetOrder(1) )	// F4_FILIAL+F4_CODIGO
		SF4->( DbSeek(xFilial("SF4") + aItens[nPos][__TES]) )
		If !(SF4->F4_INCSOL $ "A,N,D")
			nValSol	+= MaFisRet(nPos,"IT_VALSOL")
		EndIf
		// usado no calculo de diferenca da venda abaixo (nItDifere)
		nTotValSol += nValSol

		If lFtvdVer12 .AND. nTotICM > 0 .And. aItens[nPos,__ACRSFIN] > 0
			nDifAcres  := 0
			nDifAcres  := (A410Arred(aItens[nPos,__ACRSFIN], "F3_VALOBSE") - aItens[nPos,__ACRSFIN])
			nRestAcres += nDifAcres
		EndIf
		aItens[nPos][__ACRSFIN]	:= A410Arred(aItens[nPos,__ACRSFIN], "F3_VALOBSE")
		aVlrAcres[nPos] 		:= aItens[nPos][__ACRSFIN]
		nSomAcrRnd				+= aVlrAcres[nPos]
		nAItValIpi				:= 0
		
		If MaFisRet(,"NF_SUFRAMA")
			nAItValIpi := aItens[nPos][__VALIPI]
		EndIf
		
		nSomItRnd += A410Arred(aItens[nPos,__VLRITEM], "D2_TOTAL") - MaFisRet(nPos,"IT_DEDICM") - MaFisRet(nPos,"IT_VNAGREG") + nAItValIpi
		nSomDesFin+= aItens[nPos][__DESCFIN]

		// Soma o valor da garantia
		If lGE .AND. SuperGetMv("MV_LJIMPGF",,.F.)
            If ( Posicione("SB1",1,xFilial("SB1")+aItens[nPos][__PRODUTO], "B1_TIPO") == cMvLjTGar )
   				nVlrGar += A410Arred(aItens[nPos,__VLRITEM], "D2_TOTAL") - MaFisRet(nPos,"IT_DEDICM") - MaFisRet(nPos,"IT_VNAGREG") + aItens[nPos][__VALIPI] + nValSol
   	  		EndIf

   	  		If AllTrim(aItens[nPos,__ENTREGA]) == "3"
   				lEntrega := .T.
   			EndIf
		EndIf

		If aItens[nPos,__ENTREGA] $ "13"
			lRatFrete := .T.
			nLastDesp := nPos //Ultimo registro de despesas
			nQtdEntre ++
		EndIf

	Next nPos

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Armazena a dizima do valor cheio menos o valor arredondado	³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nLj7TDescV	:= IIf(ExistFunc("LjNewCalSol") .And. LjNewCalSol() ,0, Lj7T_DescV(2))
	nNFTotal:= MaFisRet(,"NF_TOTAL")	
	If nMvLjTpDes <> 2
		nAcrDifere := Round(NoRound(nSomaAux, nDecsAux) - nSomAcrRnd, nDecsAux)
	  	nDesFinDif := Round(NoRound(((nNFTOTAL - nLj7TDescV)* nPerDescFin) / 100, TamSx3("L2_VRUNIT")[2]) - nSomDesFin, nDecVrUnit )
    Else
		If (lFtvdVer12 .AND. nTotICM == 0) .OR. !lFtvdVer12
			nAcrDifere := Round(A410Arred(nSomaAux, "D2_TOTAL") - nSomAcrRnd, nDecsAux)
		Else
			nAcrDifere := Round(A410Arred(nSomaAux + nRestAcres,"D2_TOTAL") - nSomAcrRnd, nDecsAux)
		EndIf
		If nNCCUsada <= (nNFTOTAL - nLj7TDescV)
			nDesFinDif := Round(A410Arred(((nNFTOTAL - nLj7TDescV - nNCCUsada)* nPerDescFin) / 100, "D2_DESCON" ) - nSomDesFin , nDecVrUnit)
		EndIf
	EndIf

	nItDifere := 0
	If !lOrcFilVen
		nItDifere := Round(Lj7T_Total(2) - Lj7CalcFrete(lJob) - (nSomItRnd + nTotValSol + nDifValSol), nDecsAux)
	EndIf

	LjGrvLog(SL1->L1_NUM,"VALOR DE RESERVA",nValRes)
	LjGrvLog(SL1->L1_NUM,"DIFERENÇA DO TOTAL COM A SOMA DOS ITENS",nItDifere)

	If lGE .AND. SuperGetMv("MV_LJIMPGF",,.F.) .AND. nVlrGar > 0 .AND. !lEntrega .And. lOrcFilVen
	 	/* Subtrai o Valor da Reserva + Garantia para calcular
	 	 a diferença correta quando for Orcamento Filho Retira */
   		nItDifere := (nItDifere + nVlrGar) - nValRes
	EndIf

	If lFtvdVer12 .AND. (nDesFinDif <> 0 .Or. nItDifere <> 0)
		For nItem := Len(aItens) To 1 Step -1
			If aItens[nItem][__DESCFIN] > 0
				Exit
			EndIf
		Next nItem
		If nItem == 0
			nItem := Len(aItens)
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Aplica ajuste da dizima de acrescimo ou desconto financeiro no ultimo item	³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nAcrDifere <> 0 .And. ABS(nAcrDifere) < 0.05
		aItens[Len(aItens)][__ACRSFIN] 	+= nAcrDifere
		aVlrAcres[Len(aItens)] 			+= nAcrDifere
	ElseIf nDesFinDif <> 0 .And. ABS(nDesFinDif) < 0.05
        aItens[Len(aItens)][__DESCFIN] 	+= nDesFinDif
	EndIf

	LjGrvLog(SL1->L1_NUM,"DIFERENÇA NA VENDA",nItDifere)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Aplica ajuste da dizima do valor dos itens no ultimo item	³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nItDifere <> 0
		If !lFtvdVer12
			If IIf(!lOrcFilVen,ABS(nItDifere)<0.05,nItDifere<=0.05)
				aItens[Len(aItens)][__VLRITEM] 	+= nItDifere
				aItens[Len(aItens)][__VRUNIT] 	:= A410Arred(aItens[Len(aItens)][__VLRITEM] / aItens[Len(aItens)][__QUANT], "L2_VRUNIT")
			EndIf
		Else
		 	If IIf(!lOrcFilVen,ABS(nItDifere)<0.05,nItDifere<0.05)
				aItens[nItem][__VLRITEM] 	+= nItDifere
				aItens[nItem][__VRUNIT] 	:= A410Arred(aItens[nItem][__VLRITEM] / aItens[nItem][__QUANT], "D2_TOTAL")
				If nPerDescFin <> 0
					aItens[nItem][__DESCFIN] -= nItDifere
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

If !MaFisRet(,"NF_SUFRAMA")
	//Recalcula a funcao fiscal
	LjRecalFis(	aItens										, lJob		, lEmiteNF	, nQtdItens ,;
				IIf(!lJob,nSomItRnd+nDescontFi,nTotItens)	, lOrcFilVen, nValRes	, IIf (!lJob, nQtdEntre, nQtdItens))
EndIf
LjGrvLog(SL1->L1_NUM,"DEPOIS DO RECALCULO FISCAL")
//Inicializa nValRes para receber total de itens reserva atualizado com descontos proporcionais
nValRes := 0
Begin Transaction

DbSelectArea("SF4")
SF4->(DbSetOrder(1)) // F4_FILIAL+F4_CODIGO

DbSelectArea("SL2")

For nPos := 1 to nQtdItens
	
	SF4->(DbSeek(xFilial("SF4") + aItens[nPos][__TES])) //Posiciona TES para verIficar se a apuracao eh pelo bruto ou liquido 
	SL2->(DbGoto(aItens[nPos][__RECNO])) // Posiciona no Item da Venda

	RecLock("SL2", .F.)

	If lAtuDesc
		REPLACE L2_VRUNIT  WITH aItens[nPos][__VRUNIT]
		REPLACE L2_VLRITEM WITH aItens[nPos][__VLRITEM]
		REPLACE L2_DESCPRO WITH aItens[nPos][__DESCPRO] + aItens[nPos][__DESCFIN]		//Desconto Total + Desconto Financeiro
    EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualizacao dos campos do SL2 com o calculo dos impostos retornados   ³
	//³ pela MATXFIS                                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lIntegDef .And. MaFisFound("IT", nPos) //Integracao mantem os impostos informados
		//Apos a atualizacao, retiro os valores de ISS, ICMS e IPI para atualizacao da base
		REPLACE L2_VALISS  WITH MaFisRet(nPos,"IT_VALISS")
		REPLACE L2_BASEICM WITH MaFisRet(nPos,"IT_BASEICM")
		REPLACE L2_VALICM  WITH MaFisRet(nPos,"IT_VALICM")
		REPLACE L2_VALIPI  WITH MaFisRet(nPos,"IT_VALIPI")
		REPLACE L2_BRICMS  WITH MaFisRet(nPos,"IT_BASESOL")
		REPLACE L2_ICMSRET WITH MaFisRet(nPos,"IT_VALSOL")
		REPLACE L2_CF 	   With MaFisRet(nPos,"IT_CF")

		/*
		FRETE
		- quando a venda for somente Retira, o valor do frete sera distribuido em todos os itens da venda
		- quando a venda for do tipo mista (retira e outro tipo de entrega), o valor do frete será distribuido
		entre os itens que NAO sao do tipo Retira
		*/
		If ( lRatFrete .AND. SL2->L2_ENTREGA $ "1|3" ) .OR. !lRatFrete
			nFreteSl2 := MaFisRet(nPos,"IT_FRETE")   //Armazena valor frete
			nSegurSl2 := MaFisRet(nPos,"IT_SEGURO")  //Armazena valor seguro
			nDespeSl2 := MaFisRet(nPos,"IT_DESPESA") //Armazena valor despesa
			
			//Acumulador despesas
			nTotFrete += nFreteSl2
			nTotSegur += nSegurSl2
			nTotDespe += nDespeSl2
			
			//Tratamento de arredondamento das despesas, maximo para diferenca de 5 centavos
			//Ajusta apenas Venda Assistida e no ultimo registro de entrega/retira posterior
			If !lJob .And. nPos == nLastDesp									
				//Frete
				nItDifere := nTotFrete - SL1->L1_FRETE //Diferenca entre totalizador frete e SL1 
				
				If nItDifere > 0 .And. Abs(nItDifere) <= 0.05 //Acumulado de frete maior que o conteudo armazenado na SL1, necessario diminuir  
					nFreteSl2 -= Abs(nItDifere) 
				ElseIf nItDifere < 0 .And. Abs(nItDifere) <= 0.05 //Acumulado de frete menor que o conteudo armazenado na SL1, necessario aumentar
					nFreteSl2 += Abs(nItDifere)
				EndIf
			
				//Seguro
				nItDifere := nTotSegur - SL1->L1_SEGURO //Diferenca entre totalizador frete e SL1 
				
				If nItDifere > 0 .And. Abs(nItDifere) <= 0.05 //Acumulado de seguro maior que o conteudo armazenado na SL1, necessario diminuir  
					nSegurSl2 -= Abs(nItDifere) 
				ElseIf nItDifere < 0 .And. Abs(nItDifere) <= 0.05 //Acumulado de seguro menor que o conteudo armazenado na SL1, necessario aumentar
					nSegurSl2 += Abs(nItDifere)
				EndIf
			
				//Despesa
				nItDifere := nTotDespe - SL1->L1_DESPESA //Diferenca entre totalizador despesa e SL1 
				
				If nItDifere > 0 .And. Abs(nItDifere) <= 0.05 //Acumulado de seguro maior que o conteudo armazenado na SL1, necessario diminuir  
					nDespeSl2 -= Abs(nItDifere) 
				ElseIf nItDifere < 0 .And. Abs(nItDifere) <= 0.05 //Acumulado de seguro menor que o conteudo armazenado na SL1, necessario aumentar
					nDespeSl2 += Abs(nItDifere)
				EndIf
			EndIf  
			
			REPLACE L2_VALFRE  WITH nFreteSl2
			REPLACE L2_SEGURO  WITH nSegurSl2
			REPLACE L2_DESPESA WITH nDespeSl2
			LjGrvLog(SL1->L1_NUM,"LOGFRET - Soma Rectrib Frete+Seguro+Despesa",nFreteSl2+nSegurSl2+nDespeSl2)
		ElseIf !lJob
			//Se Venda Assistida, item retira e venda possui reserva, zera rateio frete, seguro e despesa dos itens retira
			REPLACE L2_VALFRE  WITH 0
			REPLACE L2_SEGURO  WITH 0
			REPLACE L2_DESPESA WITH 0
		EndIf

		REPLACE L2_VALACRS With aItens[nPos][__ACRSFIN]
		
		If Len(aAlqLeiTr) == 4 .OR. !(cMvFisAlCT == "3" .AND. cMvFisCTrb == "2")      
           If lCpoTotImp
               REPLACE L2_TOTIMP With noRound(((L2_VLRITEM +L2_VALFRE+ L2_SEGURO+ L2_DESPESA) * aItens[nPos][__TOTIMP])/100 ,nDecsAux )
               nTotImpNCM      +=SL2->L2_TOTIMP
               nTotVLRNCM      +=SL2->L2_VLRITEM +L2_VALFRE+ L2_SEGURO+ L2_DESPESA
           EndIf
          
           If lCpoImpEnt       
               REPLACE L2_TOTFED With noRound(((L2_VLRITEM +L2_VALFRE+ L2_SEGURO+ L2_DESPESA) * aItens[nPos][__TOTIMPFED])/100 ,nDecsAux )
               nTotImpFED      +=SL2->L2_TOTFED
    
               REPLACE L2_TOTEST With noRound(((L2_VLRITEM +L2_VALFRE+ L2_SEGURO+ L2_DESPESA) * aItens[nPos][__TOTIMPEST])/100 ,nDecsAux )
               nTotImpEST      +=SL2->L2_TOTEST
    
               REPLACE L2_TOTMUN With noRound(((L2_VLRITEM +L2_VALFRE+ L2_SEGURO+ L2_DESPESA) * aItens[nPos][__TOTIMPMUN])/100 ,nDecsAux )
               nTotImpMUN      +=SL2->L2_TOTMUN
           EndIf
		ElseIf Len(aAlqLeiTr) == 8
    		If lCpoTotImp
    			REPLACE L2_TOTIMP With aItens[nPos][__TOTIMP]
    			nTotImpNCM 		+=SL2->L2_TOTIMP
    			nTotVLRNCM 		+=SL2->L2_VLRITEM +L2_VALFRE+ L2_SEGURO+ L2_DESPESA
    		EndIf
    
    		If lCpoImpEnt  		
    			REPLACE L2_TOTFED With aItens[nPos][__TOTIMPFED]
    			nTotImpFED		+=SL2->L2_TOTFED
    
    			REPLACE L2_TOTEST With aItens[nPos][__TOTIMPEST]
    			nTotImpEST		+=SL2->L2_TOTEST
    
    			REPLACE L2_TOTMUN With aItens[nPos][__TOTIMPMUN]
    			nTotImpMUN		+=SL2->L2_TOTMUN
    		EndIf       
       EndIf    
       		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Para o acerto de PIS e COFINS (retencao e apuracao pelo liquido), faz-se necessario alterar           ³
		//³a base de calculo atraves da funcao MAFISALT, visto que valores que sao acrescidos aos itens vendidos,³
		//³sao escolhidos apos ja' ter sido calculado o imposto.                                                 ³
		//³Acerta valores de Cofins, quando retencao ou apuracao pelo liquido                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        If (SL2->(ColumnPos("L2_BASECF2"))  > 0 .AND. SL2->(ColumnPos("L2_VALCF2")) > 0);
        	.AND. (SA1->A1_RECCOFI == "S" .OR. SF4->F4_COFBRUT <> "1") .AND. SF4->F4_PISCOF <> "4"
			REPLACE L2_BASECF2 WITH MaFisRet(nPos,"IT_BASECF2")
			REPLACE L2_VALCF2  WITH MaFisRet(nPos,"IT_VALCF2")
	    EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Acerta valores de Pis, quando retencao ou apuracao pelo liquido³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (SL2->(ColumnPos("L2_BASEPS2")) > 0 .AND. SL2->(ColumnPos("L2_VALPS2")) > 0);
			.AND. (SA1->A1_RECPIS == "S" .OR. SF4->F4_PISBRUT <> "1") .AND. SF4->F4_PISCRED <> "3"
			REPLACE L2_BASEPS2 WITH MaFisRet(nPos,"IT_BASEPS2")
			REPLACE L2_VALPS2  WITH MaFisRet(nPos,"IT_VALPS2")
        EndIf
	EndIf
	
	//Integracao - Transparencia Fiscal
	If lIntegDef 
		nPosTotFed := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_TOTFED"})
		REPLACE L2_TOTFED With noRound(aColsDet[nPos][nPosTotFed], nDecsAux)  		
		nTotImpFED	 += SL2->L2_TOTFED
		
		nPosTotEst := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_TOTEST"})	
		REPLACE L2_TOTEST With noRound(aColsDet[nPos][nPosTotEst], nDecsAux) 		
		nTotImpEST	 += SL2->L2_TOTEST 
		
		nPosTotMun  := Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_TOTMUN"})
		REPLACE L2_TOTMUN With noRound(aColsDet[nPos][nPosTotMun], nDecsAux)		
		nTotImpMUN	 += SL2->L2_TOTMUN 
		
		SL2->L2_TOTIMP := SL2->L2_TOTFED + SL2->L2_TOTEST + SL2->L2_TOTMUN
	EndIf 
	
	SL2->(MsUnlock())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Acumula os Descontos / Acrescimos para gravacao do SL1³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nDescTot += aItens[nPos][__DESCPRO]  					// Desconto Total
	nVlrDesc += aItens[nPos][__DESCFIN]						// Desconto Financeiro
	nVlrAcrs += aItens[nPos][__ACRSFIN]						// Acrescimo Financeiro

	cFilReserva := Posicione("SLJ",1,xFilial("SLJ")+SL2->L2_LOJARES,"LJ_RPCFIL")

	If ( SL2->L2_ENTREGA $ "1|3" ) .OR. (SL2->L2_ENTREGA == "2"	.AND. IIf(!Empty(SLJ->LJ_RPCFIL), SLJ->LJ_RPCFIL <> xFilial("SL1"),.F.)) // Armazena o valor dos itens de reserva
		nValRes += SL2->L2_VLRITEM
	EndIf

  	If lGE .AND. (SuperGetMv("MV_LJIMPGF",,.F.) .AND. !Empty(SL2->L2_GARANT)) .OR. !Empty(cCodProGar)

  		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Rotina Garantia Estendida para tratamento, se caso seja ³
		//³produto Garantia Estendida, soma o Valor do mesmo aos   ³
		//³totalizadores nValRes de valor de Reserva para constar  ³
		//³no Cupom Não fiscal.                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Empty(cCodProGar)
			cCodProGar := SL2->L2_GARANT
	   	ElseIf cCodProGar == SL2->L2_PRODUTO
	   		nValRes += SL2->L2_VLRITEM
	   		cCodProGar := ""
	   	EndIf
   	EndIf
   	
   	If lL2FECP
		REPLACE L2_ALQFECP WITH MaFisRet(nPos, "IT_ALIQFECP")
		REPLACE L2_VALFECP WITH MaFisRet(nPos, "IT_VALFECP")
	EndIf
	
	If lL2FECPST
        REPLACE L2_ALQFCST WITH MaFisRet(nPos, "IT_ALFCST")
        REPLACE L2_VFECPST WITH MaFisRet(nPos, "IT_VFECPST")	           
	EndIf
Next nPos

End Transaction

LjGrvLog(SL1->L1_NUM,"DEPOIS DA ATUALIZACAO DO SL2")

If lFisFound
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ajuste da gravacao dos dados do SL1 para a venda                                                 ³
	//³                                                                                                  ³
	//³ Exemplo de gravavao dos campos                                                                   ³
	//³ Venda de 1 item de R$100,00 com:                                                                 ³
	//³                          L1_VLRTOT   L1_DESCONT   L1_VLRLIQ   L1_VALBRUT   L1_VALMERC  L1_JUROS  ³
	//³ Acresc.financ de 10%        100.00         0.00      110.00      110.00       100.00      10.00  ³
	//³ Descon.financ de 10%        100.00         0.00       90.00       90.00       100.00       0.00  ³
	//³ Descon.total  de 10%         90.00        10.00       90.00       90.00       100.00       0.00  ³
	//³ Descon.item   de 10%         90.00         0.00       90.00       90.00       100.00       0.00  ³
	//³	                                                                                                 ³
	//³ Obs.1: A gravacao dos campos tem como base a gravacao da Venda Balcao para mantermos             ³
	//³ o legado das customizacoes.                        ³                                             ³
	//³                                                                                                  ³
	//³ Obs.2: Nao eh necessario dar um RecLock no SL1, pois esta preso desde o inicio da rotina         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lIntegDef
		nVlrIPI := SL1->L1_VALIPI
		nValSol := SL1->L1_ICMSRET
	Else
		nVlrIPI := MaFisRet(,"NF_VALIPI")
		nValSol := IF(lJob,MaFisRet(,"NF_VALSOL"),nTotValSol)
	EndIf
	nNFTotal	:= MaFisRet(,"NF_TOTAL")
	nLj7TDescV	:= IIf(ExistFunc("LjNewCalSol") .And. LjNewCalSol() ,0, nDescTot)
	lMaSUFRAMA	:= MaFisRet(,"NF_SUFRAMA")
	
	DbSelectArea( "SL1" )
	aSL1 := {}
		
	If !lMaSUFRAMA			
		/*Se trabalhar com o conceito de acrescimo separado,
		nao grava o acrescimo no valor do cupom, pois o    
		mesmo sera gravado no Contas a receber (SE1)       */
		If lVerEmpres .OR. (SuperGetMV("MV_LJICMJR",,.F.) .AND. cPaisLoc == "BRA")
			aAdd( aSL1, { "L1_VLRTOT",      SL1->L1_VALMERC - nDescItens - nDescTot + nVlrIPI + nValSol}) 
			aAdd( aSL1, { "L1_VLRLIQ",		SL1->L1_VALMERC + nFreDesSeg - nVlrDesc - nDescTot - nDescItens + nVlrIPI + nValSol })
			nL1VALBRUT := SL1->L1_VALMERC + nFreDesSeg - nVlrDesc - nDescTot - nDescItens + nVlrIPI + nValSol
			aAdd( aSL1, { "L1_VALBRUT",		nL1VALBRUT })
		Else
			aAdd( aSL1, { "L1_VLRTOT",      SL1->L1_VALMERC - nDescItens - nDescTot + nVlrIPI + nVlrAcrs + nValSol}) 
			aAdd( aSL1, { "L1_VLRLIQ",		SL1->L1_VALMERC + nVlrAcrs + nFreDesSeg - nVlrDesc - nDescTot - nDescItens + nVlrIPI + nValSol })
			nL1VALBRUT := SL1->L1_VALMERC + nVlrAcrs + nFreDesSeg - nVlrDesc - nDescTot - nDescItens + nVlrIPI + nValSol
			aAdd( aSL1, { "L1_VALBRUT",		nL1VALBRUT })
		EndIf
		
		aAdd( aSL1, { "L1_BRICMS",  MaFisRet(,"NF_BASESOL") } )
        aAdd( aSL1, { "L1_ICMSRET", nValSol } )
	Else
        aAdd( aSL1, { "L1_VLRTOT",  nNFTotal - nDescItens - nLj7TDescV + nVlrIPI }) 
        aAdd( aSL1, { "L1_VLRLIQ",  nNFTotal + nVlrAcrs + nFreDesSeg - nVlrDesc - nLj7TDescV - nDescItens + nVlrIPI })
        nL1VALBRUT := (MaFisRet(,"NF_VALMERC")) + nVlrAcrs + nFreDesSeg - nVlrDesc - nDescTot - nDescItens + nVlrIPI            
        aAdd( aSL1, { "L1_VALBRUT",     nL1VALBRUT })       
	EndIf			
		
	If lFtvdVer12
	   aAdd( aSL1, { "L1_DESCONT", nDescTot  } )
	EndIf
	
	If !lIntegDef
       aAdd( aSL1, { "L1_VALIPI",       MaFisRet(,"NF_VALIPI") } )
    EndIf
	
	aAdd( aSL1, { "L1_VALICM",		MaFisRet(,"NF_VALICM") } )
	aAdd( aSL1, { "L1_VALISS",		MaFisRet(,"NF_VALISS") } )
	
	Lj7GeraSL( "SL1", aSL1, .F., .F. )
EndIf

Return NIL

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funo    ³L7CriaCxa ³ Autor ³ Vendas Clientes       ³ Data ³ 09/01/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ VerIfica se caixa existe(tratamento multi-moeda).O portador³±±
±±³          ³do titulo(caixa) e definido pela moeda                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1 := L7CriaCxa(ExpN1,ExpC2,ExpC3,ExpC4)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 - Moeda do titulo                                    ³±±
±±³          ³ ExpC2 - Codigo do Caixa logado                             ³±±
±±³          ³ ExpC3 - Codigo da agencia do Caixa                         ³±±
±±³          ³ ExpC4 - Codigo da conta do Caixa                           ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function L7CriaCxa( nMoeda , cCodigo , cAgencia , cConta )

//retiramos o corpo dessa funcao, pois a funcao abaixo eh identica.
LjxDVerCx(nMoeda,cCodigo,cAgencia,cConta)	//LOJXFUND.PRW

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7PrepGrvºAutor  ³Vendas Clientes     º Data ³  09/01/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Prepara os arrays utilizados na gravacao dos impostos      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7PrepGrvImp()
Local aDadosImps  := {}
Local aImposto    := {}
Local nPosDtTes	  := Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_TES"}) 		// Posicao do Codigo do TES
Local nPosItem		:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_ITEM"})][2]		// Posicao do numero do item
Local nPosProd		:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_PRODUTO"})][2]	// Posicao do Codigo do produto
Local nPosQuant		:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_QUANT"})][2]		// Posicao da Quantidade
Local nPosVrUnit	:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_VRUNIT"})][2]		// Posicao do Valor unitario do item
Local nValImp     := 0
Local nValBas     := 0
Local nTotImp     := 0
Local nX          := 0
Local nI 		  := 0
Local nE          := 0
Local nPosCpo     := 0

aImpsSL1 := {}
aImpsSL2 := {}

For nX := 1 To Len(aCols)
	If !aCols[nX][Len(aHeader)+1]
		aDadosImps := TesImpInf(aColsDet[nX][nPosDtTes])
		AAdd(aImpsSL2,{aCols[nX][nPosProd],aColsDet[nX][nPosDtTes],{}})
		For nI := 1 To Len(aDadosImps)
		  	If (nE := Ascan( aImpsSL1,{|x| x[1] == aDadosImps[nI,1]})) == 0
		       	AAdd(aImpsSL1,{aDadosImps[nI][1],"L1_"+Substr(aDadosImps[nI][6],4,7),0,"L1_"+Substr(aDadosImps[nI][8],4,7),0,aDadosImps[nI][3],aDadosImps[nI][9],0})
				nE := Len(aImpsSL1)
		  	EndIf
		    cIndImp := Substr(aDadosImps[nI][2],10,1)
		  	nPosCpo := aScan(aHeaderDet,{|x| Trim(x[2]) == "LR_VALIMP"+cIndImp})
		    nValImp := aColsDet[nX][nPosCpo]
		  	nPosCpo := aScan(aHeaderDet,{|x| Trim(x[2]) == "LR_BASIMP"+cIndImp})
		  	nValBas := aColsDet[nX][nPosCpo]

		   	Lj7GeraImp( @aImposto            , aDadosImps[nI] , nValImp , aCols[nX][nPosQuant] , ;
		   	            aCols[nX][nPosVrUnit], 1              , cIndImp , nValBas               )

		   	AAdd(aImpsSL2[Len(aImpsSL2)][3],aClone(aImposto))
		   	nTotImp += (nValImp * aImposto[10,Val(SubStr(aImposto[5],2,1))])
		   	aImpsSL1[ nE,3 ] += A410Arred(aImpsSL2[len(aImpsSL2)][3][nI][4],"L1_VALIMP1",nMoedaCor)	//Valor do imposto no cabecalho
		   	aImpsSL1[ nE,5 ] += aImpsSL2[len(aImpsSL2)][3][nI][3]										//Base do imposto no cabecalho
		   	aImpsSL1[ nE,8 ] += nValImp 				   		   										//Total sem arredondamento
		Next nI
		AAdd(aImpsSL2[Len(aImpsSL2)],aCols[nX][nPosItem])
		AAdd(aImpsSL2[Len(aImpsSL2)],.F.)
	Else
		If !Empty(aCols[nX][nPosProd])
			AAdd(aImpsSL2,{aCols[nX][nPosProd],aColsDet[nX][nPosDtTes],{}})
		EndIf
	EndIf
Next nX

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7GeraImpºAutor  ³Vendas Clientes     º Data ³  09/01/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Gera o array com os dados dos impostos incidentes em um    º±±
±±º          ³ determinado produto                                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7GeraImp( aImposto , aInfo, nValImp , nQuant , ;
                     nVlrUnit , nX   , cIndImp ,nValBas )

Local cCpoVlrItem := ""
Local cCpoBaseIte := ""
Local cCpoVlrCab  := ""
Local cCpoBaseCab := ""

cCpoVlrItem := "L2_"+SubStr(aInfo[2],4,7)   //Campo de gravacao do valor do imposto no item
cCpoBaseIte := "L2_"+SubStr(aInfo[7],4,7)   //Campo de gravacao da base do imposto no item
cCpoVlrCab  := "L1_"+SubStr(aInfo[6],4,7)   //Campo de gravacao do valor do imposto no cabecalho
cCpoBaseCab := "L1_"+SubStr(aInfo[8],4,7)   //Campo de gravacao da base do imposto no cabecalho

aImposto := {}                   //Limpa o array para que armazene somente os
 						         //dados do imposto que está sendo calculado

AAdd( aImposto, aInfo[1] )       							//Codigo do imposto
AAdd( aImposto, aInfo[9] )       							//Aliquota do imposto
AAdd( aImposto, nValBas )        							//Base do Imposto
AAdd( aImposto, a410Arred(nValImp,"L2_VALIMP1",nMoedaCor)) 	//Valor do imposto - F1CHI
AAdd( aImposto, aInfo[4] + aInfo[3] + aInfo[5] )   		//FC_INCDUPL/FC_INCNOTA/FC_CREDITA
AAdd( aImposto, cCpoVlrItem )
AAdd( aImposto, cCpoBaseIte )
AAdd( aImposto, cCpoVlrCab )
AAdd( aImposto, cCpoBaseCab )
AAdd( aImposto, {1,-1,0} )
AAdd( aImposto, nQuant )
AAdd( aImposto, nVlrUnit )

Return( Nil )


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³Lj7DocsCF ³ Autor ³Vendas Clientes        ³ Data ³ 23/01/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Tela para digitacao de documentos para clientes tipo Consu-³±±
±±³          ³ midor Final cuja venda seja superior ao determinado no pa- ³±±
±±³          ³ rametro MV_LIMCFIS                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ Lj7DocsCF()                 							      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Venda Assistida (Loc. Argentina)                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj7DocsCF(aDadosCF)
Local lRet      := .F.
Local cCbxTpDoc := ""
Local nPosDocCF
Local aTipoDoc  := {}
Local aTipoCI   := {}
Local aAreaSX3  := {}
Local aAreaSX5  := {}
Local aArea     := GetArea()
Local oDlgLojaDocs
Local oTipoDoc
Local oTipoCI
Local aDadosCFPE:= {}

DbSelectArea("SX3")
aAreaSX3 := GetArea()
DbSetOrder(2)
If DbSeek("LS_TPDOCCF")
   cCbxTpDoc  := X3CBox()  //O combo box pode variar de impressora para impressora
EndIf
RestArea(aAreaSx3)

While .T.
   nPosDocCF  := At(";",cCbxTpDoc)
   If !Empty(cCbxTpDoc)
      If nPosDocCF > 0  //Preenche no array aTipoDoc com as opcoes disponiveis
         Aadd(aTipoDoc,Substr(cCbxTpDoc,1,nPosDocCF-1))
      Else //Ultimo elemento
         nPosDocCF  := Len(cCbxTpDoc)
         Aadd(aTipoDoc,Substr(cCbxTpDoc,1,nPosDocCF))
         Exit
      EndIf
      cCbxTpDoc  := Substr(cCbxTpDoc,nPosDocCF+1)
   Else
      Exit
   EndIf
End
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Busca os tipos de CI na tabela "OC" do arq. SX5³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SX5")
aAreaSX5 := GetArea()
If DbSeek(xFilial("SX5")+"OC")
   While xFilial("SX5")+"OC" == SX5->X5_FILIAL+AllTrim(SX5->X5_TABELA)
      If Substr(X5Descri(),4,3) == "CI "
         Aadd(aTipoCI,Substr(X5Descri(),1,2)+"-"+Substr(X5Descri(),4))
      EndIf
      DbSkip()
   End
EndIf
RestArea(aAreaSX5)

DEFINE MSDIALOG oDlgLojaDocs FROM 12, 14 TO 23, 80 TITLE STR0036; //"Dados para Consumidor Final"
STYLE nOr( DS_MODALFRAME, WS_DLGFRAME ) OF oDlgVA

@ 00.3 , 01 TO 5,31.2 OF oDlgLojaDocs

@ 01.0 , 01.5 SAY STR0037 //"Tipo do Documento"
@ 12.0 , 69.5 MSCOMBOBOX oTipoDoc VAR aDadosCF[2] ITEMS aTipoDoc OF oDlgLojaDocs SIZE 92,40 ON CHANGE Lj7TipoDoc(aDadosCF[2],oTipoCI) PIXEL

//Tipo CI
@ 12.0 , 163  MSCOMBOBOX oTipoCI VAR aDadosCF[3] ITEMS aTipoCI OF oDlgLojaDocs SIZE 82,40 PIXEL
oTipoCI:Hide()

If ExistBlock("LJDocCF")
	aDadosCFPE := {aDadosCF[2],aDadosCF[3],aDadosCF[1],aDadosCF[4],aDadosCF[6]}
	aDadosCFPE := ExecBlock( "LJDocCF", .F., .F., {aDadosCFPE, aTipoDoc, aTipoCI} )

	aDadosCF[2] := aDadosCFPE[1]
	aDadosCF[3] := aDadosCFPE[2]
	aDadosCF[1] := aDadosCFPE[3]
	aDadosCF[4] := aDadosCFPE[4]
	aDadosCF[6] := aDadosCFPE[5]

	Lj7TipoDoc(aDadosCF[2],oTipoCI) //Chama funcao para verificar se ativa ou nao o segundo ComboBox para apresentar o Tipo de Documento CI
EndIf

@ 02.0 , 01.5 SAY STR0038 //"Numero do Documento"
@ 25.0 , 69.5 MSGET aDadosCF[1] RIGHT SIZE 92,10 OF oDlgLojaDocs PIXEL PICTURE PesqPict("SLS","LS_DOCCF") VALID LjVlNumDoc(aDadosCF[1])

@ 03.0 , 01.5 SAY STR0039 //"Nome do Cliente"
@ 37.0 , 69.5 MSGET aDadosCF[4] RIGHT SIZE 175,10 OF oDlgLojaDocs PIXEL

@ 04.0 , 01.5 SAY STR0040 //"Endereco"
@ 49.0 , 69.5 MSGET aDadosCF[6] RIGHT SIZE 175,10 OF oDlgLojaDocs PIXEL


DEFINE SBUTTON FROM 70,103 TYPE 1 ACTION (If(Lj7VldCF(aDadosCF),lRet := .F.,;
(lRet:= .T.,If(aDadosCF[2]<>"6",aDadosCF[3] := "",aDadosCF[3] := Substr(aDadosCF[3],1,2));
,oDlgLojaDocs:End()))) ENABLE OF oDlgLojaDocs

DEFINE SBUTTON FROM 70,136 TYPE 2 ACTION (lRet:= .F.,oDlgLojaDocs:End()) ENABLE OF oDlgLojaDocs

ACTIVATE MSDIALOG oDlgLojaDocs

RestArea(aArea)

Return (lRet)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³Lj7VldCF  ³ Autor ³ Vendas Clientes       ³ Data ³ 23/01/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ VerIfica se todos os dados do Cliente foram digitados na   ³±±
±±³          ³ tela quando Consumidor Final e venda > MV_LIMCFIS          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ Lj7VldCF()                 							      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Venda Assistida (Loc. Argentina)                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj7VldCF(aDadosCF)
Local lRet  := .F.

If ExistBlock("LJVldCF")
	lRet := !ExecBlock( "LJVldCF", .F., .F., { aDadosCF  })
EndIf

If !lRet
	lRet := Empty(aDadosCF[2]) .OR. Empty(aDadosCF[1]) .OR. Empty(aDadosCF[4]) .OR. Empty(aDadosCF[6])
EndIf

If lRet
	lRet := LjVlNumDoc(aDadosCF[1])
EndIf

Return (lRet)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³Lj7TipoDoc³ Autor ³ Vendas Clientes       ³ Data ³ 23/01/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Tratamento para tipo de documento CI                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ Lj7TipoDoc(cTipoDocCF,oTipoCI)							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Venda Assistida (Loc. Argentina)                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj7TipoDoc(cTipoDocCF,oTipoCI)

If cTipoDocCF == "6"  //CI
   oTipoCI:Show()
Else
   oTipoCI:Hide()
EndIf
oTipoCI:Refresh()

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³Lj7SerArg    ³ Autor ³ Vendas Clientes       ³Data  ³29/01/04  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Indica a serie da fatura/cupom fiscal dependendo do tipo de   ³±±
±±³          ³ cliente(Loc. Argentina)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpL1 := Lj7SerArg()                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpC1 := Serie                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Venda Assistida     									         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Lj7SerArg()
Local cTipoCli   := ""
Local cSerieDoc
Local lIntSynt 	 := SuperGetMV("MV_LJSYNT",,"0") == "1"	 // Informa se a integracao Synthesis esta ativa

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Relacao Tipo de Cliente x Serie  ³
//ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
//³Tipo Cliente      ³ Serie        ³
//ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
//³E(Exportacao)   	 ³ E		    ³
//³F(Cons. Final)    ³ B            ³
//³M(Monotrib.)      ³ B            ³
//³N(Resp.Nao Insc.) ³ B            ³
//³S(Nap Sujeito)    ³ B            ³
//³X(Isento) 	     ³ B            ³
//³I(Inscrito)       ³ A            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type("M->LQ_CLIENTE") <> "U" .AND. Type("M->LQ_LOJA") <> "U"
	cTipoCli  := Posicione( "SA1",1,xFilial("SA1")+M->LQ_CLIENTE+M->LQ_LOJA,"SA1->A1_TIPO" )
Else
	cTipoCli  := Posicione( "SA1",1,xFilial("SA1")+SL1->L1_CLIENTE+SL1->L1_LOJA,"SA1->A1_TIPO" )
EndIf

If cTipoCli == "E"
   cSerieDoc := "E"
ElseIf cTipoCli $ "F|M|N|S|X"
   cSerieDoc := "B"
Else
   cSerieDoc := "A"
EndIf

If lIntSynt .AND. !Empty(SL1->L1_SERIE)
	cSerieDoc := SL1->L1_SERIE
EndIf

Return (cSerieDoc)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ LJ7ImpCH ³ Autor ³  Vendas Clientes      ³ Data ³26/03/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Realiza impressao do cheque                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LJ7ImpCH(aImpCheque)
Local nI		:= 0		//controle de loop
Local lTemCH	:= .F.
Local cObs		:= ""
Local cVerso	:= ""
Local cFavorec
Local cCidade
Local cBanco
Local nValor
Local dEmissao
Local cAgencia
Local cConta
Local cCheque

For nI := 1 To Len(aPgtos)
	If AllTrim(aPgtos[nI][3]) == AllTrim(MVCHEQUE)
		lTemCH := .T.
		Exit
	EndIf
Next nI

If lTemCH
	// Em caso do Nome Comercial(SM0->M0_NOMECOM) estar preenchido, o mesmo sera atribuido para impressao da informacao Favorecido.
	cFavorec := If(Empty(SM0->M0_NOMECOM),SM0->M0_NOME,SM0->M0_NOMECOM)
	cCidade  := Left(SM0->M0_CIDCOB,15)
	cCidade  := If(Empty(cCidade), "Sao Paulo", cCidade)
	For nI := 1 To Len(aPgtos)
		If AllTrim(aPgtos[nI][3]) == AllTrim(MVCHEQUE)
			cBanco   := Substr(aPgtos[nI][4][4],1,3)
			nValor   := aPgtos[nI][2]
			If SuperGetMV("MV_DATCHE") == "E"
				dEmissao := dDataBase
			Else
				dEmissao := aPgtos[nI][1]
			EndIf
			cAgencia := aPgtos[nI][4][5]
			cConta   := aPgtos[nI][4][6]
			cCheque  := aPgtos[nI][4][7]
			LjImpCheque( cBanco      ,cAgencia  ,cConta   ,cCheque   ,;
			             @nValor     ,@cFavorec ,@cCidade ,@dEmissao ,;
			             @cObs       ,@cVerso   ,   .F.   ,     nI   ,;
			             @aImpCheque )
		EndIf
	Next nI
EndIf

Return NIL

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funo    ³LJ7ConfAdm  ³ Autor ³ Vendas Clientes     ³ Data ³ 16.09.04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Atualiza a descricao da adiministrada de cartos em uma     ³±±
±±³          ³ transacao TEF, qdo selecionada uma ADM <> da utilizada     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ LOJA701C                                                   ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LJ7ConfAdm( cAdmUti	, cAdmRet	, lSemRede 	, cFormaCart ,;
					 cIdCartao 	, cTipCart	, nParcelas	, cDescCart	 ,;
					 lTefManual , nNumTrans , lGeraLog	, cRedeRet	 ,;
					 cValorForm , cCodRede  , lSelTefManu)
Local aArea 		:= GetArea()
Local cReturn 		:= ""
Local cAdmVer		:= ""
Local nPos 			:= 0
Local lAdmIgual		:= .T.
Local xRet										// Retorno do Execblock LJ7019
Local lRet			:= .T.
Local nPosAdm		:= 0
Local aTpAdms		:= {}
Local lSelAdm       := SuperGetMv("MV_LJADMFI",,.F.)   			// Parametro que desabilita a escolha das administradoras de cartoes
Local aTefInf		:= {}
Local aRet			:= {}
Local nLinAdm		:= 0
Local nTamAE_TIPO	:= TamSx3("AE_TIPO")[1]		// Tamanho do AE_TIPO
Local aDadosSae		:= {}      					// Guarda os dados da Adm Financeira
Local nPosSAE		:= 1                        // Guarda a posicao da Adm FInanceira no array aDadosSae
Local cRetPrior1	:= ""
Local cRetPrior2	:= ""

Local cInstitu	:= ""
Local cTEFBand	:= ""
Local cAdmGeneri	:= Alltrim(SuperGetMV("MV_LJADMGN",,""))
Local lAEREDEAUT	:= SAE->(ColumnPos("AE_REDEAUT")) > 0
Local cBandSITEF	:= ""
Local cDesBandMDE 	:= ""
Local cRedeSITEF	:= ""
Local cDesRedeMDE 	:= ""
Local lPesqNome 	:= .T. //Indica se deve pesquisar a Adm. Financeira por nome
Local nParcDe		:= 0
Local nParcAte		:= 0
Local lContinua		:= .T.
Local cIdCard 		:= If(cIdCartao <> Nil, cIdCartao, "")
Local nTamCODSIT 	:= If(lSelAdm,TamSX3("MDE_CODSIT")[1],0)
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local nS			:= 0


Default cAdmRet	:= ""
Default lSemRede := .F.      // Retorno da rede
Default cFormaCart  := ""    // Tipo de forma dos Cartos do oTef
DEFAULT cTipCart  := "" 	 // Tipo do Cartao
DEFAULT nParcelas := 1  	 // Numero de Parcelas
DEFAULT cDescCart := ""
DEFAULT lTefManual	:= .F.
DEFAULT nNumTrans	:= 0 	//Numero correspondente ao ID da transação (identificador da ordem dos cartões).
DEFAULT cRedeRet	:= ""
DEFAULT lGeraLog	:= .F.
DEFAULT cValorForm 	:= ""
DEFAULT cCodRede 	:= ""
Default lSelTefManu	:= .F.

If Type("lAutoExec") == "U"
	lAutoExec := .F.
EndIf

If Len(cAdmUti) == 3
	DbSelectArea("SAE")
	SAE->(DbSetOrder(1))
	SAE->(DbSeek(xFilial("SAE")+cAdmUti))
	cAdmUti := SAE->AE_COD + " - " + AllTrim(Upper(SAE->AE_DESC))
EndIf

LjGrvLog("", "Administ. Financ. Utilizada:", cAdmUti)
LjGrvLog("", "Administ. Financ. Retornada:", cAdmRet)
LjGrvLog("", "Codigo de retorno Sitef (Bandeira):", cTipCart)
LjGrvLog("", "Codigo de retorno Sitef (Rede):", cCodRede)
LjGrvLog("", "Rede Retornada:", cRedeRet)
LjGrvLog("", "Parcelas:", nParcelas)

If lUsaTEF
	nPosAdm := Ascan(aRetAdmTef,{|x| x[1] == cIdCard .And. x[2] == AllTrim(cFormaCart) })
	If nPosAdm > 0
		cReturn	:= aRetAdmTef[nPosAdm][3] //Retorna a Adm. Financeira ja encontrada/selecionada para este cartao
		lContinua := .F.
	EndIf
Endif

If lContinua
	
	//Tratamento para garantir a seleção correta da administradora financeira ed acordo como número de parcelas//
	If lTefManual .And. lSelTefManu .And. Type("aPgtoSsint") <> "U" .And. Len(aPgtoSsint) > 0
		LjGrvLog("", "Analisando número correto de parcelas", nParcelas)
		For nS := 1 To Len(aPgtoSsint)
			If aPgtoSsint[nS,04] == cIdCartao .And. AllTrim(cFormaCart) == AllTrim(aPgtoSsint[nS,01])   
				nParcelas := aPgtoSsint[nS,02]
				Exit 		
			EndIf
		Next nS
		LjGrvLog("","O número correto de parcelas é: ", nParcelas)
	EndIf

	lRet	:= .F.
	nPos := ( At(" - ", cAdmUti) + 3 )
	cAdmVer := AllTrim(Upper(SubStr(cAdmUti, nPos)))  //-- Administradora selecionada pelo usuário.
	cAdmRet := Alltrim(Upper(cAdmRet))                //-- Administradora retornada pelo TEF (que realmente foi utilizada).

	If ExistBlock("LJ7022") .AND. !lFtvdVer12
		xRet := ExecBlock("LJ7022", .F., .F.,{cAdmVer,cAdmRet,nNumTrans,cRedeRet,cCodRede,cFormaCart,nParcelas})                                          // PE para verificar qual sera o tipo de comparacao
		If ValType(xRet) == "L"
			lRet := xRet
		ElseIf ValType(xRet) == "A"
			lRet 		:= xRet[1]
			cAdmRet 	:= xRet[2]

			If Len(xRet) > 2
				cReturn := xRet[3]

				//Validacao para verificar se o codigo da Adm. Financ. retornada existe
				DbSelectArea("SAE")
				SAE->(DbSetOrder(1))
				If !SAE->(DbSeek(xFilial("SAE")+Left(cReturn,TamSx3("AE_COD")[1])))
					cReturn := "" //Caso nao encontre a Adm Financ. Retornada pelo P.E., limpa a variavel, para que seja feita a busca da Adm. Financ. na tabela SAE
				EndIf
			EndIf

			If Len(xRet) > 3 //Protecao, versao anterior do PE nao estava previsto posicao 4
				cRedeRet:= xRet[4]
			EndIf
		EndIf

		lAdmIgual := (cAdmRet $ cAdmVer) .AND. (cRedeRet $ cAdmVer)

	ElseIf !lFtvdVer12
		lAdmIgual := (cAdmRet $ cAdmVer) .AND. (cRedeRet $ cAdmVer)
	EndIf

	If ExistBlock("FTVD7022") .AND. lFtvdVer12
		xRet := ExecBlock("FTVD7022", .F., .F.)			// PE para verificar qual sera o tipo de comparacao
		If ValType(xRet) == "L"
			lRet := xRet
		EndIf
		If lRet
	 		lAdmIgual := (cAdmRet $ cAdmVer)
		Else
	 		lAdmIgual := (cAdmVer == cAdmRet)
	 	EndIf
	ElseIf lFtvdVer12
		lAdmIgual := (cAdmRet $ cAdmVer) .And. (cRedeRet $ cAdmVer)
	EndIf

	If !lAdmIgual .And. Empty(cReturn)
		If lSelAdm .And. cTipTef == TEF_CLISITEF //Busca pelo codigo de retorno do SITEF
		   LjGrvLog("", "Busca pelo codigo de retorno do SITEF",lSelAdm  )
			DbSelectArea("SAE")
			SAE->(DbSetOrder(1))  
			SAE->(DbSeek(xFilial("SAE")))		
			While !SAE->(Eof()) .AND. SAE->AE_FILIAL == xFilial("SAE")

				nParcDe		:= If(SAE->AE_PARCDE==0,1,SAE->AE_PARCDE)
				nParcAte	:= If(SAE->AE_PARCATE==0,999,SAE->AE_PARCATE)

				If Empty(cFormaCart) .OR. (AllTrim(SAE->AE_TIPO) == AllTrim(cFormaCart))
					If (nParcelas >= nParcDe .AND. nParcelas <= nParcAte)

						DbSelectArea("MDE")
						MDE->(DbSetOrder(1))
						If !Empty(SAE->AE_ADMCART) .And. MDE->(DbSeek(xFilial("MDE")+SAE->AE_ADMCART ))
							cBandSITEF	:= MDE->MDE_CODSIT 	//Codigo da Bandeira (Retornado pelo SITEF)
							cDesBandMDE := MDE->MDE_DESC	//Descricao da Bandeira
						Else
							cBandSITEF	:= Space(nTamCODSIT)
							cDesBandMDE := ""
						EndIf

						LjGrvLog("", "Busca pelo codigo de retorno do SITEF - AE_ADMCART -cBandSITEF",cBandSITEF  )
						LjGrvLog("", "Busca pelo codigo de retorno do SITEF - AE_ADMCART -cDesBandMDE",cDesBandMDE  )

						If lAEREDEAUT //Controle pela Rede que autorizou a transacao TEF
							If !Empty(SAE->AE_REDEAUT) .And. MDE->(DbSeek(xFilial("MDE")+SAE->AE_REDEAUT ))
								cRedeSITEF	:= MDE->MDE_CODSIT 	//Codigo da Rede autorizadora da transação TEF (Retornado pelo SITEF)
								cDesRedeMDE := MDE->MDE_DESC	//Descricao da Rede
							Else
								cRedeSITEF	:= Space(nTamCODSIT)
								cDesRedeMDE := ""
							EndIf
						Else
							cRedeSITEF	:= Space(nTamCODSIT)
						EndIf
						LjGrvLog("", "Busca pelo codigo de retorno do SITEF - Controle pela Rede que autorizou a transacao TEF",lAEREDEAUT  )
						LjGrvLog("", "Busca pelo codigo de retorno do SITEF - AE_REDEAUT -cBandSITEF",cRedeSITEF  )
						LjGrvLog("", "Busca pelo codigo de retorno do SITEF - AE_REDEAUT -cDesBandMDE",cDesRedeMDE  )

						//Verifica se a Bandeira configurada na Adm. Financeira (AE_ADMCART) esta de acordo com o Codigo da Bandeira retornada pelo SiTEF
						If !Empty(cTipCart) .And. !Empty(cBandSITEF) .And. cTipCart <> cBandSITEF
							//Desconsidera este registro, pois a Bandeira Retornada pelo SiTEF eh diferente da Bandeira configurada na Adm. Financeira
							SAE->(DbSkip())
							Loop
						EndIf

						//Verifica se a Rede configurada na Adm. Financeira (AE_REDEAUT) esta de acordo com o Codigo da Rede retornada pelo SiTEF
						If lAEREDEAUT .And. !Empty(cCodRede) .And. !Empty(cRedeSITEF) .And. cCodRede <> cRedeSITEF
							//Desconsidera este registro, pois a Rede Retornada pelo SiTEF eh diferente da Rede configurada na Adm. Financeira
							SAE->(DbSkip())
							Loop
						EndIf

						AAdd(aTpAdms, { AllTrim(SAE->AE_TIPO)							,; //01-Tipo (CC,CD,...)
										SAE->AE_COD+" - "+AllTrim(Upper(SAE->AE_DESC))	,; //02-Codigo e Nome da Adm. Financeira. (Ex. 001 - VISA)
										nParcDe											,; //03-Parcela Inicial
										nParcAte										,; //04-Parcela Final
										SAE->AE_ADMCART									,; //05-Codigo Relacionado a tabela MDE para a Bandeira
										cDesBandMDE										,; //06-Descricao da Bandeira (campo MDE_DESC)
										cBandSITEF										,; //07-Codigo da Bandeira(campo MDE_CODSIT)
										SAE->(Recno())									,; //08-Recno SAE
										cRedeSITEF										,; //09-Codigo da Rede (Campo MDE_CODSIT)
										cDesRedeMDE 									}) //10-Descricao da Rede (campo MDE_DESC)

						cReturn := SAE->AE_COD + " - " + AllTrim(Upper(SAE->AE_DESC))

						//Considera que achou ate este ponto (nao precisa buscar pelo nome) (lPesqNome = .F.),
						//pois pode acontecer de os campos com o código relacionado a bandeira (AE_ADMCART) ou o codigo relacionado a rede (AE_REDEAUT) nao estarem preenchidos, que eh a verificacao feita no IF abaixo
						lPesqNome := .F.

						//Verifica se encontrou a Adm. Financeira exata (Comparando a Bandeira e a Rede configurada na Adm. Financeria com a Bandeira e a Rede retornada pelo SiTEF)
						If cTipCart == cBandSITEF .And. (!lAEREDEAUT .Or. cCodRede == cRedeSITEF)
							lContinua := .F. //Seta a variavel para indicar que nao precisa continuar a busca da Adm. Financeira, pois ja encontrou
							Exit //Se entrou aqui, eh porque encontrou a Adm. Financeira exata, entao abandona o laço
						EndIf

					EndIf

				Endif

				SAE->(DbSkip())
			End
			LjGrvLog("", "Busca pelo codigo de retorno do SITEF =",cReturn  )
		EndIf

		If lPesqNome
			LjGrvLog("", "Busca Administradora Financeira pela Descricao",lPesqNome  )
			//Busca Administradora Financeira pela "Descricao"
			DbSelectArea("SAE")
			SAE->(DbSetOrder(1))
			SAE->(DbSeek(xFilial("SAE")))
			While !SAE->(Eof()) .AND. SAE->AE_FILIAL == xFilial("SAE")
				If Empty(cFormaCart) .OR. (AllTrim(SAE->AE_TIPO) == AllTrim(cFormaCart))
					If (nParcelas >= SAE->AE_PARCDE .AND. nParcelas <= SAE->AE_PARCATE) .OR. (SAE->AE_PARCDE == 0 .AND. SAE->AE_PARCATE == 0)
						//-- Caso encontre a administradora retornada pelo TEF no cad. de administradora ela que será utilizada,
					    //-- caso contrário fica a que o usuário escolheu.
						If AllTrim(Upper(cAdmRet)) $ AllTrim(Upper(SAE->AE_DESC)) .OR. AllTrim(Upper(cAdmRet)) $ AllTrim(Upper(SAE->AE_DESCSE))
							If !Empty(cRedeRet) .AND. (Upper(cRedeRet) $ Upper(SAE->AE_DESC)) .OR. (Upper(cRedeRet) $ Upper(SAE->AE_DESCSE))
								cReturn := SAE->AE_COD + " - " + AllTrim(Upper(SAE->AE_DESC))
								cRetPrior1 := cReturn
								lAdmIgual	:= .T.
								Exit
								If cTipTEF == TEF_DISCADO
							    	AADD(aDadosSae, {SAE->AE_COD, SAE->AE_DESC } )
								EndIf
							Endif
							cReturn := SAE->AE_COD + " - " + AllTrim(Upper(SAE->AE_DESC))
							cRetPrior2 := cReturn
						ElseIf (Type("aTEFDados") == "A" .And. Len(aTefDados)>0 .AND. !lTefOk)
							If cTipTEF == TEF_DISCADO .AND. ("REDE " $ AllTrim(Upper(SAE->AE_DESC)) .OR. "CIELO" $ AllTrim(Upper(SAE->AE_DESC)))
						    	AADD(aDadosSae, {SAE->AE_COD, SAE->AE_DESC } )
						    Endif
						ElseIf lUsaTEF 
							If cTipTEF == TEF_NAO_USADO 
								AADD(aDadosSae, {SAE->AE_COD, SAE->AE_DESC } )
							Endif							
						Endif
					EndIf
	           EndIf
				SAE->(DbSkip())
			End
			LjGrvLog("", "Busca Administradora Financeira pela Descricao =",cReturn  )
		EndIf

		If lContinua
		   LjGrvLog("", "lContinua",lContinua  )
			If !Empty(cRetPrior1)
				cReturn := cRetPrior1
			ElseIf !Empty(cRetPrior2)
				cReturn := cRetPrior2
			Endif

			If lSelAdm .AND. !(cTipTEF == TEF_DISCADO .AND. !Empty(cReturn)) .AND. (cTipTEF <> TEF_NAO_USADO)  // No caso do discado nao tem tela de identificação
			    AADD(aTefInf,{.T.,cTipCart,cAdmRet,cFormaCart,nParcelas,cIdCartao,cCodRede})
				cReturn := FR271AdmFin(NIL,NIL,@aTpAdms,NIL,NIL,aTefInf,lTefManual,lSelTefManu)
			ElseIf lSelAdm .AND. cTipTEF == TEF_NAO_USADO .AND. lUsaTEF
				cReturn := LjSelecAdm(nPosSAE, aDadosSae , cReturn, cIdCartao, cFormaCart, cValorForm)				
			Else
				If cTipTEF == TEF_DISCADO .And. Empty(cRetPrior1) .And. Empty(cRetPrior2)
					If Len(aDadosSae) > 0 .AND. (Empty(cAdmRet) .OR. !lAdmIgual)
						If Empty(cAdmGeneri) .OR. (cAdmRet == "" .AND. cRedeRet =="")
							cReturn 	:= LjSelecAdm(nPosSAE, aDadosSae , cReturn, cIdCartao, cFormaCart, cValorForm)
						Else
							DbSelectArea("SAE")
							SAE->(DbSetOrder(1))  
							If SAE->(DbSeek(xFilial("SAE")+cAdmGeneri))
								cReturn	:= SAE->AE_COD + " - " + AllTrim(Upper(SAE->AE_DESC))
							EndIf
						EndIf
					ElseIf Len(aDadosSae) == 1
						cReturn := aDadosSae[1][1] + " - " + aDadosSae[1][2]
					Endif
				EndIf
	        EndIf
	        LjGrvLog("", "lContinua",cReturn  )
		EndIf
   	EndIf

	lSemRede := Empty( Alltrim(cReturn) )

	If lSemRede
		cReturn := cAdmUti
	EndIf

	AADD(aRetAdmTef,{cIdCard,AllTrim(cFormaCart),cReturn})  // Adiciona o ID e a Adm do cartao
EndIf

RestArea(aArea)
LjGrvLog("", "Retorno da funcao:", cReturn)
Return cReturn

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7CliCRD ºAutor  ³Vendas Clientes     º Data ³  30/05/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Selecao do cliente para integracao com SIGACRD             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ Lj7CliCRD()   											  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ Nenhum                                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ Se cliente encontrado na base de dados                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7CliCRD()
Local aAreaSA1      := SA1->(GetArea())   // Area do Arquivo de Cliente
Local aRetCart      := {}                 // Contem o tipo e numero do documento do cliente da venda
Local aDadosCli     := {}                 // Contem numero do cartao, CNPJ/CPF, codigo e loja do cliente selecionado
Local lCliente 		:= .T.                // Indica se o cliente foi encontrado na base
Local lRet          := .T.               // Define se prossegue a operacao
Local cTpFrete := "" //Tipo do Frete
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local cNomeProg	:= Iif(lFtvdVer12,"FATA701","LOJA701")	//Nome da Rotina

aDadosCli     := {Space(TamSX3("MA6_NUM")[1]),;    //Numero do cartao
                  Space(TamSX3("A1_CGC")[1]),;     //CNPJ/CPF do cliente
                  Space(TamSX3("A1_COD")[1]),;     //Codigo do cliente
                  Space(TamSX3("A1_LOJA")[1])}     //Loja do cliente


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Chamada da tela para selecao do CNPJ/CPF ou numero ³
//³do cartao Private Label                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lRet  := CrdIdentCli(  @aRetCart  ,@aDadosCli  ,@lCliente  ,.T.  ,;
                        NIL        ,NIL )
If lRet
	If !lCliente
		aCrdCliente[2] := aDadosCli[1]  //Numero do cartao
	 	aCrdCliente[1] := aDadosCli[2]  //CNPJ/CPF
	    M->LQ_CLIENTE  := aDadosCli[3]  //Codigo
	    M->LQ_LOJA     := aDadosCli[4]  //Loja
	  	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	  	//³Executa os gatilhos dos campos e as validacoes necessarias³
	 	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	  	If ExistTrigger("LQ_CLIENTE")
	    	RunTrigger(1,Nil,Nil,,"LQ_CLIENTE")
	  	EndIf
	  	If ExistTrigger("LQ_LOJA")
	    	RunTrigger(1,Nil,Nil,,"LQ_LOJA")
	  	EndIf
	    	Lj7ValCli(.F.)
		If !(MaFisFound("NF"))
			cTpFrete := Lj7TpFrete(M->LQ_CLIENTE,M->LQ_LOJA)
			cTpFrete	:= IIf( Empty(cTpFrete) .And. (M->LQ_TPFRET == "S" .OR. M->LQ_TPFRET == "0"), "S", cTpFrete)

	    	MaFisIni( M->LQ_CLIENTE, M->LQ_LOJA, "C", "S",;
	    			 Nil, Nil, Nil, .F.,;
	    			 "SB1", cNomeProg, NIL, NIL,;
		             NIL           , NIL         , NIL ,  NIL , ;
		             NIL           , NIL         , NIL ,  lCalcIPI ,;
		             NIL           , NIL         , NIL ,  NIL , ;
		             NIL				, cTpFrete)

		    IF ExistFunc("LjSatMxFis")
				LjSatMxFis()
			EndIf
	  	EndIf

	Else
    	If aRetCart[1] == 3  //CPF/CNPJ
 			MsgStop(STR0059)   //"Cliente nao encontrado com o numero de documento digitado."
    	EndIf
 		RestArea(aAreaSA1)
   EndIf
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7AprovCRºAutor  ³Vendas Clientes     º Data ³  02/06/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Solicitar a confirmacao e cancelamento da analise de creditoº±±
±±º          ³do cliente                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³Lj7AprovCRD(ExpC1, ExpC2, ExpN3, ExpL4, ExpN5, ExpC6, ExpL7)º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpC1 - Tipo da transacao                                  º±±
±±º          ³ 		   "1" - solicitacao da analise de credito            º±±
±±º          ³ 		   "2" - confirmacao da transacao                     º±±
±±º          ³ 		   "3" - cancelamento da transacao                    º±±
±±º          ³ ExpC2 - Numero do contrato                                 º±±
±±º          ³ ExpN3 - Valor da venda                                     º±±
±±º          ³ ExpL4 - Confirma a transacao?                              º±±
±±º          ³ ExpN5 - Valor financiado                                   º±±
±±º          ³ ExpC6 - VerIfica se deve realizar analise de credito, consiº±±
±±º          ³dera o modulo e o processo(operacao)  					  º±±
±±º          ³ ExpL7 - Modo de consulta?                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ *** Transacao "1" ***                                      º±±
±±º          ³aRet[1] - Retorno da Funcao                                 º±±
±±º          ³              0 - Aprovado                                  º±±
±±º          ³              1 - Nao aprovado                              º±±
±±º          ³              2 - Aprovado Off-line                         º±±
±±º          ³              3 - Rejeitado                                 º±±
±±º          ³              4 - Fila crediario                            º±±
±±º          ³aRet[2] - Valor do limite de credito do cliente             º±±
±±º          ³aRet[3] - Valor dos titulos em aberto do cliente            º±±
±±º          ³aRet[4] - Numero do contrato de credito                     º±±
±±º          ³aRet[5] - Indica se a venda foi rejeitada                   º±±
±±º          ³                                                            º±±
±±º          ³ *** Transacao "2" ***                                      º±±
±±º          ³aRet[1] - 0                                                 º±±
±±º          ³aRet[2] - Array com dados do contrato de financiamento      º±±
±±º          ³                                                            º±±
±±º          ³ *** Transacao "3" ***                                      º±±
±±º          ³aRet[1] - 0                                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7AprovCRD(	cTransacao,		cNumContra,		nVlrVenda,	lConfCRD,;
						nValorFin,		cModOper,		lModoCons)

Local aRetCrd     := {}                  // Retorno da funcao
Local aDadosCrd   := {}                  // Dados para a analise de credito
Local aProdCrd    := {}                  // Produtos da venda
Local aParcCrd    := {}                  // Parcelas do financiamento
Local aParcVda    := {}                  // Parcelas da venda
Local nI          := 0					 // Variavel do loop
Local nX 	      := 0                   // Variavel do loop
Local nPosItem    := GdFieldPos("LR_ITEM")		// Posicao do item no aHeader
Local nPosCod     := GdFieldPos("LR_PRODUTO")	// Posicao do codigo do produto no aHeader
Local nPosDescri  := GdFieldPos("LR_DESCRI")	// Posicao da descricao do produto no aHeader
Local nPosQuant   := GdFieldPos("LR_QUANT")		// Posicao da quantidade no aHeader
Local nPosUnit    := GdFieldPos("LR_VRUNIT")	// Posicao do valor unitario no aHeader
Local nPosTotal   := GdFieldPos("LR_VLRITEM")	// Posicao do valor do item no aHeader
Local nTamSAE     := TamSx3("AE_COD")[1] // Tamanho do campo AE_COD
Local nMoedaParc  := 1                   // Moeda da parcela
Local nTpVenda    := 1                   // 1-Venda Normal 2-Venda forcada
Local lCheque     := .F.                 // Indica se a parcela e cheque
Local cRespForcada := ""                  // Responsavel pela venda forcada
Local cMV_CLIPAD   := PadR(SuperGetMV("MV_CLIPAD"),TAMSX3("LQ_CLIENTE")[1])		// Cliente padrao
Local cMV_LOJAPAD  := PadR(SuperGetMV("MV_LOJAPAD"),TAMSX3("LQ_LOJA")[1])			// Loja do cliente padrao

Default cNumContra 	:= ""
Default lConfCRD   	:= .F.
Default nValorFin  	:= 0
Default cModOper   	:= "XX"
Default lModoCons  	:= .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se for Cliente Padrao, inicializa o array aCrdCliente para forcar a tela de identIficacao do cliente³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cMV_CLIPAD+cMV_LOJAPAD == M->LQ_CLIENTE+M->LQ_LOJA
	aCrdCliente  := {"", ""}
EndIf

For nI := 1 to Len(aPgtos)
	lCheque := AllTrim(aPgtos[nI][3]) == "CH"
	If cPaisLoc == "BRA"
		nMoedaParc  := 1
	Else
		nMoedaParc  := aPgtos[nI][6]
	EndIf
	If Len(aPgtos[nI][4]) > 0
		Aadd(	aParcVda,{aPgtos[nI][1],;																				//Data de vencimento
				aPgtos[nI][2],;																							// Valor da parcela
				aPgtos[nI][3],;																							// Forma de pagamento
				If(AllTrim(aPgtos[nI][3])<> "FID",(Substr(aPgtos[nI][4][5],1,nTamSAE)),""),;							// Codigo da Administradora (Ignora se for cartao fidelidade)
				If(lCheque,aPgtos[nI][4][7],If(AllTrim(aPgtos[nI][3])== "FID",aPgtos[nI][4][1],aPgtos[nI][4][4])),;	// Numero do cartao/cheque
				If(lCheque,aPgtos[nI][4][5],""),;																		// Agencia do cheque
				If(lCheque,aPgtos[nI][4][6],""),;																		// Conta do cheque
				If(lCheque,aPgtos[nI][4][9],""),;																		// RG do cheque
				If(lCheque,aPgtos[nI][4][10],""),;																		// Telefone do portador do cheque
				.F.,;																									//
				nMoedaParc })																							// Moeda da parcela
	Else  // Dinheiro.
		Aadd(	aParcVda,{aPgtos[nI][1],;		// Data de vencimento
				aPgtos[nI][2],;					// Valor da parcela
				aPgtos[nI][3],;					// Forma de pagamento
				"",;							// Codigo da Administradora
				"",;							// Numero do cartao/cheque
				"",;							// Agencia do cheque
				"",;							// Conta do cheque
				"",;							// RG do cheque
				"",;							// Telefone do portador do cheque
				.F.,;							//
				nMoedaParc })					//Moeda da parcela
	EndIf
    Conout("43. LOJA701C -  Lj7AprovCRD -  aParcVda: nI: " + ALLTRIM(STR(nI)) +;
    			 " " + If(Empty(aParcVda[nI][3]), "", aParcVda[nI][3]) +;
    			 " " + If(Empty(aParcVda[nI][4]), "", aParcVda[nI][4]) )
Next nI

For nI := 1 to Len(aCols)
	If !(aCols[nI][Len(aCols[nI])])
		AAdd( aProdCrd, {	aCols[nI][nPosItem],;           //Item do Produto
							aCols[nI][nPosCod],;            //Codigo do Produto
							aCols[nI][nPosDescri],;         //Descricao do Produto
							aCols[nI][nPosQuant],;          //Quantidade de pecas vendidas
							aCols[nI][nPosUnit],;           //Valor unitario do produto
							aCols[nI][nPosTotal]} )         //Valor total da venda do item
	EndIf
Next nI

If Len(aParcVda) > 0
	SM0->(DbSetOrder(1))
	SM0->(DbSeek(Substr(cEmpAnt,1,2)+cFilAnt))

    AADD( aDadosCrd, aCrdCliente[2]			)				// 1.Numero do cartao
    AADD( aDadosCrd, aCrdCliente[1]			)				// 2.CNPJ/CPF
    AADD( aDadosCrd, nVlrVenda				)				// 3.Valor da venda
    AADD( aDadosCrd, M->LQ_JUROS			)				// 4.Juros da venda(%)
    AADD( aDadosCrd, Len(aParcVda)			)				// 5.Numero de parcelas
    AADD( aDadosCrd, nTpVenda				)				// 6.Venda forcada(1-Venda Normal 2-Venda forcada)
    AADD( aDadosCrd, cRespForcada			)				// 7.Responsavel pela venda forcada
    AADD( aDadosCrd, AClone(aParcCrd)		)				// 8.Dados das parcelas
    AADD( aDadosCrd, SM0->M0_CODIGO+"-"+FWGETCODFILIAL+"-"+Alltrim(SM0->M0_NOME)  ) // 9.Filial da venda
    AADD( aDadosCrd, LjGetStation("LG_PDV")	)				// 10.PDV
    AADD( aDadosCrd, xNumCaixa()			)				// 11.Caixa
    AADD( aDadosCrd, M->LQ_NUM				)				// 12.Num. do orcamento
    AADD( aDadosCrd, aClone(aProdCrd)		)				// 13.Produtos selecionados numa venda
    AADD( aDadosCrd, aClone(aParcVda)		)				// 14.Parcelas de uma venda
    AADD( aDadosCrd, FWGETCODFILIAL			)				// 15.Filial do Caixa que esta sendo utilizado
    AADD( aDadosCrd, M->LQ_CLIENTE			)				// 16.Cliente
    AADD( aDadosCrd, M->LQ_LOJA				)				// 17.Loja
    AADD( aDadosCrd, cUserName				)				// 18.Nome do usuario
    AADD( aDadosCrd, M->LQ_CONDPG 			)				// 19.Condicao de pagamento
    AADD( aDadosCrd, "LOJ" 					)			    // 20.Modulo chamador
	AADD( aDadosCrd, M->LQ_VEND				)			    // 21.VENDEDOR

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Analise de credito  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cTransacao == "1"

	    Conout("44.L0JA701C - Lj7AprovCRD - Chama a funcao CrdxVenda - " +;
	    		" Orcamento: " 	+ M->LQ_NUM +;
	    		" Contrato: " 	+ If(Empty(cNumContra),"", cNumContra))

		aRetCrd   := aClone(CrdxVenda( "1"   ,@aDadosCrd  ,cNumContra  ,.F.       ,;
                                      	NIL   ,cModOper    ,lModoCons   ,@aRecCrd  ))

		Conout("45.L0JA701C - Lj7AprovCRD - Retorno da funcao CrdxVenda - " +;
	    		" Orcamento: " 	+ M->LQ_NUM +;
	    		" Contrato: " 	+ If(Empty(aRetCrd[4]),"", aRetCrd[4]) +;
	    		" aRetCrd[5]: " + If( aRetCrd[5],".T.", ".F.") )

		If !aRetCrd[5]      //Se venda nao rejeitada
			cNumContra := aRetCrd[4]
			For nX := 1 to Len(aDadosCrd[8])
				nValorFin  += aDadosCrd[8][nX][2]
			Next nX
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza aContraTmp com os contratos que jah foram gerados. Utilizado na funcao CrdAtuPend para nao    ³
		//³deixar contratos pendentes 																		      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty(aRetCrd[4]) .AND. Ascan(aContraTmp,{|x| Trim(x[1]) == Trim(aRetCrd[4])}) == 0
			Aadd(aContraTmp,{aRetCrd[4],aDadosCrd[16],aDadosCrd[17]})
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Armazena CNPJ/CPF e/ou numero do cartao caso a identIficacao ³
		//³tenha sido feita na CrdxVenda                                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Empty(aCrdCliente[1]+aCrdCliente[2]) .AND. !Empty(aDadosCrd[1]+aDadosCrd[2])
			aCrdCliente    := {	aDadosCrd[02],;		// CNPJ/CPF.
								aDadosCrd[01]}		// Numero do cartao.
			M->LQ_CLIENTE  :=	aDadosCrd[16]
			M->LQ_LOJA     :=	aDadosCrd[17]
			Lj7ValCli(.F.)
			Lj7T_Total(2,Lj7T_SubTotal(2) + Iif(Type("aAcrescimo") <> "U",aAcrescimo[1],0) + Lj7CalcFrete())
			
			If MaFisFound("NF")
				MaFisAlt("NF_FRETE"  , 0)
				MaFisAlt("NF_SEGURO" , 0)
				MaFisAlt("NF_DESPESA", 0)
			EndIf
		EndIf
	ElseIf cTransacao == "2"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Confirmacao da transacao de credito  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza o array das parcelas de financiamento. O array aParcCrd, por ser local, esta vazio ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aDadosCrd) > 0
			aDadosCrd[8]  := AClone(aRecCrd)
		EndIf
        aRetCrd := aClone(CrdxVenda( "2"   ,aDadosCrd  ,cNumContra  ,.F.     ,;
                                     NIL    ,NIL       ,NIL          ,aRecCrd ))
		If aRetCrd[1] == 0  //Confirmacao ok
			lConfCRD    := .T.
		EndIf
	ElseIf cTransacao == "3"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cancelamento da transacao de credito ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        aRetCrd  := aClone(CrdxVenda( "3"   ,aDadosCrd  ,cNumContra  ,.F.     ,;
                                       NIL  ,NIL         ,NIL         ,aRecCrd ))
	EndIf
Else
   Conout("46. LOJA701C - Lj7AprovCRD - aParcVda vazio, orcamento " + M->LQ_NUM +;
   			 " Contrato " + If(Empty(cContrato),"",cContrato))
EndIf

Return (aRetCrd)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7SetCRDCºAutor  ³Vendas Clientes     º Data ³  02/06/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Inicializar array que contem o CNPJ/CPF ou numero do cartao º±±
±±º          ³e a variavel do numero do contrato(cContrato)			      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ Lj7SetCRDClie(EXpL1)									      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpL1 - controla se atualiza aContraTmp					  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ Nenhum                                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7SetCRDClie(lAtuTmp)

Default lAtuTmp  := .F.

Conout("47. LOJA701C -  Lj7SetCRDClie - Inicializa variaveis - " +;
		" Contrato " + If(Empty(cContrato), "", cContrato) )

aCrdCliente := {"",""}
cContrato   := Space(TamSX3("MA7_CONTRA")[1])
lAvalBotao  := .F.
aInfMA7     := {}
aInfMAH     := {}
aInfMAL     := {}
aRecCrd     := {}
If lAtuTmp
   aContraTmp  := {}
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7CancCRDºAutor  ³Vendas Clientes     º Data ³  02/06/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Desfaz a operacao de credito caso ocorra algum erro na tran-º±±
±±º          ³sacao                                                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ Lj7CancCRD(ExpC1, ExpC2) 								  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpC1: Codigo do cliente                                   º±±
±±º          ³ ExpC2: Loja do cliente                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ Nenhum                                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7CancCRD(cCodClie  ,cLoja)
Local cNumContra   := ""                     //Numero do contrato
Local aRetCrd      := {}                    //Retorno do cancelamento da transacao
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Desfaz a transacao de credito  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If CrdxInt()
   DbSelectArea("MA7")
   DbSetOrder(1)
   If DbSeek(xFilial("MA7")+cCodClie+cLoja) .AND. (!Empty(MA7->MA7_CONTRA) .OR. !Empty(cContrato))
      If !Empty(MA7->MA7_CONTRA)
         cNumContra  := MA7->MA7_CONTRA
      Else
         cNumContra  := cContrato
      EndIf

 	  Conout("48.LOJA701C - Lj7CancCRD - Orcamento: " +  M->LQ_NUM +;
	               " Contrato: " + If (Empty(cContrato), "", cContrato) +;
	      		   " Desfas a transacao de credito: Lj7AprovCRD Param1=3 " )


	  aRetCrd     := AClone(Lj7AprovCRD( "3"  ,cNumContra  ,Lj7T_Total(2)  ,NIL   ,;
	                                      NIL  ,NIL        ,NIL ))
   EndIf
Else
	Conout("49.LOJA701C - Lj7CancCRD - Orcamento: " +  M->LQ_NUM + "  Sem Integracao com o CRD")
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7CRDAvalºAutor  ³Vendas Clientes     º Data ³  20/06/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Realiza a analise de credito chamado pelo botao da toolbar  º±±
±±º			 ³Integracao com SIGACRD									  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ Lj7CRDAval(ExpN1)           								  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpN1 - opcao do aRotina						              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Venda liberada ou bloqueada							  	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7CRDAval(nOpc)
Local lRet          := .T.                       			// Controla o prosseguimento da funcao
Local lTemFinanc    := .F.                       			// Determina se tem alguma parcela financiada para chamar a tela
Local lTemParcFI    := .F.                         			// Controla se tem alguma parcela financiada para avaliacao de credito
Local nX            := 0                             			// Variavel de controle de loop
Local nValorFin     := 0                         			// Valor financiado
Local nSaldo        := 0                         			// Saldo restante para atingir limite de credito
Local cMV_FormCRD   := SuperGetMV("MV_FORMCRD",,"CH/FI") 	// Formas de pagamento para as quais deve avaliar credito - SIGACRD
Local cMsgStatus    := ""                       			// Mensagem de retorno ao Caixa
Local cMV_CLIPAD	:= PadR(SuperGetMV("MV_CLIPAD"),TAMSX3("LQ_CLIENTE")[1])					// Cliente padrao
Local cMV_LOJAPAD	:= PadR(SuperGetMV("MV_LOJAPAD"),TAMSX3("LQ_LOJA")[1])						// Loja do cliente padrao
Local aRetCrd       := {}                       			// Array de retorno com informacoes de credito do cliente(SIGACRD)
Local oMsgStatus                                			// Objeto da mensagem de retorno ao Caixa
Local oDlg                                      			// Objeto da caixa de dialogo
Local aParc    		:= {}									// Parcelas a serem analisadas pelo SIGACRD
Local nPosCpo		:= 0									// Posicao do campo FORMA de pagamento no array
Local nTipo         := 0

Conout("50. LOJA701C - Lj7CRDAval - Inicio da Rotina")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se o campo L4_FORMAID nao estiver criado, as parcelas nao foram adicionadas no array aPgtosSint³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lVisuSint
	aParc      		:= aClone(aPgtosSint)
	nPosCpo			:= 1
Else
	aParc    		:= aClone(aPgtos)
	nPosCpo			:= 3
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³VerIfica se as parcelas foram selecionadas 					³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := 1 to Len(aParc)
   lRet  := !Empty(aParc[nX][nPosCpo])
   If !lRet
      Exit
   EndIf
Next nX

If !lRet
   MsgAlert(STR0060)  //"Digite as parcelas antes de realizar a analise de credito."
EndIf

If lRet
   For nX := 1 to Len(aParc)
      If Empty(aParc[nX][nPosCpo])
         Loop
      EndIf
      If AllTrim(aParc[nX][nPosCpo]) $ cMV_FormCRD
         lTemParcFI  := .T.
      EndIf
      If !IsMoney(Alltrim(aParc[nX][nPosCpo])) .AND. AllTrim(aParc[nX][nPosCpo]) <> AllTrim(MVCHEQUE)
         If AllTrim(aParc[nX][nPosCpo]) $ cMV_FormCRD
            lTemFinanc  := .T.
            Exit
         EndIf
      EndIf
   Next nX

   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   //³Chama a tela para selecionar a Adm. Financeira quando grava orcamento,   ³
   //³tiver ao menos uma parcela em que avalia o credito e SIGACRD integrado   ³
   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   If lTemFinanc
      Lj7InfPgtos(nTipo)
   EndIf

   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   //³Se for chamada da finalizacao da venda, recupera o numero do contrato gra³
   //³vado no orcamento 													   ³
   //³Busca os dados do cliente se tiver parcela financiada 				   ³
   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   If nOpc == 4 .AND. lTemParcFI
      If Empty(aCrdCliente[1]+aCrdCliente[2]) .AND. M->LQ_CLIENTE+M->LQ_LOJA <> cMV_CLIPAD+cMV_LOJAPAD
         aCrdCliente   := AClone(CrdInfClie(M->LQ_CLIENTE, M->LQ_LOJA))
      EndIf
   EndIf

   Conout("51. LOJA701C - Lj7CRDAval - Chama a funcao LJ7AprovCRD - "+;
   			" Contrato:" + If(Empty(cContrato),"", cContrato))

   aRetCrd   := AClone(Lj7AprovCRD( "1"        ,@cContrato ,Lj7T_Total(2)  ,NIL   ,;
                                     @nValorFin ,"XX"      ,.T.))
   Conout("52. LOJA701C - Lj7CRDAval - Retorno da funcao LJ7AprovCRD - "+;
   			" Contrato:" + If(Empty(cContrato),"", cContrato))

   If Len(aRetCrd) > 1
		If aRetCrd[5]  // Venda rejeitada.
			lRet := .F.
		ElseIf !Empty(aRetCrd[4])  // Se retornou o numero do contrato, credito aprovado.
	     lAvalBotao  := .T.
	     cContrato   := aRetCrd[4]
	     If aRetCrd[1] == 0
	        nSaldo     := aRetCrd[2] - (aRetCrd[3] + nValorFin)
	        //Se foi desbloqueado pelo analista de credito(saldo < 0) nao mostra mensagem de status
	        If nSaldo >= 0
					cMsgStatus := STR0063 + Transform(aRetCrd[2], PesqPict("MAL", "MAL_VALOR")) + Space(10)	// "Valor do Limite de crédito do cliente: "
					cMsgStatus += STR0064 + Transform(nSaldo, PesqPict("MAL", "MAL_VALOR")) + CRLF				// " Saldo: "
					cMsgStatus += STR0065 + Transform(aRetCrd[3], PesqPict("MAL", "MAL_VALOR"))				// "Valor dos títulos em aberto: "
					cMsgStatus += STR0066 + Transform(nValorFin, PesqPict("MAL", "MAL_VALOR"))					// " + Compra Atual: "
		    EndIf
	     EndIf
	  Else
			If aRetCrd[1] == 2   // Off-line.
	        //"A consulta nao poderá ser realizada pois o serviço se encontra indisponível no momento."
	        MsgAlert(STR0062)
	     Else
	        //"Não sera realizada a análise de crédito, a condição de pagamento selecionada nao requer sua realização."
	        MsgAlert(STR0061)
	     EndIf
	  EndIf
	  If !Empty(cMsgStatus)
		DEFINE FONT oFont NAME "Times New Roman" SIZE 9,14

		DEFINE MSDIALOG oDlg FROM 0,0 TO 130,600 TITLE STR0067 PIXEL  //"Analise de Credito"

	 	   @ 03, 002 TO  45, 297 LABEL STR0068 OF oDlg PIXEL   //"Status"
		   @ 12, 005 SAY oMsgStatus VAR cMsgStatus PIXEL FONT oFont

		   DEFINE SBUTTON FROM 50,268 TYPE 01 ACTION oDlg:End() ENABLE

		ACTIVATE MSDIALOG oDlg CENTERED
	  EndIf
   EndIf
EndIf

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7SetContºAutor  ³Vendas Clientes     º Data ³  20/06/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atualiza variaveis de contrato quando finalizacao de venda  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ Lj7SetContra()           								  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Nenhum 													  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Nenhum 												  	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7SetContra()

Conout("53.LOJA701C - Lj7SetContra, contrato " + M->LQ_CONTRA )
cContrato    := M->LQ_CONTRA
If !Empty(cContrato)
   AAdd(aContraTmp,{cContrato,M->LQ_CLIENTE,M->LQ_LOJA})
   Lj7GetInfCRD(cContrato,M->LQ_CLIENTE,M->LQ_LOJA)
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7GetContºAutor  ³Vendas Clientes     º Data ³  20/06/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Recupera o conteudo da variavel aContraTmp. Variavel utili- º±±
±±º			 ³zada para verIficar se deve cancelar contrato pendente      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ Lj7GetContra()           								  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Nenhum 													  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Conteudo aContraTmp 									      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7GetContra()
Local aRet     := {}               //Conteudo da variavel aContraTmp

aRet  := AClone(aContraTmp)

Return (aRet)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7GetInfCºAutor  ³Vendas Clientes     º Data ³  20/06/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Armazena os dados dos arquivos MAH e MAL se o orcamento tem º±±
±±º			 ³um contrato de financiamento associado. Sera utilizado caso º±±
±±º			 ³o usuario nao confirme a operacao, pois deve voltar o backupº±±
±±º			 ³destes arquivos para atualizar a base de dados              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ Lj7GetInfCRD(ExpC1, ExpC2, ExpC3)					      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpC1 - Numero do contrato 								  º±±
±±º          ³ExpC2 - Codigo do cliente 								  º±±
±±º          ³ExpC3 - Loja do cliente 								      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Nenhum			 									      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7GetInfCRD(cNumContra, cCodClie, cLoja)
Local aArea    := GetArea()      // Area atual

DbSelectArea("MA7")
DbSetOrder(1)
If DbSeek(xFilial("MA7")+cCodClie+cLoja)
   aInfMA7    := {}
   Aadd(aInfMA7, MA7->MA7_DATABL )
   Aadd(aInfMA7, MA7->MA7_HORABL )
   Aadd(aInfMA7, MA7->MA7_USRBL  )
   Aadd(aInfMA7, MA7->MA7_MOTBL  )
   Aadd(aInfMA7, MA7->MA7_VLRBL  )
   Aadd(aInfMA7, MA7->MA7_BLOQUE )
   Aadd(aInfMA7, MA7->MA7_DTHRDS )
   Aadd(aInfMA7, MA7->MA7_LC     )
   Aadd(aInfMA7, MA7->MA7_ARQPRO )
   Aadd(aInfMA7, MA7->MA7_ARQPAR )
EndIf

DbSelectArea("MAH")
DbSetOrder(1)
If DbSeek(xFilial("MAH")+cNumContra)
   aInfMAH    := {}
   Aadd(aInfMAH, MAH->MAH_CONTRA )
   Aadd(aInfMAH, MAH->MAH_EMISSA )
   Aadd(aInfMAH, MAH->MAH_DTTRN  )
   Aadd(aInfMAH, MAH->MAH_HRTRN  )
   Aadd(aInfMAH, MAH->MAH_PDVTRN )
   Aadd(aInfMAH, MAH->MAH_CXTRN  )
   Aadd(aInfMAH, MAH->MAH_LJTRN  )
   Aadd(aInfMAH, MAH->MAH_VLRFIN )
EndIf

aInfMAL    := {}
DbSelectArea("MAL")
DbSetOrder(1)
DbSeek(xFilial("MAL")+cNumContra)
While !Eof() .AND. xFilial("MAL")+cNumContra == MAL->MAL_FILIAL+MAL->MAL_CONTRA
   Aadd(aInfMAL, { MAL->MAL_CONTRA ,;
                   MAL->MAL_PARCEL ,;
                   MAL->MAL_VENCTO ,;
                   MAL->MAL_VALOR  ,;
                   MAL->MAL_SALDO  })
   DbSkip()
End

RestArea(aArea)

Return NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7RestInfºAutor  ³Vendas Clientes     º Data ³  20/06/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Se usuario nao confirmou a operacao de gravacao, o sistema  º±±
±±º          ³deve verIficar se os dados do orcamento x dados do contrato º±±
±±º          ³estao integros, porque a cada analise solicitada os dados doº±±
±±º          ³contrato sao atualizados enquanto os do orcamento apenas na º±±
±±º          ³confirmacao da operacao(gravacao orcamento/venda)			  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³Lj7RestInfCRD()           								  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Nenhum 													  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Nenhum			 									      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7RestInfCRD()

If !Empty(cContrato) .AND. Len(aInfMAH) > 0 .AND. Len(aInfMAL) > 0 .AND. Len(aInfMA7) > 0
   CrdRestInfCRD(cContrato		, aInfMAH		, aInfMAL	, aInfMA7	,;
   				 M->LQ_CLIENTE	, M->LQ_LOJA	)
   aInfMA7    := {}
   aInfMAH    := {}
   aInfMAL    := {}
EndIf

Return (NIL)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7AtuPremioºAutor  ³Vendas Clientes      º Data ³11/03/06  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Inicializa as variaveis de resgate de premio                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³Lj7AtuPremio()              								  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Nenhum 													  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Retorno do valor total dos premios (brinde + self-liquidate º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7AtuPremio(lZeraPremio)
Local nRet := nTotPremio

Default lZeraPremio 	:= .F.

If lZeraPremio
	nTotPremio := 0
	aPremio	   := {}
	aLibera	   := {}
EndIf

Return (nRet)

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³Lj7GrvPremioºAutor  ³Vendas Clientes      º Data ³11/03/06  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Grava o premio resgatado pelo cliente no arquivo SL2 pois e º±±
±±º          ³um produto da loja                                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³Lj7GrvPremio()              								  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Nenhum 													  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Nenhum													  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Lj7GrvPremio()
Local aSL1      := {}
Local aSL2      := {}
Local nX		:=0							//Contador
Local nQtdItens :=0							//Quantidade de itens
Local nTamItem	:=TamSx3("L2_ITEM")[1]  	//Tamanho do L2_ITEM
Local cItem		:= Space(nTamItem)			//Item
Local cTes		:= ""						//Tes
Local cCampo	:= ""                 		//campo
Local nPrcTab   := 0						//Preco de tabela
Local nValDesc  := 0						//Valor do desconto
Local nItens	:= 0						//Numero do item
Local cTabPad	:= AllTrim(SuperGetMv("MV_TABPAD"))	//Tabela de preco padrao
Local nDescPer  := 0
Local lL2FECP	:= SL2->( ColumnPos("L2_ALQFECP") > 0 .AND. ColumnPos("L2_VALFECP") > 0 )
Local lL2FECPST := SL2->( ColumnPos("L2_ALQFCST") > 0 .AND. ColumnPos("L2_VFECPST") > 0 )


AEval(aCols, {|x| If(!x[Len(x)], nQtdItens++,)})

cItem := StrZero( nQtdItens,nTamItem ,0)

DbSelectArea("SB1")
DbSetOrder(1)

For nX := 1 to Len(aPremio)

	// Se nao for vale compra, grava o item no SL2
	If Empty(aPremio[nX][4])

		If  DbSeek(xFilial("SB1")+aPremio[nX][3])

			cItem := Soma1(cItem)

			cTes := SB1->B1_TS
			If Empty(cTes)
				cTes:= SuperGetMv("MV_TESSAI")
			EndIf
			SF4->( DbSetOrder(1) )
			SF4->( DbSeek(xFilial("SF4")+cTes) )

	    	SB0->( DbSetOrder(1) )
			If SB0->( DbSeek(xFilial("SB0")+aPremio[nX][3]) )
				cCampo := "B0_PRV"+cTabPad
				nPrcTab := SB0->(&cCampo)
			EndIf
			nValDesc := Round( (nPrcTab * aPremio[nX][6])/100, 2)

			If aPremio[nX][5] = 0.01
				cPremio := "1"   // Brinde
			Else
				cPremio := "2"   // Self-Liquidate
			EndIf

			If MaFisFound("NF")

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Quando for inclusao de um novo item chama a funcao MafisAdd              ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					MaFisAdd( aPremio[nX][3],;				// Produto
								cTes,;						// Tes
								1,;							// Quantidade
								aPremio[nX][5],;			// Preco unitario
								0,;							// Valor do desconto
								"",; 						// Numero da NF original
								"",; 						// Serie da NF original
								0,;							// Recno da NF original
								0,; 						// Valor do frete do item
								0,; 						// Valor da despesa do item
								0,; 						// Valor do seguro do item
								0,; 						// Valor do frete autonomo
								aPremio[nX][5],;			// Valor da mercadoria
								0 )							// Valor da embalagem
			EndIf

			aAdd( aSL2, {} )

			aAdd( aSL2[Len(aSL2)], { "L2_FILIAL"	, 	xFilial("SL2") } )
			aAdd( aSL2[Len(aSL2)], { "L2_NUM"		, 	M->LQ_NUM } )
			aAdd( aSL2[Len(aSL2)], { "L2_ITEM"		,	cItem } )
			aAdd( aSL2[Len(aSL2)], { "L2_PRODUTO"	,	aPremio[nX][3] } )
			aAdd( aSL2[Len(aSL2)], { "L2_DESCRI"	, 	SB1->B1_DESC } )
			aAdd( aSL2[Len(aSL2)], { "L2_QUANT"		, 	1 } )
			aAdd( aSL2[Len(aSL2)], { "L2_VRUNIT"	, 	aPremio[nX][5] } )
			aAdd( aSL2[Len(aSL2)], { "L2_VLRITEM"	, 	aPremio[nX][5] } )
			aAdd( aSL2[Len(aSL2)], { "L2_LOCAL"		, 	SB1->B1_LOCPAD } )
			aAdd( aSL2[Len(aSL2)], { "L2_UM"		, 	SB1->B1_UM } )
			aAdd( aSL2[Len(aSL2)], { "L2_DESC"		, 	aPremio[nX][6] } )
			aAdd( aSL2[Len(aSL2)], { "L2_VALDESC"	, 	nValDesc } )
			aAdd( aSL2[Len(aSL2)], { "L2_TES"		, 	cTes } )
			aAdd( aSL2[Len(aSL2)], { "L2_CF"		, 	SF4->F4_CF } )
			aAdd( aSL2[Len(aSL2)], { "L2_EMISSAO"	, 	dDatabase } )
			aAdd( aSL2[Len(aSL2)], { "L2_GRADE"		, 	"N" } )
			aAdd( aSL2[Len(aSL2)], { "L2_VEND"		,	M->LQ_VEND } )
			aAdd( aSL2[Len(aSL2)], { "L2_TABELA"	,	cTabPad } )
			aAdd( aSL2[Len(aSL2)], { "L2_PRCTAB"	, 	nPrcTab } )
			If SL2->(Fieldpos("L2_PREMIO")) > 0
				aAdd( aSL2[Len(aSL2)], { "L2_PREMIO", 	cPremio } )
			EndIf
			If SL2->( FieldPos("L2_ITEMSD1")) > 0
				aAdd( aSL2[Len(aSL2)], { "L2_ITEMSD1"	, 	"000000" } )
			EndIf

	        nItens := nX + nQtdItens

			If MaFisFound("IT",nItens)

				aAdd( aSL2[Len(aSL2)], { "L2_VALIPI",	MaFisRet(nItens,"IT_VALIPI") } )
				aAdd( aSL2[Len(aSL2)], { "L2_VALICM",	MaFisRet(nItens,"IT_VALICM") } )
				aAdd( aSL2[Len(aSL2)], { "L2_VALISS",	MaFisRet(nItens,"IT_VALISS") } )
				aAdd( aSL2[Len(aSL2)], { "L2_BASEICM",	MaFisRet(nItens,"IT_BASEICM") } )

				If SL2->(FieldPos("L2_VALPIS")) >0 	.AND. SL2->(FieldPos("L2_VALCOFI"))>0 .AND.	;
				   SL2->(FieldPos("L2_VALCSLL"))>0 .AND. SL2->(FieldPos("L2_VALPS2")) >0 .AND.	;
				   SL2->(FieldPos("L2_BASEPS2"))>0	.AND. SL2->(FieldPos("L2_ALIQPS2"))>0 .AND.	;
				   SL2->(FieldPos("L2_VALCF2")) >0	.AND. SL2->(FieldPos("L2_BASECF2"))>0 .AND.	;
				   SL2->(FieldPos("L2_ALIQCF2"))>0	.AND. ;
				   ( SA1->A1_RECPIS == "S" .OR. SA1->A1_RECCOFI == "S" .OR. SA1->A1_RECCSLL == "S" )

					aAdd( aSL2[Len(aSL2)], { "L2_VALPIS ", MaFisRet(nItens,"IT_VALPIS") } )
					aAdd( aSL2[Len(aSL2)], { "L2_VALCOFI", MaFisRet(nItens,"IT_VALCOF") } )
					aAdd( aSL2[Len(aSL2)], { "L2_VALCSLL", MaFisRet(nItens,"IT_VALCSL") } )

				EndIf

				aAdd( aSL2[Len(aSL2)], { "L2_BASEPS2", MaFisRet(nItens,"IT_BASECF2") } )
				aAdd( aSL2[Len(aSL2)], { "L2_BASECF2", MaFisRet(nItens,"IT_BASECF2") } )

				aAdd( aSL2[Len(aSL2)], { "L2_VALPS2" , MaFisRet(nItens,"IT_VALPS2") } )
				aAdd( aSL2[Len(aSL2)], { "L2_VALCF2" , MaFisRet(nItens,"IT_VALCF2") } )

				aAdd( aSL2[Len(aSL2)], { "L2_ALIQPS2", MaFisRet(nItens,"IT_ALIQPS2") } )
				aAdd( aSL2[Len(aSL2)], { "L2_ALIQCF2", MaFisRet(nItens,"IT_ALIQCF2") } )

				aAdd( aSL2[Len(aSL2)], { "L2_BRICMS", 	MaFisRet(nItens,"IT_BASESOL") } )
				aAdd( aSL2[Len(aSL2)], { "L2_ICMSRET",	MaFisRet(nItens,"IT_VALSOL") } )

				aAdd( aSL2[Len(aSL2)], { "L2_VALFRE",	MaFisRet(nItens,"IT_FRETE") } )
				aAdd( aSL2[Len(aSL2)], { "L2_SEGURO",	MaFisRet(nItens,"IT_SEGURO") } )
				aAdd( aSL2[Len(aSL2)], { "L2_DESPESA",  MaFisRet(nItens,"IT_DESPESA") } )
				
				If lL2FECP
					aAdd( aSL2[Len(aSL2)], { "L2_ALQFECP",  MaFisRet(nItens, "IT_ALIQFECP") } )
					aAdd( aSL2[Len(aSL2)], { "L2_VALFECP",  MaFisRet(nItens, "IT_VALFECP") } )
				EndIf
				
				If lL2FECPST
                    aAdd( aSL2[Len(aSL2)], { "L2_ALQFCST",  MaFisRet(nItens, "IT_ALFCST") } )
                    aAdd( aSL2[Len(aSL2)], { "L2_VFECPST",  MaFisRet(nItens, "IT_VFECPST") } )
                EndIf
			EndIf
		EndIf
	EndIf
Next nX
For nX := 1 to Len( aSL2 )
   Lj7GeraSL( "SL2", aSL2[nX], .T. )
Next nX

If Lj7T_DescP(2) > 0 .AND. nTotPremio > 0
   nDescPer  := Round((Lj7T_DescV(2)/Lj7T_Total(2)) * 100,2)
EndIf

aAdd( aSL1, {} )
aAdd( aSL1[Len(aSL1)], { "L1_VALMERC", MaFisRet(,"NF_VALMERC") } )
aAdd( aSL1[Len(aSL1)], { "L1_DESCNF" , nDescPer } )
For nX := 1 to Len( aSL1 )
   Lj7GeraSL( "SL1", aSL1[nX], .F. )
Next nX

Return NIL

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³ LjImpTEF   ºAutor  ³Vendas Clientes      º Data ³29/08/06  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Imprime e Grava a Transacao tef da Venda                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³LjImpTEF()              								      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Nenhum 													  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Nenhum													  º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function LjGrvImpTEF(lTefOk		, lCartao	, aRet		, nSize		,;
						 	cRBuffer	, nHandle	, lAbtoAll	, cAdminis	,;
						 	oTef		, cSerie	, lLog1		, lLog4		,;
						 	lErrCupTEF	, lDscCupTef, aTefDados , lTemTefPend,;
						 	aNSUVndTef)

Local nCont 		:= 0									// Contador
Local nX  			:= 0									// Contador do FOR
Local aSL1			:= {}									// Array com os campos do SL1
Local aSL4			:= {}									// Array com os campos do SL4
Local lMVTELAFIN	:= SuperGetMv("MV_TELAFIN",,.T.)		// Define se mostra a tela de administradora
Local lSemRede		:= .F.									// Variavel que retorna se a rede selecioda no TEF existe na base
Local aUsado		:= {}
Local nY			:= 1
Local lTEFFat       := .F.									// Uso do TEF dentro do modulo Faturamento
Local cContOnf      := "" 	    	                        // Contador Geral de Operação Não Fiscal
Local cContRg       := ""   	                            // Contador Geral de Relatório Gerencial
Local cContCdc      := ""           	                    // Contador de Comprovante de Crédito ou Débito
Local lRelGer       := .F.                                  // Indica se houve impressão de relatorio gerencial

Local aGetTabela  	:= {}									// Guara Area do tabela
Local lRet				:= .F.

Local nPosData   	 := 0									// Variavel que contem a posicao no Array oTef:aRetCartao:aDatas
Local dDataTrans	 := CtoD(Space(08))                     // Conteudo do Array oTef:aRetCartao:aDatas
Local nPosTrans		 := 0                                 	// Variavel que contem a posicao no Array oTef:aRetCartao:aValores
Local nValorTrans 	 := 0									// Conteudo do Array oTef:aRetCartao:aValores
Local nPosRetCart    := 0                                   // Varial que contem posicao no Array oTef:aRetCartao
Local lTefMult		 := SuperGetMV("MV_TEFMULT", ,.F.)		// Identifica se o cliente utiliza múltiplas transacoes TEF
Local aDTEFPend		 := {} 									//Array de transacoes DTEF Pendentes
Local nCountTEF		 := 0  									// Contador de pagamentos com forma TEF
Local cNroDoc 		 := ""
Local cNumPDV 		 := ""
Local cCodRede 		 := ""
Local cDescRede		 := ""
Local lAtribRede 	 := LJRDLJXTEF() //Verifica a data do fonte LOJXTEF para saber se o atributo cCodRede existe no objeto oTef:aRetCartao
Local cNSUVndTef	 := ""
Local aRetPbm		 := {}	//Retorno das informações do PBM Funcional Card
Local nI			 := 1	//Contador
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	 := LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida

Default lDscCupTef	 := .F.									//se TEF discado, indica se o comprovante TEF foi impresso
Default aNSUVndTef	 := {}

If LjNfUsaTef(SM0->M0_CGC)
	lTefFAT	:= LJXVERTEF(.F.)
	aRet[2] := {"",""}
EndIf

If (lTefOk .AND. !lFtvdVer12 .AND. lUsaTef .AND. (lCartao .OR. (LjNfUsaTef(SM0->M0_CGC) .AND. lTEFFat));
	.AND. cTipTEF $	TEF_SEMCLIENT_DEDICADO + ";" + ;
					TEF_COMCLIENT_DEDICADO + ";" + ;
					TEF_DISCADO			   + ";" + ;
					TEF_CENTROPAG		   + ";" + ;
					TEF_CLISITEF ) .OR. ;
	(lTefOk .AND. lFtvdVer12 .AND. lUsaTef .AND. (lCartao .OR. lTEFFat);
	.AND. cTipTEF $	TEF_SEMCLIENT_DEDICADO + ";" + ;
					TEF_COMCLIENT_DEDICADO + ";" + ;
					TEF_DISCADO			   + ";" + ;
					TEF_CLISITEF	)

	If !Empty( LOG_TEF )
		LjWriteLog( LOG_TEF + M->LQ_NUM + ".TXT", "Impressão do cupom tef - N / S / S / S / " + cTipTEF )
	EndIf

	If aRet[1]
		If lLog1 .AND. lLog4 .AND. nHandle >= 0
			nSize 		:= FSeek( nHandle, 0, 2 )
			cRBuffer 	:= Space( nSize )

			FSeek( nHandle, 0, 0 )
			FRead( nHandle, @cRBuffer, nSize )

			cRBuffer := Encript( cRBuffer, 1 )
			If !("#TEF#" $ cRBuffer)
				cRBuffer := cRBuffer + "#TEF#"
			EndIf

			FSeek( nHandle, 0, 0 )
			FWrite( nHandle, Encript( cRBuffer, 0 ) )
		EndIf

		aSL1 := {}

		If lUsaTef .AND. lTefOk
			If cTipTef $ TEF_SEMCLIENT_DEDICADO + ";" + TEF_COMCLIENT_DEDICADO + ";" + 	TEF_DISCADO
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Sem Client / Com Client / Discado ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				AAdd( aSL1, { "L1_VENDTEF", "S" } )
				AAdd( aSL1, { "L1_DATATEF", aTefDados[1][2] } )
				AAdd( aSL1, { "L1_HORATEF", aTefDados[1][3] } )
				AAdd( aSL1, { "L1_DOCTEF" , aTefDados[1][4] } )
				AAdd( aSL1, { "L1_AUTORIZ", aTefDados[1][5] } )
				AAdd( aSL1, { "L1_INSTITU", aTefDados[1][8] } )
				AAdd( aSL1, { "L1_DOCCANC", aTefDados[1][6] } )
				AAdd( aSL1, { "L1_DATCANC", aTefDados[1][12] } )
				AAdd( aSL1, { "L1_HORCANC", aTefDados[1][7] } )
				AAdd( aSL1, { "L1_NSUTEF" , aTefDados[1][9] } )
				AAdd( aSL1, { "L1_TIPCART", aTefDados[1][10] } )

				If !Empty( aTefDados[1][15] )
					AAdd( aSL1, { "L1_FORMPG", aTefDados[1][20] } )
				EndIf

				AAdd(aSL1,{"L1_TEFBAND"	, aTefDados[1][18]})
				

				If SL1->(ColumnPos( "L1_PARCTEF" ) ) > 0
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Tipo de Parcelamento ("0" - Estabelecimento / "1" - Administradora) + Quantidade de Parcelas³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					AAdd( aSL1, { "L1_PARCTEF", aTefDados[1][16] + aTefDados[1][17] } )
				EndIf
			Else
				If cTipTef $ TEF_CLISITEF+ ";" + TEF_CENTROPAG
					aSL1 := LjTEFGeraSL( aSL1, "SL1" )
				EndIf
			EndIf
			Lj7GeraSL( "SL1", aSL1, .F., .F. )
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Faz a gravacao do SL4 somente se nao for orcamento gerado de ³
		//³ um pedido                                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Empty( SL1->L1_FILRES ) .AND. Empty( SL1->L1_ORCRES )
			aSL4 := {}

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Teve abatimento total no valor da venda (PIS/COFINS/CSLL)³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Len( aPgtos ) == 1 .AND. Empty( aPgtos[1,1] ) .AND. aPgtos[1,2] == ( LJPCCRet() + If( LJ220AbISS(), MaFisRet( , "NF_VALISS" ), 0 ) )
				lAbtoAll := .T.
			EndIf

			If cTipTEF == TEF_DISCADO  .AND. L010IsDirecao(L010GetGPAtivo())
				aDTEFPend :=  LJLoadDTEF()
			EndiF

			For nX := 1 To Len( aPgtos )
				// Contador de Formas de Pagto TEF
				If AllTrim(aPgtos[nX][3]) $ _FORMATEF
					nCountTEF := aScan(aTefDados,{|x|,Alltrim(x[19]) == Alltrim(aPgtos[nX][8])})
				Endif
				
				AAdd( aSL4, {} )
				AAdd( aSL4[nX], { "L4_VENDTEF", "N" } )
				
				If Len(aNSUVndTef) > 0
					nCont := Ascan(aNSUVndTef, {|x| AllTrim(x[1])+x[2] == AllTrim(aPgtos[nX][3])+aPgtos[nX][8]}) //Forma + ID											
					cNSUVndTef := IIf( nCont > 0 , aNSUVndTef[nCont][4], "")
					If !Empty(AllTrim(cNSUVndTef))
						aAdd( aSL4[nX], { "L4_VENDTEF", "S"})
					EndIf
				EndIf		

				If lMFE .And. Len(aIdPgtoMfe) > 0 .And. AllTrim(aPgtos[nX][3]) $ _FORMATEF
					aAdd( aSL4[nX], { "L4_IDPGVFP", aIdPgtoMfe[nI][1]})		
					nI++
				EndIf							

				If lUsaTef .AND. lTefOk
					If cTipTef $ TEF_SEMCLIENT_DEDICADO + ";" + TEF_COMCLIENT_DEDICADO + ";" + 	TEF_DISCADO .AND. AllTrim(aPgtos[nX][3]) $ _FORMATEF
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Sem Client / Com Client / Discado ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		                If ( nPos := AScan( aTefMult, { |x| AScan( x[10], StrZero( nX, 2 ) ) > 0 } ) ) <> 0
			                If Len( aTefMult[nPos][7] ) > 0
			    	            aTefDados := aClone( aTefMult[nPos][7] )

								AAdd( aSL4[nX], { "L4_VENDTEF", "S" } )
								AAdd( aSL4[nX], { "L4_DATATEF", aTefDados[1][2] } )
								AAdd( aSL4[nX], { "L4_HORATEF", aTefDados[1][3] } )
								AAdd( aSL4[nX], { "L4_DOCTEF" , aTefDados[1][4] } )
								AAdd( aSL4[nX], { "L4_AUTORIZ", aTefDados[1][5] } )
								AAdd( aSL4[nX], { "L4_INSTITU", aTefDados[1][8] } )
								AAdd( aSL4[nX], { "L4_DOCCANC", aTefDados[1][6] } )
								AAdd( aSL4[nX], { "L4_DATCANC", aTefDados[1][12] } )
								AAdd( aSL4[nX], { "L4_HORCANC", aTefDados[1][7] } )
								AAdd( aSL4[nX], { "L4_NSUTEF" , aTefDados[1][9] } )
								AAdd( aSL4[nX], { "L4_TIPCART", aTefDados[1][10] } )

								If !Empty( aTefDados[1][15] )
									AAdd( aSL4[nX], { "L4_FORMPG", aTefDados[1][15] } )
								EndIf

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³Antes de gravar o SL4 vou verIficar se a ADM selecionada ³
								//³pelo operador e a mesma da resposta da transacao         ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								cAdminis := LJ7ConfAdm( aPgtos[nX][4][5], aTefDados[1][8] )

								If !Empty( cAdminis )
									AAdd( aSL4[nX], { "L4_ADMINIS", cAdminis } )
								EndIf
							EndIf
						ElseIf cTipTEF == TEF_DISCADO  .AND. L010IsDirecao(L010GetGPAtivo()) .AND. AllTrim(aPgtos[nX][3]) $ _FORMATEF .AND. Len(aDTEFPend) > 12						 
							nPosRetCart := Iif(lTefMult, aScan(aDTEFPend, {|x| x[14] == aPgtos[nX][8] } ), 1)
							If nPosRetCart > 0
								cL4NSUTEF := Right(aDTEFPend[nPosRetCart][7], Len(aDTEFPend[nPosRetCart][7] - 3))
								
								aAdd( aSL4[nX], { "L4_VENDTEF","S"})
								aAdd( aSL4[nX], { "L4_DATATEF",aDTEFPend[nPosRetCart][10]})
								aAdd( aSL4[nX], { "L4_HORATEF",aDTEFPend[nPosRetCart][11]})
								aAdd( aSL4[nX], { "L4_DOCTEF" ,aDTEFPend[nPosRetCart][13]})
								aAdd( aSL4[nX], { "L4_AUTORIZ",aDTEFPend[nPosRetCart][13]})
								aAdd( aSL4[nX], { "L4_NSUTEF" ,cL4NSUTEF})
							    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³Antes de gravar o SL4 vou verIficar se a ADM selecionada ³
								//³pelo operador e a mesma da resposta da transacao         ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								cAdminis := LJ7ConfAdm( aPgtos[nX][4][5], aDTEFPend[nPosRetCart][06] )

								If !Empty( cAdminis )
									AAdd( aSL4[nX], { "L4_ADMINIS", cAdminis } )
								EndIf
							EndIf
						ElseIf cTipTEF == TEF_DISCADO .AND. AllTrim(aPgtos[nX][3]) $ _FORMATEF .AND. lTefMult
							If nCountTEF>0 .AND. Len(aTEFDados) >= nCountTEF .AND. Len(aTEFDados[nCountTEF]) >= 15
									AAdd( aSL4[nX], { "L4_VENDTEF", "S" } )
									AAdd( aSL4[nX], { "L4_DATATEF", aTefDados[nCountTEF][2] } )
									AAdd( aSL4[nX], { "L4_HORATEF", aTefDados[nCountTEF][3] } )
									AAdd( aSL4[nX], { "L4_AUTORIZ", aTefDados[nCountTEF][5] } )
									AAdd( aSL4[nX], { "L4_INSTITU", aTefDados[nCountTEF][8] } )
									AAdd( aSL4[nX], { "L4_DOCCANC", aTefDados[nCountTEF][6] } )
									AAdd( aSL4[nX], { "L4_DATCANC", aTefDados[nCountTEF][12] } )
									AAdd( aSL4[nX], { "L4_HORCANC", aTefDados[nCountTEF][7] } )
									If L010IsDirecao(L010GetGPAtivo())
										AAdd( aSL4[nX], { "L4_NSUTEF" , Right(aTefDados[nCountTEF][9],6) } )
										AAdd( aSL4[nX], { "L4_DOCTEF" , aTefDados[nCountTEF][5] } )
									Else
										AAdd( aSL4[nX], { "L4_NSUTEF" , aTefDados[nCountTEF][9] } )
										AAdd( aSL4[nX], { "L4_DOCTEF" , aTefDados[nCountTEF][5] } )
									EndIf
									AAdd( aSL4[nX], { "L4_TIPCART", aTefDados[nCountTEF][10] } )

									If !Empty( aTefDados[nCountTEF][15] )
										AAdd( aSL4[nX], { "L4_FORMPG", aTefDados[nCountTEF][20] } )
									EndIf

									AAdd( aSL4[nX], { "L4_FORMA"  , aTefDados[nCountTEF][20] } )
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³Antes de gravar o SL4 vou verIficar se a ADM selecionada ³
									//³pelo operador e a mesma da resposta da transacao         ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

									If !Empty( cAdminis ) .AND. cTipTEF <> TEF_DISCADO
										AAdd( aSL4[nX], { "L4_ADMINIS", cAdminis } )
									EndIf
							EndIf
							// Se estiver usando Pay&Go e MV_TEFMULT = .F. faz tratamento para preencher a array aSL4 a partir do aTefDados
						ElseIf cTipTEF == TEF_DISCADO .AND. Alltrim(aPgtos[nX][3]) $ _FORMATEF .AND. !lTefMult
							If Len(aTEFDados) >= 1 .AND. Len(aTEFDados[1]) >= 15
								aAdd( aSL4[nX], { "L4_VENDTEF","S"})
								aAdd( aSL4[nX], { "L4_DATATEF",alltrim(aTefDados[1][2])})
								aAdd( aSL4[nX], { "L4_HORATEF",alltrim(aTefDados[1][3])})
								aAdd( aSL4[nX], { "L4_AUTORIZ",alltrim(aTefDados[1][5])})
								aAdd( aSL4[nX], { "L4_INSTITU",alltrim(aTefDados[1][8])})
								aAdd( aSL4[nX], { "L4_DOCCANC",alltrim(aTefDados[1][6])})
								aAdd( aSL4[nX], { "L4_DATCANC",alltrim(aTefDados[1][12])})
								aAdd( aSL4[nX], { "L4_HORCANC",alltrim(aTefDados[1][7])})
									aAdd( aSL4[nX], { "L4_NSUTEF" ,alltrim(aTefDados[1][9])})
									aAdd( aSL4[nX], { "L4_DOCTEF" ,alltrim(aTefDados[1][5])})
								aAdd( aSL4[nX], { "L4_TIPCART", alltrim(aTefDados[1][12])})
								aAdd( aSL4[nX], { "L4_FORMPG" , alltrim(aTefDados[1][20])})
								aAdd( aSL4[nX], { "L4_ADMINIS", cAdminis } )
							EndIf
						EndIf
					Else
						If (cTipTef == TEF_CENTROPAG .OR. cTipTef == TEF_CLISITEF ).AND. AllTrim(aPgtos[nX][3]) $ _FORMATEF
							If !lMVTELAFIN
								LJVERADM(@lSemRede, lTefOK)
							EndIf

							// Por estar em um For e passar pelas mesmas posicoes varias vezes,
							// as variaveis sao inicializadas novamente a cada For
							nPosData   	:= 0
							dDataTrans	:= CtoD(Space(08))
							nPosTrans	:= 0
							nValorTrans := 0
							nPosRetCart := 0

							// oTef:aRetCartao > 1 quando venda com multiplos cartoes
							nPosRetCart := Iif(lTefMult, aScan(oTef:aRetCartao, {|x| x:CIDCART == aPgtos[nX][8] } ), 1)

							If nPosRetCart > 0
								// Procura pela data conforme condicao de pagamento/parcelamento (se for parcelado, procura pela data do vencimento da parcela)
								nPosData   	:= aScan(oTef:aRetcartao[nPosRetCart]:aDatas, {|x| x == aPgtos[nX][1] } )

								// Procura pelo valor da transacao (se for parcelado, procura pelo valor da parcela)
								nPosTrans	:= aScan(oTef:aRetcartao[nPosRetCart]:aValores, {|x| x == aPgtos[nX][2] } )

						        If nPosData > 0 .And. nPosTrans > 0
                                   	dDataTrans := oTef:aRetcartao[nPosRetCart]:aDatas[nPosData]
									nValorTrans := oTef:aRetcartao[nPosRetCart]:aValores[nPosTrans]

									If  dDataTrans == aPgtos[nX][1]	 .AND. nValorTrans == aPgtos[nX][2]
										If lAtribRede //Verifica se o atributo cCodRede existe no objeto oTef:aRetCartao
											cCodRede 	:= oTef:aRetCartao[nPosRetCart]:cCodRede
											cDescRede 	:= oTef:aRetCartao[nPosRetCart]:cDescRede
										EndIf

										cAdminis  := LJ7ConfAdm( aPgtos[nX][4][5]											, oTef:aRetCartao[nPosRetCart]:cDescAdm , .F. 									  	, aPgtos[nX][_FORMAPGTO]		   			,;
																 IIf(lTefMult,oTef:aRetCartao[nPosRetCart]:cIdCart ,NIL )	, oTef:aRetCartao[nPosRetCart]:cTipCart , oTef:aRetCartao[nPosRetCart]:nParcelas 	, oTef:aRetCartao[nPosRetCart]:cDescCart	,;
																 Nil														, nPosRetCart							 , Nil										, cDescRede								 	,;
																 Nil														, cCodRede )
									EndIf
								Endif
							Endif

							//Caso o Tef Tenha sido cancelado matem a admnistradora do aPgtos
							If Empty(AllTrim(cAdminis) )
								cAdminis  := aPgtos[nX][4][05]
							EndIf

							aSL4 := LjTEFGeraSL( 	aSL4			, "SL4"	, Nil, aPgtos[nX, 3]	, ;
													aPgtos[nX, 8]	, Nil	, Nil, Nil				, ;
													Nil				, nX )

							If !Empty( cAdminis )
								AAdd( aSL4[nX], { "L4_ADMINIS", cAdminis } )
							    If (Alltrim( aPgtos[nX][3] ) $ _FORMATEF) .AND. cTipTef == TEF_CLISITEF .AND. lUsaTEF
									cAdminis := ""
								Endif
							EndIf

						EndIf
					EndIf
				EndIf
			Next nX

			nCont := 1

			DbSelectArea( "SL4" )
			SL4->(DbSetOrder( 1 ))
			SL4->(DbSeek( xFilial( "SL4" ) + SL1->L1_NUM ))

			While !SL4->(EOF()) .AND. SL4->L4_FILIAL + SL4->L4_NUM == xFilial( "SL4" ) + SL1->L1_NUM
				If nCont <= Len(aSL4)
			    	Lj7GeraSL( "SL4", aSL4[nCont], .F. )
			 	EndIf
		    	SL4->(DbSkip())
				nCont ++
			End
		EndIf

		LjDeLogR( SL1->L1_NUM )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ha' casos, com causa nao identificada, em que aRet nao traz o documento / pdv, na 2a. dimensao.   ³
		//³Por isso o tratamento abaixo (evita erro ao gravar  os logs da  venda)                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ValType(aRet[2]) == "C"
			cNroDoc := SL1->L1_DOC
			cNumPDV := SL1->L1_PDV
		Else
			cNroDoc := aRet[2][1]
			cNumPDV := aRet[2][2]
		EndIf
		If Empty(cNroDoc)
			cNroDoc := SL1->L1_DOC
			cNumPDV := SL1->L1_PDV
		EndIf

		LjGrLogT(	SL1->L1_NUM			, cNroDoc			, xNumCaixa()		, aTefDados			,;
					SL1->L1_DINHEIRO	, SL1->L1_CHEQUES	, SL1->L1_CARTAO	, SL1->L1_VLRDEBI	,;
					SL1->L1_CONVENI		, SL1->L1_VALES		, SL1->L1_FINANC	, SL1->L1_OUTROS	,;
					SL1->L1_DESCONT		, SL1->L1_DESCNF	, cNumPDV			, cSerie )

		If cTipTef $ TEF_SEMCLIENT_DEDICADO + ";" + TEF_COMCLIENT_DEDICADO + ";" + 	TEF_DISCADO
			If LOJA010T( "I", "V", NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, @lRelGer)
				lTefOk := LJ701AtCartao()
				lDscCupTef 	:= .T.	//se discado, indica se o comprovante TEF foi impresso

				If lLog1 .AND. lLog4 .AND. nHandle >= 0
					nSize 		:= FSeek( nHandle, 0, 2 )
					cRBuffer 	:= Space( nSize )

					FSeek( nHandle, 0, 0 )
					FRead( nHandle, @cRBuffer, nSize )

					cRBuffer := Encript( cRBuffer, 1 )
					If !("#TEFOK#" $ cRBuffer)
						cRBuffer := cRBuffer + "#TEFOK#"
					EndIf

					FSeek( nHandle, 0, 0 )
					FWrite( nHandle, Encript( cRBuffer, 0 ) )
				EndIf
				lImpTefIpdv := .T.
			Else
				lErrCupTEF := .T.
			EndIf
		Else
			If (cTipTef == TEF_CENTROPAG .OR. cTipTEF == TEF_CLISITEF) //.AND. ( LjNfUsaTef(SM0->M0_CGC) .OR. lFtvdVer12 )
				If oTef:lTefOk
					If lMFE .And. lLjRspFisc .And. Len(oTef:aRetCartao) > 0
						LjRspFisc(oTef:aRetCartao,.F.,aIdPgtoMfe)
						aIdPgtoMfe := {}
					EndIf	
				EndIf			
				oTEF:ImpCupTef( NIL , @lRelGer)
				lTefOk := oTef:lTefOk
				lTemTEFPend := .F.
				aTefBKP     := {}
				//Valida se já foi impresso o comprovante PBM e limpa as variáveis
				If ExistFunc("LJGDadosVL")
					aRetPbm := LJGDadosVL() //recupera dados do pbm selecionados
					If aRetPbm[3] <> 99 .And. aRetPbm[3] <> 0
						oTEF:aRetVidaLink := Nil
						LJ7DadosVL() //zera dados pbm funcional card
					EndIf
				EndIf
			EndIf
		EndIf
		If lUsaTef .AND. !lTefOk
			Lj7LimpTef()
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Contadores necessarios para o PAF-ECF³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If LjNfPafEcf(SM0->M0_CGC) .AND. !lFtvdVer12
			// Retorna o Contador Geral de Operação Não Fiscal
			nRet := IFStatus(nHdlECF, "36", @cContOnf)

			// Retorna o Contador de Comprovante de Credito ou Debito
			nRet := IFStatus(nHdlECF, "38", @cContCdc)

			If lRelGer
			    // Retorna o Contador Geral de Relatório Gerencial
				nRet := IFStatus(nHdlECF, "37", @cContRg)
			EndIf

			RecLock("SL1",.F.)
				If SL1->(ColumnPos("L1_CONTONF")) > 0
					REPLACE L1_CONTONF WITH cContOnf
				EndIf
				If SL1->(ColumnPos("L1_CONTCDC")) > 0
					REPLACE L1_CONTCDC WITH cContCdc
				EndIf
				If SL1->(ColumnPos("L1_CONTRG")) > 0
					REPLACE L1_CONTRG WITH cContRg
				EndIf
			MsUnlock()
		EndIf
	ElseIf !aRet[1]
		If cTipTef $ TEF_SEMCLIENT_DEDICADO + ";" + TEF_COMCLIENT_DEDICADO + ";" + 	TEF_DISCADO
			lTefOk := LOJA010T( "F", "N" )
		EndIf
		If lTefOk
	  	   MsgInfo( STR0028 ) //"Transação TEF não efetuada, favor reter o cupom!"
		EndIf
	EndIf

	If !Empty( LOG_TEF )
		LjWriteLog(	LOG_TEF + M->LQ_NUM + ".TXT", "Impressão do cupom tef - " + If( aRet[1], "S", "N" ) + " / " + ;
		           	If( lTefOk, "S", "N" ) + " / " + If( lErrCupTEF, "S", "N" ) )
	EndIf

	aRetAdmTef	:= {}	// Limpa o array de retorno das AdmFinanceiras
EndIf

//Faz a impressao do comprovante de "Recarga de Celular"
If lUsaTef .And. cTipTEF == TEF_CLISITEF .And. ExistFunc("Lj7RCImpRC") .And. Lj7RCImpRC()

	If oTef:lTefOk .And. oTef:nCodFuncao == 0
		oTef:nCodFuncao := 301 		//Recarga de Celular
	EndIf

	oTef:ImpCupTef() 			// Imprime Cupom TEF
	lTefOk 	:= oTef:lTefOk		// Se a transação TEF está OK

ElseIf lUsaTef .And. cTipTEF == TEF_CLISITEF .And. ExistFunc("Lj7CP_OK") .And. Lj7CP_OK() .And. Lj7CP_Imp()

	//-----------------------------------------------------------------------
	//Faz a impressao do comprovante de "Recarga de Cartao Presente" (Gift Card)
	//-----------------------------------------------------------------------
	If oTef:lTefOk .And. oTef:nCodFuncao == 0
		If AllTrim(SuperGetMv("MV_LJCPMOD", ,"" )) == "1"
			oTef:nCodFuncao := 669 		//669=Recarga de Cartão Presente (Gift Card) - (Modulo Givex)
		ElseIf AllTrim(SuperGetMv("MV_LJCPMOD", ,"" )) == "2"
			oTef:nCodFuncao := 264 		//264=Recarga de Cartão Presente (Gift Card) - (Modulo SQCF / Todo Cartoes)
		EndIf
	EndIf

	oTef:ImpCupTef() 			// Imprime Cupom TEF
	lTefOk 	:= oTef:lTefOk		// Se a transação TEF está OK

EndIf

Return NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ LjCancCup  ºAutor  ³Vendas Clientes      º Data ³30/08/06  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Cancela o cupom Fiscal                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³LjCancCup()              								      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Nenhum 													  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³aRet - Retorno se foi tudo Ok  							  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LjCancCup()
Local aRet			:= {.T.,'',''}											//Retorno da funcao
Local nRet 			:= 0													//Retorno de verIficao em ECF

nRet := IfCancCup( nHdlECF )
If Lj7VerCmd( nRet )
   Inkey(8)   // dá um tempo para a impressora fazer a impressao do cancelamento
Else
   aRet[1] := .F.
   aRet[3] := STR0099 //"Falha no cancelamento do cupom"
EndIf

Return ( aRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ LjCancTEF  ºAutor  ³Vendas Clientes      º Data ³30/08/06  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Cancela a transacao Tef                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   LjCancTEF()              								      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Nenhum 													  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Nenhum						  							  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjCancTEF()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Usuário TEF e Venda com Transação Tef                    ³
//³ Verifica se o usuario e' fiscal e se o ambiente e' LINUX ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lUsaTef .AND. LJXVERTEF(.F.)
	If lFiscal .OR. (!lFiscal .AND. GetRemoteType() <> REMOTE_LINUX )
		If cTipTef == TEF_CLISITEF
			If !oTef:lImprimiu .AND. !lTelaTefPed   // Realiza o desfazimento da Transação TEF caso não tenha sido impresso o comprovante
				oTEF:FinalTrn( 0 )
				lTefCanc :=  .T.
				MsgStop(UPPER(STR0007)+"!!!"+CTRL+STR0200+CTRL+STR0201,STR0007) //"Atenção"###"Todas as transações TEF pendentes foram canceladas!"###"Os cartões que haviam sido aprovados nesta venda, foram cancelados e deverão ser passados novamente!"###"Atenção"
			EndIf
		Else
			LOJA010t("F", "D")
			lTefCanc :=  .T.
			MsgStop(UPPER(STR0007)+"!!!"+CTRL+STR0200+CTRL+STR0201,STR0007) //"Atenção"###"Todas as transações TEF pendentes foram canceladas!"###"Os cartões que haviam sido aprovados nesta venda, foram cancelados e deverão ser passados novamente!"###"Atenção"
		EndIf
	EndIf
EndIf

Return .T.

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³ LjIncSF3   ºAutor  ³Vendas Clientes      º Data ³30/08/06  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Cancela a transacao Tef                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³LjIncSF3()              								      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Nenhum 													  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Nenhum						  							  º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Lj7IncSF3(	cNumNota	, cSerNota	, cCliente	, cLoja	,;
							cPdv		, lSF3		, lErroCF )

Local lProcIncSf3	:= .T.				// Se processa o SF3
Local aGetBook		:= {}
Local aLivro		:= {}
Local aImpVarSD2	:= {}
Local aAreaSL2		:= {}
Local aAreaSF4		:= {}

Default lSF3		:= .F.
Default lErroCF     := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Cancela NF somente se for pelo modo antigo³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lFisLivro
	lProcIncSf3 := SuperGetMV("MV_MAPARES") == "N"

	If cPaisLoc == "BRA" .AND. lProcIncSf3

		SF3->(dbSetOrder(4))
		IF !SF3->(DbSeek(xFilial("SF3")+Padr(cCliente, TamSX3("F3_CLIEFOR")[1])+Padr(cLoja, TamSX3("F3_LOJA")[1])+Padr(cNumNota, TamSX3("F3_NFISCAL")[1])+Padr(cSerNota, TamSX3("F3_SERIE")[1])))

			RecLock("SF3",.T.)

			REPLACE SF3->F3_FILIAL	with xFilial("SF3")
			REPLACE SF3->F3_ENTRADA	with dDatabase
			REPLACE SF3->F3_NFISCAL	with cNumNota
			REPLACE SF3->F3_SERIE  	with cSerNota
			REPLACE SF3->F3_CLIEFOR	with cCliente
			REPLACE SF3->F3_LOJA	with cLoja
			REPLACE SF3->F3_PDV     with cPDV
			REPLACE SF3->F3_EMISSAO	with dDatabase
			REPLACE SF3->F3_DTCANC	with dDatabase
			REPLACE SF3->F3_OBSERV	with "NF CANCELADA"

			MsUnLock()

		EndIf

	EndIf
EndIf

If (cPaisLoc == "ARG" .AND. lSF3) .OR. (cPaisLoc == "ARG" .AND. lErroCF)
	aAreaSL2 := SL2->( GetArea() )
	aAreaSF4 := SF4->( GetArea() )
	If SL2->( DbSeek( xFilial("SL2") + SL1->L1_NUM ) )
		While !SL2->(EOF()) .AND. ( SL2->L2_FILIAL + SL2->L2_NUM == xFilial("SL2") + SL1->L1_NUM )
			SF4->( DbSeek( xFilial("SF4") + SL2->L2_TES ) )
			aImpVarSD2 := Lj010SimSD2( SL2->L2_TES )
			aLivro := GetBook( @aGetBook, aImpVarSD2, "V", SL1->L1_TXMOEDA, aLivro, "S" )
			SL2->( DbSkip() )
		End
	EndIf
	RestArea(aAreaSF4)
	RestArea(aAreaSL2)

	If Len(aLivro) > 0

		GravaLivro( @aLivro , SL1->L1_SERIE , cNumNota )

		RecLock("SF3",.F.)
		REPLACE SF3->F3_OBSERV WITH "ORC ANULADO: " + SL1->L1_FILIAL + SL1->L1_NUM
		SF3->( MsUnLock() )
		
		RecLock("SL1",.F.)
		REPLACE SL1->L1_STORC WITH "C"
		SL1->( MsUnLock() )
	EndIf
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7CancVendaºAutor  ³Vendas Clientes      º Data ³11/09/06  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Cancela venda e executa os processo relacionados            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³Lj7CancVenda(ExpC1)      								      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpC1 - Mensagem a se apresentada							  º±±
±±º          ³ExpC2 - Numero do Cupom  									  º±±
±±º          ³ExpC3 - Serie												  º±±
±±º          ³ExpC4 - Numero do Pdv										  º±±
±±º          ³ExpL5 - so cancela caso o cupom esteja aberto				  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Nenhum						  							  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function Lj7CancVenda(	cTexto		, cDoc		, cSerie	, cPdv		,;
								lSoAberto	, lTefOK	, lExistNF	, cDescErro	,;
								lSF3		, lErroCF	, lIsPedido	, aTefBKP	,;
								lTemTEFPend )

Local nRet			:= 0			// Retorno do status da impressora
Local lCancela		:= .T.			// Se deve cancelar o cupom fiscal
Local cRetorno		:= ""			// Retorno da verIficacao do status da impressora
Local aRet			:= {.T.}		// Retorno da funcao de cancelamento
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lEmitNfce	:= LjEmitNFCe()		// Sinaliza se utiliza NFC-e

Default lExistNF	:= .F.
Default cDescErro	:= ""
Default lSF3		:= .F.
Default lErroCF     := .F.
Default lIsPedido 	:= .F.
Default aTefBKP 	:= {}
Default lTemTEFPend := .F.

LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT', "Cancelamento automatico antes liberacao")

LjGrvLog(M->LQ_NUM,"Cancelamento da Venda")

If cPaisLoc <> "ARG"

	If Type("oTef") <> "U" .And. oTef:lTefOk
		aTefBKP := aClone(oTef:aRetCartao)
		lTemTEFPend := .T.
	EndIf

	LjGrvLog(M->LQ_NUM,"Configuracao do parametro MV_TEFPEND", SuperGetMV("MV_TEFPEND",,"0"))

	If SuperGetMV("MV_TEFPEND",,"0") == "0"
		LjCancTEF()
		LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT',  "tef Cancelado")
		
		If lTefCanc   // Transacao TEF foi cancelada
			lTemTEFPend := .F.  // Nao possue transacao TEF pendente
		Endif		
	EndIf
EndIf

If lSoAberto .AND. !lEmitNFCe
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ VerIfica se ha um cupom em aberto. Caso afirmativo, faz o    ³
	//³ cancelamento antes da abertura de outro                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nRet := IfStatus( nHdlECF, '5', @cRetorno )
	If nRet <> 7
		lCancela = .F.
	EndIf

EndIf

If lCancela .AND. lCupFiscal .AND. !lEmitNFCe
	aRet := LjCancCup()
	LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT',  "cupom Cancelado")
EndIf

//VerIfica se o comando foi executado com sucesso
If aRet[1] .OR. cPaisLoc == "ARG" .OR. lEmitNFCe .Or. lIsPafNfce
	//Inclui o registro para os livros fiscais
	Lj7IncSF3(	cDoc	, cSerie	, M->LQ_CLIENTE	, M->LQ_LOJA	,;
				cPdv	, lSF3		, lErroCF .OR. lEmitNFCe .Or. lIsPafNfce)
	LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT',  "SF3 Cancelamento Incluido doc->" + cDoc + " Serie->" + cSerie + " Cliente->" + M->LQ_CLIENTE + " Loja->" + M->LQ_LOJA + " Pdv->" + cPdv)
Else
	MsgStop(aRet[3])
	LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT',  "Erro no cancelamento do cupom")
EndIf

If !lEmitNFCe .And. !lIsPafNfce	//Ja possui mensagem de cancelamento da NFC-e
	MsgStop(STR0081)//"Venda cancelada devido a erro na gravação!"
End
LjWriteLog(LOG_TEF + M->LQ_NUM + '.TXT',  "Cancelamento Automatico liberado automatico")
Lj701Erro(aRet[1] .OR. lEmitNFCe .Or. lIsPafNfce, @lExistNF, @cDescErro)

Return .T.


/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LJVERADM  ºAutor  ³Vendas Clientes     º Data ³  09/01/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna se achou a administradora que retornou do SITEF.  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³ ExpL1 = Retorna se achou a rede                            º±±
±±º          ³ ExpL2 = Informa se TEF foi OK                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ LOJA701C                                                   º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LJVERADM( 	lSemRede, lTefOk, lTefManual, nLinAPgtos ,;
 							lSelTefManu)
Local nI 		:= 1 					// Variavel do For
Local nX        := 1					// Variavel do For
Local lRet      := .F.					// Retorno da Funcao
Local cAdminis  := ""					// Guarda o nome da administradora
Local cTipcart	:= ""					// Guarda o tipo de cartao utilizado
Local lTefMult	:= SuperGetMV("MV_TEFMULT", ,.F.)		// Identifica se o cliente utiliza múltiplas transacoes TEF
Local cIdCart	:= ""
Local cCodRede 	:= ""
Local cDescRede	:= ""
Local cFormCart := ""
Local lAtribRede:= LJRDLJXTEF() //Verifica a data do fonte LOJXTEF para saber se o atributo cCodRede existe no objeto oTef:aRetCartao

Default lTefManual := .F.
Default nLinAPgtos := 0
Default lSelTefManu:= .F.

If lTefOk
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Laco onde ira verIficar a Administradora somente³
	//³quando a forma de pagamento for Cartao          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	While ( nX <= Len(oTef:aRetCartao) )

		If lTefMult
			If lTefManual .And. nLinAPgtos > 0 .And. lSelTefManu
				cIdCart		:= aPgtos[nLinAPgtos][8]
				cFormCart	:= aPgtos[nLinAPgtos][3]
			Else
				cIdCart		:= oTef:aRetCartao[nX]:cIdCart
				cFormCart	:= oTef:aRetCartao[nX]:cFORMA
			EndIf
		Else
			cIdCart	:= ""
			cFormCart	:= oTef:aRetCartao[nX]:cFORMA
		EndIf

		LjGrvLog("", "cIdCart=",  cAdminis )
		LjGrvLog("", "cFormCart=",  cFormCart )
		If Empty(cIdCart)  // se nao for multiTef
			nI := aScan(aPgtos,{|x|,Alltrim(x[3])== Alltrim(cFormCart) })
		Else
			nI := aScan(aPgtos,{|x|,Alltrim(x[3])== AllTrim(cFormCart) .AND. x[8] == cIdCart})
		EndIf

		If nI > 0 .AND. AllTrim( aPgtos[nI][3] )$ _FORMATEF

			If lAtribRede //Verifica se o atributo cCodRede existe no objeto oTef:aRetCartao
				cCodRede 	:= oTef:aRetCartao[nX]:cCodRede
				cDescRede 	:= oTef:aRetCartao[nX]:cDescRede
			EndIf

			cAdminis := LJ7ConfAdm( aPgtos[nI][4][5], oTef:aRetCartao[nX]:cDescAdm, @lSemrede 						, cFormCart						,;
									cIdCart			, oTef:aRetCartao[nX]:cTipCart, oTef:aRetCartao[nX]:nParcelas	, oTef:aRetCartao[nX]:cDescCart	,;
									lTefManual		, nX						  , Nil								, cDescRede						,;
									Nil				, cCodRede 					  , lSelTefManu )
			If Empty( cAdminis )
				HELP( " ", 1, "SEMINSTITU" )
				// ### "Administradora: " ### ". Efetue o cadastro da Administradora no arquivo SAE e salve esta venda como Orçamento."
				MsgInfo(STR0077 + TRIM(oTef:aRetCartao[nX]:cDescAdm) + STR0078)
				lRet 		:= .F.
			Else
				While ( nI <= Len(aPgtos)) .AND.(aPgtos[nI][8] == cIdCart) .AND. (AllTrim(cFormCart) == AllTrim(aPgtos[nI][3]) )
					aPgtos[nI][4][5] := cAdminis
					++nI
					LjGrvLog("", "ADMINISTRADORA QUE SERÁ GRAVADA NO L4_ADMINIS=",  cAdminis )
				End
				lRet := .T.
			EndIf
		EndIf
		nX++
	End
EndIf
Return lRet

/*/±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±³Funo    ³LjMnReb     ³ Autor ³ Vendas Clientes       ³ Data ³ 28/02/07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Monta array de recebimentos                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                              ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function LjMnReb(aReb, aParcTef, nArredondar)
Local nPos			:= 0					// Posição do caracter pesquisado
Local nI 			:= 0					// Contador
Local nVlrEntrada	:= 0					// Valor de Entrada
Local aCartoes		:= {}					// Array Cartões para SL4
Local cCartao 		:= ""					// Qual cartão
Local cValProt		:= ""
Default aReb 		:= {}
Default aParcTef 	:= {}
Default nArredondar := 0

If cTipTef == TEF_CLISITEF  .OR. cTipTef == TEF_CENTROPAG

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pegando os dados totalizados de cartões a serem enviados para a transacao TEF ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nI := 1 To Len(aPgtosSint)
		If AllTrim(aPgtosSint[nI][1]) $ _FORMATEF

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ VerIfica o valor da primeira parcela a ser enviada para a transação TEF ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nPos := Ascan(aPgtos,{|x| AllTrim(x[3])+AllTrim(x[8]) == AllTrim(aPgtosSint[nI][1])+AllTrim(aPgtosSint[nI][4]) } )
			nVlrEntrada := If(nPos>0,aPgtos[nPos][2],0)
			If nI = 1 .AND. nArredondar > 0
				nVlrEntrada := nVlrEntrada + nArredondar
			EndIf

			// Protecao incluida para a informacao da variavel cValProt que eh adicionada no array aReb
			If Len(aPgtosSint[nI]) > 5 .AND. Len(aPgtosSint[nI][6]) > 4
				cValProt := aPgtosSint[nI][6][5]
			Else
				cValProt := ""
			EndIf
	        Aadd(aReb,{ aPgtosSint[nI][5],;											//Data
		        	    (Val(StrTran(StrTran(aPgtosSint[nI][3],",",""),".",""))/100)+iif(nI=1,nArredondar,0),;	//Valor
		        	    aPgtosSint[nI][1],;												//Forma
		        	    aPgtosSint[nI][4],;												//ID para identIficação da forma de pagamento na operação TEF
		        	    aPgtosSint[nI][2],;												//Qtde de Parcelas
						nVlrEntrada,;													//Valor Entrada
						{Space(03),Space(3),Space(04),Space(10),Space(07),Space(15),Space(15)} , ; // //Dados do Cheque
						cValProt })
		EndIf
	Next nI

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se a estação utilizar consulta de cheques pegar os dados analíticos de todos os cheques a serem consultados³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If At("S",LjGetStation("TEFCONS")) <> 0
		For nI := 1 To Len(aPgtos)
			If Alltrim(aPgtos[nI][3]) == AllTrim(MVCHEQUE)
				Aadd(aReb,{ aPgtos[nI][1],;											//Data
							aPgtos[nI][2],;												//Valor
							aPgtos[nI][3],;												//Forma
							aPgtos[nI][8],;												//ID para identIficação da forma de pagamento na operação TEF
							1,;															//Quantidade de Parcelas
							0,;															//Valor de Entrada, para cheques podemos considerar o mesmo
							{aPgtos[nI][4][8],aPgtos[nI][4][4],aPgtos[nI][4][5],aPgtos[nI][4][6],aPgtos[nI][4][7],aPgtos[nI][4][9],aPgtos[nI][4][10]}}) //Dados do Cheque
			EndIf
		Next nI
    EndIf
Else
	For nI := 1 To Len(aPgtos)
		If AllTrim(aPgtos[nI][3]) $ _FORMATEF .OR. AllTrim(aPgtos[nI][3]) == "MH" .OR. (AllTrim(aPgtos[nI][3]) == AllTrim(MVCHEQUE) .AND. (SuperGetMV("MV_INTEEMS") .OR. At("S",LjGetStation("TEFCONS"))<>0) )
			If Alltrim(aPgtos[nI][3]) == Alltrim(MVCHEQUE)
				Aadd(aReb    , {  aPgtos[nI][1]   ,;                         //Data de vencimento
				                  aPgtos[nI][2]   ,;                         //Valor da parcela
				                  aPgtos[nI][3]   ,;                         //Forma de pagamento
				                  aPgtos[nI][4][7],;                         //Numero do cheque
				                  aPgtos[nI][4][4],;                         //Banco do cheque
				                  aPgtos[nI][4][5],;                         //Agencia do cheque
				                  aPgtos[nI][4][6],;                         //Conta do cheque
				                  nI                 })
			Else
				Aadd(aReb    , {  aPgtos[nI][1]    ,;                       //Data de vencimento
				                  aPgtos[nI][2]    ,;                       //Valor da parcela
				                  aPgtos[nI][3]    ,;                       //Forma de pagamento
				                  aPgtos[nI][4][5] ,;                       //Administradora
				                  nI               ,;                       //Parcela
				                  aPgtos[nI][4][7] }) 		           		// 4 ultimos digitos do cartao
			EndIf
			Aadd(aParcTef, {  aPgtos[nI][1]     ,;                          //Data de vencimento
			                  aPgtos[nI][2]     ,;                          //Valor da parcela
			                  aPgtos[nI][3]     ,;                          //Forma de pagamento
			                  1                 ,;
			                  aPgtos[nI][4][5]  ,;                          //Administradora
			                  aPgtos[nI][8]  	})                          //ID Cartao
		EndIf
		aCartoes := Lj010LerCartao(aPgtos[nI,3])
		If Alltrim(aPgtos[nI][3]) $ _FORMATEF .OR. AllTrim(aPgtos[nI][3]) == "MH"
			If Empty(aPgtos[nI][4][5])
				cCartao := aCartoes[1]
			Else
				cCartao := aPgtos[nI][4][5]
			EndIf
		Else
			cCartao	:= ""
		EndIf
	Next nI
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³Lj7VerFretºAutor  ³ Vendas Clientes    º Data ³  27/09/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ IdentIfica a versao do fonte                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ Nenhum													  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ Versao do fonte para controle do calculo do frete		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ LOJA701                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7VerFret()
Local nRet := 0    		//	Armazena o controle da Versão do fonte para calculo do Frete

nRet :=	20060927 		// 27 de Setembro de 2006

Return (nRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuno	 |Lj701Erro   ºAutor  ³Vendas Clientes     º Data ³  02/04/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescrio ³ Tela da mensagem que controlará os erros dentro da Transação º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj701Erro(lCanCup, lExistNF, cDescErro)
Local oDlgLeg
Local oFntMsg
Local oFntTit

// variaveis para o texto de detalhe

Local oBmp
Local lTelaDetalhe 	:=.F.
Local cMsgCab	 	:= ""
Local cMsgDet   	:= ""
Local cDirlog	 	:= Iif(!IsBlind(), LjLogTef(), "")
Local lErrorLock	:= .F.						//Controla se houve erro do tipo 'Error Lock Failed' ou 'Error Lock Required'
Local lUseSAT 	:= .F.						//Utiliza SAT
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lEmitNfce	:= LjEmitNFCe()		// Sinaliza se utiliza NFC-e

Default lCanCup 		:= .T. 	//Define se o cupom fiscal foi cancelado com sucesso
Default lExistNF		:= .F.
Default cDescErro		:= ""

// Verifica se utiliza SAT
lUseSAT 	:= IIF(ExistFunc("LjUseSat"),LjUseSat(),.F.)

If 'LOCK FAILED' $ Upper(cDescErro) .OR. 'LOCK REQUIRED' $ Upper(cDescErro)
	lErrorLock := .T.
EndIf

If lErrorLock
	cMsgDet := STR0112
	//"1- Verifique se o Cliente ou Produtos utilizados nesta venda estao sendo atualizados por outro usuario. A venda so podera ser concluida com acesso exclusivo ao Cliente e Produtos para atualizacao de seus dados."
ElseIf lExistNF
	cMsgDet := STR0113
	//"2- Verifique se ja nao existe um titulo a receber com o mesmo codigo na base de dados. Chave: Prefixo + Numero + Parcela + Tipo."
Else
	cMsgDet := cDescErro
EndIf

If !lTelaTefPed // Não é apenas a saída do Begin Sequence através da Tela do TEF
	If Len(cDescErro) > 0 // Se houve error.log
		cMsgDet := STR0086  + M->LQ_NUM + ".TXT" +  STR0087 + cDirlog //"O monitoramento deste tratamento pode ser analisado através do arquivo " + M->LQ_NUM +".TXT" +" no diretório: " + cDirlog
		cMsgDet +=  CTRL + cDescErro
		cMsgCab	 += STR0088 //"Ocorreu uma incosistência durante a gravação da venda. Clique em Detalhes para maiores informações."
	Else
		cMsgCab	 += STR0089 //"Ocorreu uma incosistência durante a gravação da venda." // Não existem detalhes a serem observados
	EndIf

	cMsgCab += STR0090 // "Toda a gravação contida no controle de transação foi desfeita."
	If !IsBlind()
		If LjxVerTef(.F.) .AND. lUsaTef // Se existe transação TEF e o usuário é TEF
			If cTipTef == TEF_CLISITEF // Se for Clisitef
				If !oTef:lImprimiu // Não houve impressão do comprovante TEF
					If lTefCanc // Foi possível o desfazimento, pois não houve impressão do cupom TEF
						cMsgCab += STR0091 // "O comando para desfazimento da transação TEF foi enviado com sucesso."
					EndIf
				Else
					cMsgCab += STR0092 //"Uma vez que a impressão do comprovante TEF foi efetuada, não foi possível efetuar o desfazimento. Cancele a transação TEF manualmente."
				EndIf
			ElseIf cTipTef $ TEF_SEMCLIENT_DEDICADO + ";" + TEF_COMCLIENT_DEDICADO + ";" + 	TEF_DISCADO
				If !lImpTefIpdv
					If lTefCanc // Foi possível o desfazimento, pois não houve impressão do cupom TEF
						cMsgCab += STR0093 //"O comando para desfazimento da transação TEF foi enviado com sucesso."
					EndIf
				Else
					cMsgCab += STR0092 //"Uma vez que a impressão do comprovante TEF foi efetuada, não foi possível efetuar o desfazimento. Cancele a transação TEF manualmente."
				EndIf
			EndIf
		EndIf
	EndIf
	If lCupFiscal .AND. lCanCup // Se o cupom fiscal foi cancelado com sucesso
		cMsgCab += STR0094 //"O Cupom Fiscal foi cancelado com êxito."
	EndIf

	//Quando NFC-e, deve processar e cancelar a venda
	If (lEmitNFCe .AND. !lUseSAT) .Or. lIsPafNfce
		cMsgCab += CTRL + STR0172	//"LOJA701C - Não foi possível processar NFC-e! - Venda será processada e cancelada via Job LJGRVBATCH !"
	Elseif lUseSAT
		cMsgCab += CTRL + "LOJA701C - Não foi possível processar o "+cSiglaSat+" !"	//"LOJA701C - Não foi possível processar o SAT !"
	EndIf

	If !IsBlind()

		DEFINE MSDIALOG oDlgLeg TITLE STR0095 FROM 0,0 TO 130,600 PIXEL //"Controle de Transação"

		DEFINE FONT oFntTit NAME "Arial"  SIZE 6,16	BOLD
		DEFINE FONT oFntMsg NAME "Arial"  SIZE 5,15

		@ 0,0  BITMAP oBmp RESNAME "LOGIN" oF oDlgLeg SIZE 100,600 NOBORDER WHEN .F. PIXEL
		@05,50 TO 45,300 PROMPT STR0096 PIXEL //"Help - Controle de Transação"
		@10,52 SAY cMsgCab PIXEL SIZE 240,200 FONT oFntMsg


		@50,200 BUTTON STR0005 PIXEL ACTION oDlgLeg:End() //"Ok"
		@50,230 BUTTON STR0097 PIXEL ACTION If(	!lTelaDetalhe,; //"Detalhes"
		(oDlgLeg:ReadClientCoors(.T.),oDlgLeg:Move(oDlgLeg:nTop,oDlgLeg:nLeft,oDlgLeg:nWidth,oDlgLeg:nHeight+165,,.T.),lTelaDetalhe:=.T.),;
		(oDlgLeg:ReadClientCoors(.T.),oDlgLeg:Move(oDlgLeg:nTop,oDlgLeg:nLeft,oDlgLeg:nWidth,oDlgLeg:nHeight-165,,.T.),lTelaDetalhe:=.F.))

		@ 67,50 TO 140,300 PROMPT STR0098 PIXEL //"Descrição do Erro"
		@ 73,52 GET oMsgDet VAR cMsgDet FONT oFntMsg MEMO size 245,65  PIXEL

		ACTIVATE MSDIALOG oDlgLeg CENTERED

	Else
		Conout(cMsgCab,cMsgDet)
	EndIf

EndIf


//Restaura todas as variáveis Staticas que auxiliam na exibição da mensagem
lImpTefIpdv := .F.
cDescErro 	:= ""
lTelaTefPed	:= .F.
lCupFiscal 	:= .F.

Return Nil

/*ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³LjVerIfErro ³ Autor ³ Vendas Clientes       ³ Data ³ 22/09/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Rotina analizadora do erro                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³CONA010                                                       ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjVerIfErro(e)
Local lRet := .F.
Local cNumOrc := If(Type("M->LQ_NUM")<>"U",M->LQ_NUM,SL1->L1_NUM)

If e:gencode > 0

	LjGravaLog( .T., SL1->L1_NUM, Replicate("*", 40))
	LjGravaLog( .T., SL1->L1_NUM, "DESCRIPTION:" + e:DESCRIPTION)
	LjGravaLog( .T., SL1->L1_NUM, "ERRORSTACK:" + e:ERRORSTACK)
	LjGravaLog( .T., SL1->L1_NUM, Replicate("*", 40))

    cTextoErro := "DESCRIPTION: " + e:DESCRIPTION + CTRL
    cTextoErro += "ERRORSTACK:" + CTRL
    cTextoErro += e:ERRORSTACK

	LjGrvLog(cNumOrc,"ERRO: ",cTextoErro )

	lRet:=.T.

	Break
EndIf

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³Lj701ImpTr  ³ Autor ³ Vendas Clientes       ³ Data ³ 22/09/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Rotina analizadora do erro                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³CONA010                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj701ImpTr (nHandle,lTemTEFPend)
Local lLog1       	:= SubStr(LJGetProfile("LOGERRO"),1,1) == "S" 				// Tem Log de Erro
Local lLog4         := SubStr(LJGetProfile("LOGERRO"),4,1) == "S" 				// Log de Recuperacao, grava as parcelas
Local nSize         := 0															// Tamanho do arquivo de LOG de recuperacao
Local cRBuffer      := ""															// Buffer com conteudo da linha do log txt
Local lImpTefok		:= .F.														// Variavel para transacao TEF
Local lTefCanc		:= .F.															// Variavel para transacao TEF

If cTipTEF $ TEF_SEMCLIENT_DEDICADO+";"+TEF_COMCLIENT_DEDICADO+";"+TEF_DISCADO+";"+TEF_CLISITEF
	If lLog1 .AND. lLog4 .AND. nHandle >= 0
		nSize 		:= FSeek( nHandle, 0, 2 )
		cRBuffer 	:= Space( nSize )

		FSeek( nHandle, 0, 0 )
		FRead( nHandle, @cRBuffer, nSize )

		cRBuffer := Encript( cRBuffer, 1 )
		If !("#TEF#" $ cRBuffer)
			cRBuffer := cRBuffer + "#TEF#"
		EndIf

		FSeek( nHandle, 0, 0 )
		FWrite( nHandle, Encript( cRBuffer, 0 ) )
	EndIf


	If cTipTEF == TEF_CLISITEF
		oTEF:ImpCupTef()
		If oTef:lImprimiu
			lImpTefok := .T.
			lTemTEFPend := .F.
		EndIf
	Else
		If LOJA010T( "I", "V" )
			LJ701AtCartao()
			lImpTefok := .T.
		EndIf
	EndIf

	If lImpTefok

		If lLog1 .AND. lLog4 .AND. nHandle >= 0
			nSize 		:= FSeek( nHandle, 0, 2 )
			cRBuffer 	:= Space( nSize )

			FSeek( nHandle, 0, 0 )
			FRead( nHandle, @cRBuffer, nSize )

			cRBuffer := Encript( cRBuffer, 1 )
			If !("#TEFOK#" $ cRBuffer)
				cRBuffer := cRBuffer + "#TEFOK#"
			EndIf

			FSeek( nHandle, 0, 0 )
			FWrite( nHandle, Encript( cRBuffer, 0 ) )
		EndIf
	EndIf

Else
	If cTipTEF == TEF_CLISITEF
		oTEF:FinalTrn(0) //Finaliza a TRN com parametro confirma = 1
		MsgInfo(STR0048) //"Transação TEF não efetuada, favor reter o cupom!"
	Else
		lTefCanc := LOJA010T( "F", "N" )
		If lTefCanc
			MsgInfo(STR0048) //"Transação TEF não efetuada, favor reter o cupom!"
		EndIf
	EndIf
EndIf
Return Nil

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³Lj701CvPgt  ³ Autor ³ Vendas Clientes       ³ Data ³ 28/08/07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Converte os valores do aPgtos para a moeda a venda            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³LOJA701C                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj701CvPgt()
Local nX 		:= 0	// Contador de For
Local nTotParcs := 0	// Total de Parcelas

If Len(aPgtos) > 0
	For nX := 1 To Len(aPgtos)
		nTotParcs += Round(	xMoeda(	aPgtos[nX][_MOEORIPGT]	,	aPgtos[nX][_MOEDA]	,	nMoedaCor	,	dDataBase,;
									nDecimais+1)			,	nDecimais	)
	Next nX
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Soma a nota de credito utilizada, pis o aPgtos neste momento³
//³esta sem as notas utilizadas                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nTotParcs := nTotParcs + nNCCUsada

Return nTotParcs

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LOJA701   ºAutor  ³Vendas Clientes     º Data ³  08/07/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Refaz o calculo fiscal dos produtos da venda                º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA                                                   º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjRecalFis( aItens		, lJob		, lEmiteNF	, nQtdItens	,;
					nTotItens	, lOrcFilVen, nValRes	, nQtdEntre )

Local nConta        := 0				// Contador do For
Local nFrete        := 0				// Valor do Frete
Local nDespesa      := 0				// Valor das despesas
Local nSeguro       := 0				// Valor do seguro
Local nDescProp     := 0				// Valor de Desconto Proporcional
Local cCodIss       := ""				// Codigo do ISS utilizado
Local cTipFrete  	:= "" 				// Tipo do Frete
Local nAcrPropIt 	:= 0				// Valor do Acrescimo Proporcional
Local nVlrTotIts  	:= 0				// Valor Total dos Itens
Local nCasasDec 	:= TamSx3("L2_VRUNIT")[2] // Qde de casas decimais no campo L2_VRUNIT
Local lCalcIPI      := .T.
Local lLjIcmjr		:= Lj950Acres(SM0->M0_CGC) .OR. (SuperGetMV("MV_LJICMJR",,.F.) .AND. cPaisLoc == "BRA")
Local cTpFrete 		:= ""
Local aSl2			:={}					//Armazenaa a posição da tabela SL2
Local nI			:= 0					//Variavel auxiliar
Local nReserva		:= 0					//Armazena valor dos itens de entrega
local nFreteProp 	:= 0
Local nDespeProp 	:= 0
Local nSegurProp 	:= 0
Local lScreen	 	:= .T.
Local aSxFci		:= LjCFciParam()
Local lFciVlImpor	:= SL2->(ColumnPos("L2_VLIMPOR")) > 0 .And. SLR->(ColumnPos("LR_VLIMPOR")) > 0 .And. aSxFci[5] .And. aSxFci[6]
Local lFciCod		:= SL2->(ColumnPos("L2_FCICOD")) > 0 .And. SLR->(ColumnPos("LR_FCICOD")) > 0 .And. aSxFci[4] .And. aSxFci[8]
Local lClasFis		:= SL2->(ColumnPos("L2_CLASFIS")) > 0 .And. SLR->(ColumnPos("LR_CLASFIS")) > 0//Classificação Fiscal do Produto
Local nValMer		:= 0	
Local lFRTECF13  	:= ExistBlock("FRTECF13") 						// PE para indicar se o ECF faz o arredondamento (.T.) ou truncamento (.F.) dos valores.
Local lStatusImp13	:= .F.											// Pega o retorno do PE FRTECF13 para verificar arredondamento
Local lMvArrefat	:= (SuperGetMv("MV_ARREFAT") == "S")
Local lAcrescBC		:= !Lj950Acres(SM0->M0_CGC) .OR. ChkIncICMS()	//Incide Acrescimo na Base de Calculo
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local cNomeProg	:= Iif(lFtvdVer12,"FATA701","LOJA701")	//Nome da Rotina

Default lJob 		:= .F.
Default lEmiteNF 	:= .T.
Default nQtdItens 	:= Len(aItens)
Default nTotItens 	:= 0
Default lOrcFilVen 	:= .F.
Default nValRes		:= 0
Default nQtdEntre	:= nQtdItens

If MaFisFound("NF")
	//Finaliza as variaveis fiscais
	MaFisEnd()
EndIf

If ExistFunc("Lj7TpFrete")
	cTpFrete := Lj7TpFrete(SL1->L1_CLIENTE,SL1->L1_LOJA)
EndIf

If lJob
    lCalcIPI	:= (SL1->L1_VALIPI > 0)
    cTpFrete	:= IIf( Empty(cTpFrete) .And. SL1->L1_TPFRET == "S", SL1->L1_TPFRET, cTpFrete)

	//Inicializa as variaveis fiscais
	MaFisIni(	SL1->L1_CLIENTE	, SL1->L1_LOJA	, "C"  , "S"  	,;
				SL1->L1_TIPOCLI	, NIL	    	, NIL  , .F. 	,;
				"SB1"			, cNomeProg 	, NIL	, NIL	,;
				NIL			  	, NIL			, NIL	, NIL	,;
				NIL			  	, NIL			, lEmiteNF, lCalcIPI ,;
				NIL             , NIL        	, NIL 	, NIL	,;
				NIL             , cTpFrete )
Else
    lCalcIPI    := Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_VALIPI"})	 > 0
    cTpFrete	:= IIf( Empty(cTpFrete) .And. (M->LQ_TPFRET == "0" .or. M->LQ_TPFRET == "S" ), "S", cTpFrete)

	//Inicializa as variaveis fiscais
	MaFisIni(	M->LQ_CLIENTE	, M->LQ_LOJA	, "C"	, "S"  	,;
				M->LQ_TIPOCLI      	, NIL         	, NIL	, .F. 	,;
				"SB1"         	, cNomeProg 	, NIL	, NIL	,;
				NIL			  	, NIL			, NIL	, NIL	,;
				NIL			  	, NIL			, lEmiteNF, lCalcIPI,;
				NIL             , NIL        	, NIL 	, NIL	,;
				NIL             , cTpFrete )
EndIf

IF ExistFunc("LjSatMxFis")
	LjSatMxFis()
EndIf
If Type("nDecimais") == "U"
    nDecimais := MsDecimais(nMoedaCor)
EndIf

If lJob .OR. lOrcFilVen
	nFrete            := SL1->L1_FRETE		// Valor do Frete
	nDespesa          := SL1->L1_DESPESA	// Valor das despesas
	nSeguro           := SL1->L1_SEGURO		// Valor do seguro

	If SL1->L1_TPFRET == "S" .Or. SL1->L1_TPFRET == "0" 	 // Sem Frete
		cTipFrete := "0"
	ElseIf SL1->L1_TPFRET == "C" .Or. SL1->L1_TPFRET == "1" // CIF
		cTipFrete := "1"
	ElseIf SL1->L1_TPFRET == "F" .Or. SL1->L1_TPFRET == "2" // FOB
		cTipFrete := "2"
	EndIf
Else
	nFrete            := M->LQ_FRETE		// Valor do Frete
	nDespesa          := M->LQ_DESPESA	// Valor das despesas
	nSeguro           := M->LQ_SEGURO		// Valor do seguro

	If M->LQ_TPFRET == "S" .Or. M->LQ_TPFRET == "0"		 // Sem Frete
		cTipFrete := "0"
	ElseIf M->LQ_TPFRET == "C" .Or. M->LQ_TPFRET == "1" // CIF
		cTipFrete := "1"
	ElseIf M->LQ_TPFRET == "F" .Or. M->LQ_TPFRET == "2" // FOB
		cTipFrete := "2"
	EndIf
EndIf

If !lFtvdVer12
	nVlrTotIts := nTotItens
	
	If aItens[Len(aItens)][__ACRSFIN] > 0 .AND. cTipFrete $ "12" // Frete FOB
		nVlrTotIts := nTotItens - nFrete - nDespesa - nSeguro
	Else
		nVlrTotIts := nTotItens
	Endif

	//Loop para incluir os itens da venda
	For nConta := 1 To nQtdItens
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Desconto Proporcional do Item em relacao do desconto total  ³
		//³realizado na venda.                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nDescProp := aItens[nConta,__DESCPRO]
		nAcrPropIt:= aItens[nConta,__ACRSFIN]

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona o SL2 no item correto, para a funcao LjxPropItem()³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SL2->(DbGoTo(aItens[nConta,__RECNO]))

		SB1->(DbSetOrder(1))
		SB1->(DbSeek(xFilial("SB1")+aItens[nConta,__PRODUTO]))

		cCodIss := Alltrim(MaSBCampo("CODISS"))

		If iif(ExistFunc("LjIsTesISS"), LjIsTesISS(SL1->L1_NUM,SL2->L2_TES), SL2->L2_VALISS > 0) //Item de "servico" não realiza rateio de FRETE
			nFreteProp := 0
			nDespeProp := 0
			nSegurProp := 0
			
		ElseIf nValRes > 0		// Se o item for diferente de retira e tiver valor de frete nele
			If !Empty(aItens[nConta][__ENTREGA])  .AND. !(aItens[nConta][__ENTREGA] $ "2|4") .AND. (aItens[nConta][__FRETE] > 0 .OR. !lJob )
				If nQtdEntre > 1													// proporcionar caso haja mais de um item de reserva
					nFreteProp	:= LjxPropRes(nValRes, nFrete  , lScreen) 	// Valor do frete do item
					nDespeProp	:= LjxPropRes(nValRes, nDespesa, lScreen)	// Valor da despesa do item
					nSegurProp	:= LjxPropRes(nValRes, nSeguro , lScreen)	// Valor do seguro do item
				Else
					nFreteProp := nFrete
					nDespeProp := nDespesa
					nSegurProp := nSeguro
				EndIf
			Else 																//Caso não seja item de retira posterior ou entrega
				nFreteProp := 0
				nDespeProp := 0
				nSegurProp := 0
			EndIf
		ElseIf cTipFrete $ "12"  // CIF FOB
			If nQtdItens > 1	// proporcionar caso haja mais de um item
				nFreteProp	:= LjxPropRes(nTotItens, nFrete  , lScreen, nDescProp, nAcrPropIt ) 	// Valor do frete do item
				nDespeProp	:= LjxPropRes(nTotItens, nDespesa, lScreen, nDescProp, nAcrPropIt )	// Valor da despesa do item
				nSegurProp	:= LjxPropRes(nTotItens, nSeguro , lScreen, nDescProp, nAcrPropIt )	// Valor do seguro do item
			Else
				nFreteProp := nFrete
				nDespeProp := nDespesa
				nSegurProp := nSeguro
			EndIf
		Else																		//Caso não tenha item de retira posterior ou entrega na venda
			nFreteProp := 0
			nDespeProp := 0
			nSegurProp := 0
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Tratamento para tratar se arredonda ou trunca o valor da mercadoria    ³
		//³ para não causar diferença de valor entre o TOTAL e a BASEICM.          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lFRTECF13
			lStatusImp13 := ExecBlock("FRTECF13")
			If lStatusImp13
				If FindFunction("LjArredSat") //Arredondamento Sat
					nValMer := LjArredSat(aItens[nConta,__PRCTAB] * aItens[nConta,__QUANT], TamSx3("D2_TOTAL")[2])							
				Else
					nValMer := a410Arred((aItens[nConta,__PRCTAB] * aItens[nConta,__QUANT] ),"D2_TOTAL",nMoedaCor) 
				EndIf							
			Else
				nValMer := NoRound(aItens[nConta,__PRCTAB] * aItens[nConta,__QUANT], nDecimais)
			EndIf
		Else
			If lMvArrefat
				nValMer := a410Arred((aItens[nConta,__PRCTAB] * aItens[nConta,__QUANT] ),"D2_TOTAL",nMoedaCor)
			Else
				nValMer := NoRound(aItens[nConta,__PRCTAB] * aItens[nConta,__QUANT], nDecimais)
			EndIf
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Adiciona as variaveis nas funcoes fiscais                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		MaFisAdd(	aItens[nConta,__PRODUTO],;					// Produto
					aItens[nConta,__TES],;               		// TES
					aItens[nConta,__QUANT],;                	// Quantidade
					aItens[nConta,__VRUNIT],;            		// Preco unitario
					aItens[nConta,__DESCITEM] + aItens[nConta,__DESCFIN] + aItens[nConta,__DESCPRO],;// Valor do desconto // retirada o acrescimo porque contabilizaria na Matxfis causando inconformidade
					"",;                                     	// Numero da NF original
					"",;                                     	// Serie da NF original
					0,;                                      	// Recno da NF original
					nFreteProp,;       							// Valor do frete do item
					nDespeProp,;      							// Valor da despesa do item
					nSegurProp,;       		 					// Valor do seguro do item
					0,;                                     	// Valor do frete autonomo
					nValMer,;  									// Valor da mercadoria
					0 ,;                                                       // Valor da embalagem
					,;	// 15-RecNo do SB1
					,;	// 16-RecNo do SF4
					,;  // 17-Item
					,;	// 18-Despesas nao tributadas - Portugal
					,;	// 19-Tara - Portugal
					,;	// 20-CFO
					,;  // 21-Array para o calculo do IVA Ajustado (opcional)
					,;	// 22-Concepto
					,;	// 23-Base Veiculo
					0,;	// 24-Lote Produto
					0,;	// 25-Sub-Lote Produto
					,;	// 26-Valor do Abatimento ISS
					Iif(cCodIss==Nil , "" ,cCodIss)) // 27-Codigo ISS
					
		If aItens[nConta,__ACRSFIN] > 0
			MaFisAlt("IT_ACRESCI", aItens[nConta,__ACRSFIN], nConta) 
		EndIf

		If aSxFci[1] .And. aSxFci[9] .And. (lFciVlImpor .Or. lFciCod) .And. lClasFis
			LjCRetFci(aItens[nConta,__PRODUTO], aItens[nConta,__NLOTE], aItens[nConta,__LOTECTL],,, MaFisRet(nConta,"IT_CLASFIS"), nConta)
		EndIf

	Next nConta
ElseIf lFtvdVer12
	nVlrTotIts := nTotItens

	If aItens[Len(aItens)][__ACRSFIN] > 0 .AND. cTipFrete $ "12" // Frete FOB
		nVlrTotIts := nTotItens - nFrete - nDespesa - nSeguro
	Else
		nVlrTotIts := nTotItens
	EndIf

	//Loop para incluir os itens da venda
	For nConta := 1 To nQtdItens
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Desconto Proporcional do Item em relacao do desconto total  ³
		//³realizado na venda.                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nDescProp := aItens[nConta,__DESCPRO]
		nAcrPropIt:= aItens[nConta,__ACRSFIN]

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona o SL2 no item correto, para a funcao FTVDxPropItem()³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SL2->(DbGoTo(aItens[nConta,__RECNO]))

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Adiciona as variaveis nas funcoes fiscais                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SB1->(DbSetOrder(1))
		SB1->(DbSeek(xFilial("SB1")+aItens[nConta,__PRODUTO]))

		SF4->(DbSetOrder(1))
		SF4->(DbSeek(xFilial("SF4")+aItens[nConta,__TES]))

		MaFisIniLoad(	nConta						,;	//Numero do Item no Acols
						{aItens[nConta,__PRODUTO]	,;	//IT_PRODUTO
						aItens[nConta,__TES]		,; 	//IT_TES
						Alltrim(MaSBCampo("CODISS")) ,; 	//IT_CODISS
						aItens[nConta,__QUANT]		,;	//IT_QUANT
						""							,; 	//IT_NFORI
						""							,; 	//IT_SERIORI
						SB1->(RecNo())				,;	//IT_RECNOSB1
						SF4->(RecNo())				,;	//IT_RECNOSF4
						0  							}) 	//IT_RECORI

		If iif(ExistFunc("LjIsTesISS"), LjIsTesISS(SL1->L1_NUM,SL2->L2_TES), SL2->L2_VALISS > 0) //Item de "servico" não realiza rateio de FRETE
			nFreteProp := 0
			nDespeProp := 0
			nSegurProp := 0
			
		ElseIf cTipFrete $ "12"  // CIF FOB
			If nQtdItens > 1	// proporcionar caso haja mais de um item
				nFreteProp	:= LjxPropRes(nTotItens, nFrete  , lScreen, nDescProp, nAcrPropIt ) 	// Valor do frete do item
				nDespeProp	:= LjxPropRes(nTotItens, nDespesa, lScreen, nDescProp, nAcrPropIt )	// Valor da despesa do item
				nSegurProp	:= LjxPropRes(nTotItens, nSeguro , lScreen, nDescProp, nAcrPropIt )	// Valor do seguro do item
			Else
				nFreteProp := nFrete
				nDespeProp := nDespesa
				nSegurProp := nSeguro
			EndIf

			MaFisLoad("IT_FRETE"	,nFreteProp 																   ,nConta)
		EndIf

		MaFisLoad("IT_VALMERC"	,a410Arred((aItens[nConta,__PRCTAB] * aItens[nConta,__QUANT] ),"D2_TOTAL") + aItens[nConta,__ACRSFIN] ,nConta)
		MaFisLoad("IT_PRCUNI"	,aItens[nConta	,__VRUNIT]															,nConta)
		MaFisLoad("IT_DESCONTO"	,aItens[nConta	,__DESCITEM] + aItens[nConta,__DESCPRO] + aItens[nConta,__DESCFIN] ,nConta)

		MaFisRecal("",nConta)

		If aSxFci[1] .And. aSxFci[9] .And. (lFciVlImpor .Or. lFciCod) .And. lClasFis
			LjCRetFci(aItens[nConta,__PRODUTO], aItens[nConta,__NLOTE], aItens[nConta,__LOTECTL],,, MaFisRet(nConta,"IT_CLASFIS"), nConta)
		EndIf

		MaFisEndLoad(nConta,2)

	Next nConta
EndIf

//Atribui o valor do Frete, Seguro, Despesa (desta forma eh rateado automaticamente nos itens pela MatxFis (IT_FRETE, IT_SEGURO, IT_DESPESA)
// Somente quando não houver itens de reserva ou retira posterior
If nValRes = 0
	If nFrete > 0
		MaFisAlt( "NF_FRETE", nFrete )
	EndIf
	If nSeguro > 0
		MaFisAlt( "NF_SEGURO", nSeguro )
	EndIf
	If nDespesa > 0
		MaFisAlt( "NF_DESPESA", nDespesa )
	EndIf
EndIf

Return .T.

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³Lj7GeraEntºAutor  ³Vendas Clientes     º Data ³  14/01/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Faz a gravacao do Pedido de Venda, para vendas em que a    º±±
±±º          ³ entrega e emissao de Documento Fiscal sera realizado pelo  º±±
±±º          ³ modulo de Faturamento.                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Lj7GeraEnt(aSL1		, aSL2		, cFilEnt, 	 cOrcFilho	,;
					lJob 		, lAlterOrc	, cFilLoc, 	 cFilRes	,;
					cLjCliente	, cLjLojCli	, lExistVfe, cNumPai 	,;
					lAvCred	)
Local aCabPed		:= {}											//Cabecalho das NFs
Local aItensPed		:= {}											//Itens das NFs
Local aLinhaPed		:= {}											//Itens das NFs
Local aRet			:= {}											//Retorno da Funcao
Local aRetRes		:= {}											//Retorno da Funcao de Cancelamento da Reserva
Local aReserva		:= {}											//Array com os Dados da Reserva para Cancelamento
Local aSL1Tmp		:= {}											//Array para gravacao do Pedido no Orcamento Filho
Local aSL2Tmp		:= {}											//Array para gravacao do Pedido no Orcamento Filho

Local cCondPag		:= SuperGetMV("MV_LJCONDP", NIL, "")			//Condicao de Pagamento para Emissao do Pedido de Venda
Local cTES			:= ""											//TES utilizado para a geracao do Pedido de Venda
Local cFilBkp		:= cFilAnt										//Guarda a Filial Atual
Local cPedido		:= ""											//Numero do Pedido de Venda

Local nI			:= 0											//Contador
Local nCpo			:= 0											//Contador
Local nItens		:= Len(aSL2)									//Quantidade de Itens
Local nPosItem		:= 0											//Posicao do Item no aSL2
Local nTamC6It		:= TamSx3("C6_ITEM")[1]							//Tamanho do Campo C6_ITEM
Local nPosCli		:= 0											//Posicao do Cliente no aSL1
Local nPosLoj		:= 0											//Posicao da Loja no aSL1
Local nPosTransp	:= 0											//Posicao da Transportadora no aSL1
Local nPosVeicul	:= 0											//Posicao do Veiculo no aSL1
Local nPosTipoCli	:= 0											//Posicao do Tipo do Cliente no aSL1
Local nPosEmissao	:= 0											//Posicao da Emissao no aSL1
Local nPosVend		:= 0											//Posicao do Vendedor no aSL1
Local nPosFrete		:= 0											//Posicao do Campo do Frete no aSL1
Local nPosSeguro	:= 0											//Posicao do Campo do Seguro no aSL1
Local nPosDespesa	:= 0											//Posicao do Campo da Despesa no aSL1
Local nPosTpFrete	:= 0											//Posicao do Campo do Tipo do Frete aSL1
Local nPosDescNF	:= 0											//Posicao do Percentual de Desconto no aSL1
Local nPosJuros		:= 0											//Posicao do Percentual de Juros no aSL1
Local nPosProd		:= 0											//Posicao do Produto no aSL2
Local nPosDescri	:= 0											//Posicao da Descricao do Produto no aSL2
Local nPosUM		:= 0											//Posicao da Unidade de Medida no aSL2
Local nPosQtde		:= 0											//Posicao da Quantidade no aSL2
Local nPosVrUnit	:= 0											//Posicao do Valor Unitario no aSL2
Local nPosVlrItem	:= 0											//Posicao do Valor do Item no aSL2
Local nPosLocal		:= 0											//Posicao do Armazem no aSL2
Local nPosPrcTab	:= 0											//Posicao do Preco de Tabela no aSL2
Local nPosReserv	:= 0											//Posicao da Reserva no aSL2
Local nPosTurno		:= 0											//Posicao de Turno de entrega
Local nPosSolCom	:= 0											//Posicao da Solicitacao de compras
Local nPosLoteCTL	:= 0											//Posicao do Lote
Local nPosLote		:= 0											//Posicao do SubLote
Local nPosLocaliz	:= 0											//Posicao da Localizacao no sSL2

Local nPDesc		:= 0											//Percentual de Desconto no Total
Local nPJuros		:= 0											//Percentual de Juros no Total
Local nVlrItem		:= 0											//Valor Liquido do Item
Local nVlrUnit		:= 0											//Preco Liquido do Item

Local nQtdeSC       := 0											//Quantidade da solicitacao de compras
Local nPosOrcRes	:= 0											// Posicao do campo que indica o orcamento que esta fazendo a reserva
Local lRet			:= .T.											//Retorno da Funcao
Local lLJ7046		:= ExistBlock("LJ7046")							//VerIfica se existe o Ponto de Entrada LJ7PED
Local lLJ7065		:= ExistBlock("LJ7065")							//PE que subistitui o MATA410I chamado na geracao dos itens do pedido
Local lLJ7066		:= ExistBlock("LJ7066")							//PE que subistitui o M410STTS chamado na geracao do pedido
Local nX			:= 0											//Contador dos itens
Local cNumSc5		:= ""											// Numero do Pedido	- Inclusao
Local cMay      	:= ""											// Variavel auxiliar
Local nY			:= 0                                         	// Contador
Local lLiber 		:= .F.											// Compatibilizacao com o SIGAFAT
Local lTransf		:= .F.                                      	// Compatibilizacao com o SIGAFAT
Local lLiberOk 		:= .T.											// Compatibilizacao com o SIGAFAT
Local lResidOk 		:= .T.											// Compatibilizacao com o SIGAFAT
Local lFaturOk 		:= .F.											// Compatibilizacao com o SIGAFAT
Local lTLVReg  		:= .F.											// Compatibilizacao com o SIGAFAT
Local cMV_LJTESPE	:= SuperGetMV("MV_LJTESPE", NIL, "501")			// TES utilizado para a geracao do Pedido de Venda
Local lExecParTES   := Substr(cMV_LJTESPE,1, 1) == "&"             	// Controla se pode macro-executar o parametro MV_LJTESPE
Local xRet  														// Retorno do parametro MV_LJTESPE, se for macro-executado
Local lTESInvalido  := .F.											// TES invalido no retorno do MV_LJTESPE (macro-execucao) ou TES inteligente
Local cTipOper		:= Padr("V",TamSx3("FM_TIPO")[1])				// Tipo de operacao entrega futura
Local nPosMostruario:= 0											//Posicao do campo MOSTRUARIO/SALDAO
Local nPosObsMostr  := 0											//Posicao da observacao do mostruario/saldao
Local lC6ItemGar	:= SC6->(ColumnPos("C6_ITEMGAR")) > 0
Local lC6OrcGar		:= SC6->(ColumnPos("C6_ORCGAR")) > 0
Local nPosItemGar	:= 0
Local nC5_Moeda     := 1                                            // Moeda do pedido de venda
Local cC5_TipLib    := SuperGetMv("MV_LJLIBPE",.F. , "1")                                           // Tipo de liberacao  1-Libera por item \ 2-Libera por pedido
Local cC5_TpCarga   := If(SuperGetMV("MV_LJGCOMS", NIL, .F.),'1','2')// Carga  1-Utiliza \ 2-Nao utiliza
Local cC5_GeraWMS   :="1"                                           // GERAOSWMS  1-No Pedido \ 2-Na Montagem\ 3-Na utilizacao
Local cC6_TpOp      :="F"                                           // Tipo de Operacao 1 -Firme \ 2-Prevista
Local lFTVD7046		:= ExistBlock("FTVD7046")						//VerIfica se existe o Ponto de Entrada LJ7PED
Local cCFOP			:= ""											// Variavel usada para tratar o CFOP que sera gravado no item do pedido
Local aDadosCfo		:= {}											// Array para montagem do tratamento do CFOP
/*Tratamento para eCommerce */
Local lECommerce 	:= SuperGetMV("MV_LJECOMM",,.F.) .AND. SL1->(ColumnPos("L1_ECFLAG") > 0) .AND. (Posicione("SL1",1,xFilial("SL1")+cOrcFilho,"L1_ECFLAG") == "1")
Local lMvLjIPEn		:= SuperGetMV("MV_LJIPENP",, .F.)

// Variáveis incluidas para atender as necessidades da integração com E-Commerce
Local aItPedPres	:= {}											//Itens das NFs Presente
Local aAxlItens		:= {}                                           //Var Generica para comportar aItens
Local aPosAux		:= {}                                           //Armazena as Possições do array de itens
Local lPosAux		:= .F.                                          //Define se Array ja foi carregado
Local nPosECPresn   := 0											//Posicao do Presente no sSL2
Local nPosECPedS	:= 0
Local nPosECMEN		:= 0
Local nCont         := 0											//Contador
Local cTESPRESN		:= SuperGetMv("MV_LJECOMC",NIL,"")             //Verifica o TES configurado como Presente
Local cManPad		:= SuperGetMv("MV_LJECOMD",NIL,"")             //Mensagem padrao para pedido de venda de presente e-Commerce
Local cPedPRESN		:= "2"											//Define se o pedido é Presente ou Nao
Local cCFOPPRES		:= ""                                           //CFOP de TES de Presente
Local cPedPai		:= ""											//Pedido Pai para amarração com o pedido presente
Local cPedFilho		:= ""											//Pedido Filho que eh gerado para Presente
Local nECVezes		:= 1
Local lMultEndEnt	:= SL2->(ColumnPos("L2_CLIENT")) > 0 .AND. SL2->(ColumnPos("L2_CLILOJA")) > 0 // Checa se existe a opcao de entrega para multi enderecos
Local nPosClEntrega := 0
Local nPosLojEntrega:= 0
Local lGerSolCom	:= .F.
Local nPosL1Desc	:= 0										// Flag Gerou Solicitação Compra
Local aArea         := GetArea()
Local nIPIDesc		:= 0										//Valor de Desconto no IPI
Local nPrecoTab		:= 0										//Preco de Tabela
Local aAx2Itens		:= {}
Local cTesEnt		:= ""
Local aDadosNf		:= {}
Local cOrcPai		:= ""
Local nPosAux		:= 0
Local cNunNf		:= ""
Local cSerNf		:= ""
Local aBkpSl1		:= {}
Local aAreaTmp 		:= {}
Local cCliEntreg 	:= ""										//Cliente de Entrega
Local cLojEntreg 	:= ""
Local nPosCodLis 	:= 0
Local cCodLisPre 	:= "" 										//Codigo da Lista de Presente
Local nPosClasFis	:= 0										//Classificação Fiscal do Produto
Local cClasFis		:= ""										//Classificação Fiscal do Produto
Local nPosFilRes	:= 0										//Filial efetuada reserva VFE
Local nPosIsVFE		:= 0										//Se eh VFE
Local cCFOPEnt		:= 0
Local aSF4Ord		:= {}
Local nTotIPI		:= 0 										//Valor total do IPI   - MatxFis
Local nTotIPIEn     := 0 										//Valor total do Embutido
Local nCasasIPI		:= SLR->(TamSX3("LR_VALIPI")[2])			//Numero de Casas do IPI
Local lMVRNDIPI 	:= SuperGetMV("MV_RNDIPI", NIL, .F.) 			//IPI Arredondado?
Local lMVLjDtIPI 	:= SuperGetMv("MV_LJDTIPI", , .F.) 			//define se a diferença entre o IPI embutido e o calculado será lançado como desconto no total da NF
Local lCentroDL     := SuperGetMv("MV_LJCDL",, .F.)             //Ativa a VFE com Centro de Distribuicao Matriz x Local
Local cCli          := ""                                       //Cliente de Entrega
Local cLojCli       := ""                                       //Loja de Entrega
Local lVFE          := .F.                                      //Controla a atualizacao do Cliente e Loja de Entrega
Local aAreaSA1		:= {}											//Area de Trabalho SA1
Local cItem			:= Space(nTamC6It)
Local lC6CodLP		:= SC6->(ColumnPos("C6_CODLPRE")) > 0		//Lista de presente
Local lC6ITLtP		:= SC6->(ColumnPos("C6_ITLPRE")) > 0			//Lista de presente
Local nPosItLtPre	:= 0
Local lLstPre		:= .F.										//É lista de presente
Local cTESList		:= SuperGetMV("MV_LJLPTSV",,"")				//Tipo de Entrada/Saida padrao para o Pedido de Venda
Local cTpOperLst	:= SuperGetMV("MV_LJLPTIV",,"")	            //Tipo da Operacao para o Pedido de Venda (TES Inteligente)
Local nRecSM0Bkp 	:= 0 										//Guarda o Recno da SM0 para reposicionar depois corretamente
Local nTent 		:= 0										// Tentativas para pegar a numeracao do SC5
Local nSaveSx8 		:= GetSx8Len()								// Numeracao do SX8
Local lLj8GrvPed	:= ExistFunc("Lj8GrvPed")
Local lPosL2ITESC6	:= SL2->(ColumnPos("L2_ITESC6")) > 0
Local nPosMenNota	:= 0									//Posiçao L1_MENNOTA
Local nPosTes		:= 0										// Posicao da TES
Local nAux			:= 0									// posicao do campo temporario CONTADOR_PED protecao no retorno do PE LJ7046
Local nPosEspeci	:= 0
Local nPosVolume	:= 0
Local nPosPLiq		:= 0
Local nPosPBru		:= 0
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local nPosNSerie	:= 0 //Numero de série
Local nPosDtVal		:= 0 //Validade do lote
Local lLiberou 		:= .F.

If nCasasIPI = 0
	nCasasIPI := SLR->(TamSX3("LR_VRUNIT")[2])
EndIf

Default cFilEnt		:= cFilAnt										//Filial para geracao do Pedido
Default lJob		:= .F.											//IdentIfica se a rotina e' chamada via JOB ou nao

Private lMSErroAuto	:= .F.											//VerIfica se ocorreu algum erro durante a Geracao do PV

Default lAlterOrc   := .F.
Default cFilLoc     := ""
Default cFilRes     := ""
Default cLjCliente  := ""
Default cLjLojCli   := ""
Default lExistVfe	:= .F.
Default cNumPai		:= ""
Default lAvCred 	:= .T.  // Variavel que controla analise de credito para o pedido.

cTpOperLst := Padr(cTpOperLst, TamSx3("FM_TIPO")[1]) //Ajusta tamanho tipo de operação para TES Inteligente

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³eCommerce: Altera a TES para a geracao do Pedido de Venda.  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If  lECommerce
	cMV_LJTESPE	:= SuperGetMV("MV_LJECOME", NIL, cMV_LJTESPE)
EndIf

If !RTrim(cC5_TipLib) $ "1#2"
	cC5_TipLib := "1"
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Altera a Filial para geracao na Filial Correta.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cFilEnt <> cFilAnt
	nRecSM0Bkp	:= SM0->(Recno()) 	//Guarda o Recno da SM0 para reposicionar corretamente no final dessa funcao
	cFilAnt := cFilEnt
EndIf

aAx2Itens		:= {}
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checagem de Parametro de TES de Cliente.		  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(cTESPRESN) .And. lECommerce
	DbSelectArea("SF4")
	DbSetOrder(1)	//Filial + Codigo
	If !DbSeek(xFilial("SF4") + cTESPRESN)
		lRet := .F.
		If !lJob
			Aviso(STR0100, STR0170, {STR0005}, 2)	//"Parametro"###"Verifique o TES  Presente cadastrado no parâmetro MV_LJECOMC, pois o mesmo não foi encontrado no Cadastro de TES."##"Ok"
		Else
			Conout(STR0170)	   	   					//"Verifique o TES de Presente cadastrado no parâmetro MV_LJECOMC, pois o mesmo não foi encontrado no Cadastro de TES."
		EndIf
	Else
		cCFOPPRES	:= SF4->F4_CF
	EndIf

	RestArea(aArea)

EndIf

//Busca o Teste de entrega utilizado no caso de venda futura com emissao de documento fiscal
cTesEnt := SuperGetMV("MV_LJVFTEE",,"501")

nPosAux := ascan(aSL1, {|x| Alltrim(Upper(x[1])) == 'L1_ORCRES' } )
If nPosAux > 0
	cOrcPai := aSL1[nPosAux][2]
Endif

If Empty( cOrcPai )
	nPosAux := ascan(aSL1, {|x| Alltrim(Upper(x[1])) == 'L1_NUM' } )
	If nPosAux > 0
		cOrcPai := aSL1[nPosAux][2]
	Endif
Endif

If !lExecParTES
	cTES  := cMV_LJTESPE

	DbSelectArea("SF4")
	DbSetOrder(1)	//Filial + Codigo
	If !Empty(cTES) .AND. !DbSeek(xFilial("SF4") + cTES)
		lRet := .F.
		If !lJob
			Aviso(STR0100, STR0101, {STR0005}, 2)	//"Parametro"###"VerIfique o TES cadastrado no parâmetro MV_LJTESPE, pois o mesmo não foi encontrado no Cadastro de TES."##"Ok"
		Else
			Conout(STR0101)	   	   					//"VerIfique o TES cadastrado no parâmetro MV_LJTESPE, pois o mesmo não foi encontrado no Cadastro de TES."
		EndIf
	EndIf
EndIf

If lRet
	DbSelectArea("SE4")
	DbSetOrder(1)	//Filial + Codigo
	If Empty(cCondPag) .OR. !DbSeek(xFilial("SE4") + cCondPag)
		lRet := .F.
		If !lJob
			Aviso(STR0100, STR0102, {STR0005}, 2)	//"Parametro"###"VerIfique a Condição de Pagamento cadastrada no parâmetro MV_LJCONDP, pois a mesma não foi encontrada no Cadastro de Condições de Pagamento."##"Ok"
		Else
			Conout(STR0102)							//"VerIfique a Condição de Pagamento cadastrada no parâmetro MV_LJCONDP, pois a mesma não foi encontrada no Cadastro de Condições de Pagamento."
		EndIf
	EndIf
EndIf


If lRet
	nPosCli		:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_CLIENTE"	})
	nPosLoj		:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_LOJA" 	})
	nPosTransp	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_TRANSP"	})
	nPosVeicul	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_VEICUL1"	})
	nPosTipoCli	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_TIPOCLI"	})
	nPosEmissao	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_EMISSAO"	})
	nPosVend	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_VEND"		})
	nPosFrete	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_FRETE"	})
	nPosSeguro	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_SEGURO"	})
	nPosDespesa	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_DESPESA"	})
	nPosTpFrete	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_TPFRET"	})
	nPosDescNF	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_DESCNF"	})
	nPosJuros	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_JUROS"	})
	nPosOrcRes	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_ORCRES"	})
	nPosL1Desc	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_DESCONT"	})
	nPosMenNota:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_MENNOTA"	})

	nPosCodLis 	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_CODLPRE" })
	nPosEspeci	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_ESPECIE"	})
	nPosVolume	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_VOLUME"	})
	nPosPLiq	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_PLIQUI"	})
	nPosPBru	:= Ascan(aSL1, {|x| AllTrim(x[1]) == "L1_PBRUTO"	})

	cCliEntreg	:= aSL1[nPosCli][2]
	cLojEntreg	:= aSL1[nPosLoj][2]
	lLstPre		:= .F.

	//Se for Venda de Lista de Presente, busca o cliente de entrega
	If nPosCodLis > 0 .AND. !Empty(aSL2[1][nPosCodLis][2])
		cCodLisPre := aSL2[1][nPosCodLis][2]

		DbSelectArea("ME1")
		ME1->( DbSetOrder(2) ) //ME1_FILIAL+ME1_CODIGO+ME1_TIPO+ME1_CODCLI+ME1_LOJCLI
		If ME1->( DbSeek(xFilial("ME1")+cCodLisPre) )
			cCliEntreg := ME1->ME1_CODCLI
			cLojEntreg := ME1->ME1_LOJCLI
			lLstPre    := .T.
		EndIf
	ElseIf lECommerce .AND. MF5->(ColumnPos("MF5_CLIENT")) > 0
		If !Empty( Posicione("MF5",1,xFilial("MF5")+"SL1"+xFilial("SL1")+cOrcPai ,"MF5_CLIENT") )
			cLojEntreg := MF5->MF5_CLIENT
		EndIf
	EndIf

	If lMultEndEnt
		nPosClEntrega := Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_CLIENT"	})
		nPosLojEntrega:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_CLILOJA"	})

		// Caso os campos cliente e loja de entrega estejam vazios, lMultEndEnt é setado como falso para usar o L1_CLIENTE como cliente de entrega
		If Empty(aSL2[1,nPosClEntrega,2]) .AND.  Empty(aSL2[1,nPosLojEntrega,2])
			lMultEndEnt := .F.
		EndIf
	EndIf

	nPDesc	:= aSL1[nPosDescNF][2]
	nPJuros	:= aSL1[nPosJuros][2]

	// Validacao da Venda Fora do Estado com CD Centralizado_Matriz x Cd Local de entrega
	Aadd(aCabPed,{ "C5_FILIAL",	xFilial("SC5"),NIL })

	If lCentroDL .And. lExistVfe
		Aadd(aCabPed,{ "C5_CLIENTE", cLjCliente,NIL })
		Aadd(aCabPed,{ "C5_LOJACLI", cLjLojCli ,NIL })
		Aadd(aCabPed,{ "C5_CLIENT",  cLjCliente,NIL })
		Aadd(aCabPed,{ "C5_LOJAENT", cLjLojCli ,NIL })

		//Para VFE necessario posicionar no cliente que pode ser CD
		aAreaTmp := GetArea()
		aAreaSA1 := SA1->(GetArea())

		SA1->(dbSetOrder(1))
		SA1->(dbSeek(xFilial("SA1") + cLjCliente + cLjLojCli))

		Aadd(aCabPed,{ "C5_TIPOCLI", SA1->A1_TIPO, NIL})

		//Restaura areas
		RestArea(aAreaSA1)
		RestArea(aAreaTmp)
	Else
		Aadd(aCabPed,{ "C5_CLIENTE",	aSL1[nPosCli][2]	,NIL })
		Aadd(aCabPed,{ "C5_LOJACLI",	aSL1[nPosLoj][2]	,NIL })
		Aadd(aCabPed,{ "C5_CLIENT",		IIf(lMultEndEnt,aSL2[1,nPosClEntrega,2],cCliEntreg) ,NIL })
		Aadd(aCabPed,{ "C5_LOJAENT",	IIf(lMultEndEnt,aSL2[1,nPosLojEntrega,2],cLojEntreg),NIL })
		Aadd(aCabPed,{ "C5_TIPOCLI",	aSL1[nPosTipoCli][2]	,NIL })
	EndIf

	Aadd(aCabPed,{ "C5_TIPO","N",NIL })
	Aadd(aCabPed,{ "C5_TRANSP",		aSL1[nPosTransp][2]		,NIL })

	If nPosVeicul > 0
		Aadd(aCabPed,{ "C5_VEICULO",	aSL1[nPosVeicul][2]		,NIL })
	EndIf

	Aadd(aCabPed,{ "C5_EMISSAO",	aSL1[nPosEmissao][2]	,NIL })
	Aadd(aCabPed,{ "C5_VEND1",		aSL1[nPosVend][2]		,NIL })
	Aadd(aCabPed,{ "C5_CONDPAG",	cCondPag				,NIL })
	Aadd(aCabPed,{ "C5_ORCRES",		cOrcFilho				,NIL })
	Aadd(aCabPed,{ "C5_FRETE",		aSL1[nPosFrete][2]		,NIL })
	Aadd(aCabPed,{ "C5_SEGURO",		aSL1[nPosSeguro][2]		,NIL })
	Aadd(aCabPed,{ "C5_DESPESA",	aSL1[nPosDespesa][2]	,NIL })
	Aadd(aCabPed,{ "C5_TPFRETE",	aSL1[nPosTpFrete][2]	,NIL })
	If nPDesc > 0 .AND. !(lECommerce .AND. lMvLjIPEn)
		Aadd(aCabPed,{ "C5_DESC1"	, nPDesc					,NIL })
	Else
		nPDesc := 0
	EndIf
	Aadd(aCabPed,{ "C5_MOEDA",		nC5_Moeda				,NIL })
	Aadd(aCabPed,{ "C5_TIPLIB",	    cC5_TipLib				,NIL })
	Aadd(aCabPed,{ "C5_TPCARGA",	cC5_TpCarga				,NIL })
	Aadd(aCabPed,{ "C5_GERAWMS",	cC5_GeraWMS				,NIL })
	If  SC5->( ColumnPos("C5_ECPRESN") > 0 )
		Aadd(aCabPed,{ "C5_ECPRESN",	cPedPRESN				,NIL })
	EndIf
	Aadd(aCabPed,{ "C5_MENPAD"	,	""						,NIL })
	Aadd(aCabPed,{ "C5_MENNOTA"	,	aSL1[nPosMenNota][2]	,NIL })

	//Release 11.5 Chile/Colombia
	//Pedido de Venda / controle de formularios
	If lCFolLocR5
		Aadd(aCabPed,{ "C5_TIPOREM"	,	"0"					,NIL })
		Aadd(aCabPed,{ "C5_SERIE"	,SuperGetMV("MV_LOJAPED"),NIL })
	EndIf
	Aadd( aCabPed,{ "C5_ESPECI1", aSL1[nPosEspeci][2]	, NIL })
	Aadd( aCabPed,{ "C5_VOLUME1", aSL1[nPosVolume][2]	, NIL })
	Aadd( aCabPed,{ "C5_PESOL"	, aSL1[nPosPLiq][2]		, NIL })
	Aadd( aCabPed,{ "C5_PBRUTO"	, aSL1[nPosPBru][2]		, NIL })

	LjGrvLog(cOrcPai,"Geracao de pedido - cabecalho: ",aCabPed)

	nPosECPedS	:= IIF(SC5->(FieldPos("C5_ECPRESN") > 0), Ascan(aCabPed, {|x| AllTrim(x[1]) == "C5_ECPRESN"	}), 0)
	nPosECMEN	:= Ascan(aCabPed, {|x| AllTrim(x[1]) == "C5_MENPAD"	})
	aItensPed	:= {}
	aLinhaPed	:= {}

	If lECommerce .AND. lMvLjIPEn .AND. lMVLjDtIPI
	//define se a diferença entre o IPI embutido e o calculado será lançado como desconto no total da NF

		If MaFisFound("NF")
			MaFisEnd()

		  	MaFisIni(Iif(Empty(IIf(lMultEndEnt,aSL2[1,nPosClEntrega,2],cCliEntreg)),aSL1[nPosCli][2],IIf(lMultEndEnt,aSL2[1,nPosClEntrega,2],cCliEntreg)),;
					IIf(lMultEndEnt,aSL2[1,nPosLojEntrega,2],cLojEntreg),;
					"C",;
					"N",;
					aSL1[nPosTipoCli][2],;
					Nil,;
					Nil,;
					Nil,;
					Nil,;
					"LOJA701",;
					Nil,;
					Nil,;
					Nil,;
					Nil,;
					Nil,;
					Nil,;
					Nil,;
					NIL,,,,aSL1[nPosCli][2],aSL1[nPosLoj][2],,,aSL1[nPosTpFrete][2])


			If aSL1[nPosTpFrete][2] $ "CF"  // CIF FOB
				MaFisAlt( "NF_FRETE"	, aSL1[nPosFrete][2] )
				MaFisAlt( "NF_SEGURO"	, aSL1[nPosSeguro][2] )
				MaFisAlt( "NF_DESPESA"	, aSL1[nPosDespesa][2] )
			EndIf

        EndIf
    EndIf

	//Guarda a posicao dos Campos no aSL2.
	nPosProd	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_PRODUTO"	})
	nPosDescri	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_DESCRI"	})
	nPosUM		:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_UM"		})
	nPosQtde	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_QUANT"		})
	nPosVrUnit	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_VRUNIT"	})
	nPosVlrItem	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_VLRITEM"	})
	nPosLocal	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_LOCAL"		})
	nPosPrcTab	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_PRCTAB"	})
	nPosReserv	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_RESERVA"	})
	nPosEntreg	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_FDTENTR"	})
	nPosTurno	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_TURNO"		})
	nPosSolCom	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_SOLCOM"	})
	nPosMostruario := Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_VDMOST"	})
	nPosObsMostr:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_VDOBS"		})
	nPosLoteCTL	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_LOTECTL"	})
	nPosLote	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_NLOTE"		})
	nPosLocaliz := Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_LOCALIZ"	})
	nPosNSerie :=  Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_NSERIE"	})
	
	nPosDtVal :=  Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_DTVALID"	})
	nPosECPresn := IIF(SL2->(ColumnPos("L2_ECPRESN") > 0), Ascan(aSL2[1], {|x| Alltrim(x[1]) == "L2_ECPRESN" }), 0)
	nPosItemGar := Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_ITEMGAR"	})
	nPosFciCod	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_FCICOD" 	})
	nPosVlImpor	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_VLIMPOR" 	})
	nPosClasFis	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_CLASFIS" 	})
	nPosValDesc := Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_VALDESC" 	})
	nPosFilRes	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_FILPED" 	}) //Filial VFE
	nPosIsVFE	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_ISVFE" 	}) //Indica se eh VFEs
	nPosCodLis	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_CODLPRE" 	}) //Codigo da lista de presente
	nPosItLtPre	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_ITLPRE" 	}) //Item da venda na lista de presente
	nPosTes		:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_TES" 		}) // Posicao da TES
	nPosReserv	:= Ascan(aSL2[1], {|x| AllTrim(x[1]) == "L2_RESERVA"	})

	cItem := StrZero(0,nTamC6It,0) // Inicializa a soma de itens no pedido

	For nI := 1 to nItens
		//Release 11.5 - Localizacoes - F2CHI
		//Nao incluir o item no pedido de venda se nao houver reserva.
		If lCFolLocR5		    
		    If Empty(aSL2[nI][nPosReserv][2])
				Loop
		    EndIf
		EndIf

		If lFtvdVer12			
			//Posiciona no TES do pedido-pai
			If nPosTES > 0
				SF4->(DbSetOrder(1)	)
				SF4->(DbSeek(xFilial("SF4") + aSL2[nI][nPosTES][2]))
			EndIf
		EndIf

		//Eleger TES utilizada atraves do parametro MV_LJTESPE (macro-executa)
		If lExecParTES
		   xRet  := &(SubStr(cMV_LJTESPE,2,Len(cMV_LJTESPE)))
		   If ValType(xRet) == "C"
		   	  cTES  := xRet
		   EndIf
		EndIf

		//Eleger TES utilizada atraves do TES INTELIGENTE ou do parametro "MV_LJTESPE"
		If !lExecParTES .OR. Empty(cTES)
			If lLstPre //TES inteligente para lista de presente
				cTes := MaTesInt( 2, cTpOperLst, IIf(Empty(cCliEntreg), aSL1[nPosCli][2], cCliEntreg),; 
				                IIf(Empty(cLojEntreg), aSL1[nPosLoj][2], cLojEntreg),; 
				                "C", aSL2[nI][nPosProd][2], NIL )
				If Empty(cTes)
					cTes := cTESList
				EndIf
			Else
				cTes := MaTesInt( 2	,cTipOper,aSL1[nPosCli][2],aSL1[nPosLoj][2],;
						 		"C",aSL2[nI][nPosProd][2],NIL)
			EndIf

			If Empty(cTes)
			   cTes	:= cMV_LJTESPE
			EndIf
		EndIf

		//Ponto de Entrada para definir a TES a ser utilizada no Item do PEDIDO
		If ExistBlock("LJTESPED")
			LjGrvLog( NIL, " Antes da Execução do PE LJTESPED")
			cTES := ExecBlock("LJTESPED",.F.,.F.,{cTES,aSL1,aSL2,nI})
			LjGrvLog( NIL, " Depois da Execução do PE LJTESPED")
		EndIf

		SF4->(DbSetOrder(1)	)
		If !SF4->(DbSeek(xFilial("SF4") + cTES))
		   lTESInvalido  := .T.
		EndIf

        // Retirada comparacao do Venda Assistida x Venda Direta.
        // Venda com entrega fora do Estado da venda, estava gravando CFOP do Estado da venda.
        // Com o retorno da funcao MaFisCfo utilizado pelo Venda Direta, esta gravando corretamente CFOP de fora do Estado.
		// Eleger TES padrao atraves dos parametros MV_LJTESPE ou MV_TESSAI
		If Empty(cTES) .OR. lTESInvalido
	    	If !lExecParTES
				cTES := SuperGetMV("MV_LJTESPE", NIL, "501")
			Else
				cTES := SuperGetMV("MV_TESSAI", NIL , "501")
			EndIf
		EndIf

		SF4->(DbSetOrder(1)	)
		SF4->(DbSeek(xFilial("SF4") + cTES))

		aAreaSA1 := SA1->(GetArea())
		SA1->(DbSetOrder(1))
		If lMultEndEnt //Leio o cliente/loja de entrega digitado no item.
			SA1->(DbSeek(xFilial("SA1")+SL2->L2_CLIENT+SL2->L2_CLILOJA))
		Else
			SA1->(DbSeek(xFilial("SA1")+SL1->L1_CLIENTE+SL1->L1_LOJA))
		EndIf
		
		aDadosCfo := {}
		Aadd(aDadosCfo,{"OPERNF"	, "S"				})
		Aadd(aDadosCfo,{"TPCLIFOR"	, SA1->A1_TIPO		})
		Aadd(aDadosCfo,{"UFDEST"	, SA1->A1_EST		})
		Aadd(aDadosCfo,{"INSCR"		, SA1->A1_INSCR		})

		If SA1->(ColumnPos("A1_CONTRIB")) > 0
			Aadd(aDadosCfo,{"CONTR"	, SA1->A1_CONTRIB	})
		EndIf

		cCFOP	:= MaFisCfo(,SF4->F4_CF,aDadosCfo)

		If Empty(cCFOP)
			cCFOP	:= SF4->F4_CF
		EndIf
		RestArea(aAreaSA1)

		//Tratar os desconto do Pedido no Valor do Item.
		If  lECommerce .AND. (nPDesc > 0) .AND. (aSL2[nI][nPosVrUnit][2] == aSL2[nI][nPosPrcTab][2])
			aSL2[nI][nPosVrUnit][2]  := (aSL2[nI][nPosVrUnit][2] * (1-(nPDesc/100)))
			aSL2[nI][nPosVlrItem][2] := (aSL2[nI][nPosVrUnit][2] * aSL2[nI][nPosQtde][2])
		EndIf
		
		//Posicionamento dos itens do Pedido.
		SB1->(DbSetOrder(1))
		SB1->(DbSeek(xFilial("SB1")+aSL2[nI][nPosProd][2]))
		
		cItem := Soma1(cItem)

		//Grava valor liquido no Pedido de Venda.
		Aadd(aLinhaPed,{ "C6_FILIAL",	xFilial("SC5")	   				,NIL })
		Aadd(aLinhaPed,{ "C6_ITEM",		cItem							,NIL })
		Aadd(aLinhaPed,{ "C6_PRODUTO",	aSL2[nI][nPosProd][2]  			,NIL })
		Aadd(aLinhaPed,{ "C6_DESCRI",	aSL2[nI][nPosDescri][2]			,NIL })
		Aadd(aLinhaPed,{ "C6_UM",		aSL2[nI][nPosUM][2]				,NIL })
		Aadd(aLinhaPed,{ "C6_QTDVEN",	aSL2[nI][nPosQtde][2]			,NIL })

		//#VFE
		If SuperGetMv("MV_LJVFE", Nil, .F.) .AND. SC5->(FieldPos("C5_FILVFE")) > 0
			If nPosFilRes > 0 .AND. nPosIsVFE > 0 .AND. aSL2[nI][nPosIsVFE][2]
				Aadd(aCabPed,{ "C5_FILVFE",	aSL2[nI][nPosFilRes][2]	,NIL })
			EndIf
		EndIf
    	//VFE#

		//Se tiver reserva sem estoque subtrai o valor
		//da solicitacao de compras da quantidade liberada
		lGerSolCom := .F.
	    If AllTrim(Str(SuperGetMv("MV_LJGERSC",,1))) $ "2|3" .AND. nPosSolCom > 0
	    	nQtdeSC := LC701QtdSC(aSL2[nI][nPosSolCom][2], aSL2[nI][nPosProd][2])
	    	Aadd(aLinhaPed,{ "C6_SOLCOM",	aSL2[nI][nPosSolCom][2]			,NIL })
		    lGerSolCom := .T.
	    EndIf

	    If SuperGetMv("MV_LJPVLIB", Nil, "1") == "1" //Gera Pedido de Venda com a Qtde. Liberada para faturar? (MV_LJPVLIB: 1=Sim; 2=Nao)
			Aadd(aLinhaPed,{ "C6_QTDLIB",	aSL2[nI][nPosQtde][2] - nQtdeSC 	,NIL })		
		Else
			//Mantenho o legado para continuar funcionando e peço atualização de fonte dependente dessa alteração senão SC6 fica errado
			If GetApoInfo("LOJA701E.PRW")[4] < Ctod("11/05/2018")
				LjGrvLog( Nil, " Atualize o fonte LOJA701E [Issue MVAR-6423] para que ocorra o ajuste na tabela SB2 ")
				Conout(" Atualize o fonte LOJA701E [Issue MVAR-6423] para que ocorra o ajuste na tabela SB2 ")
				Aadd(aLinhaPed,{ "C6_QTDRESE",	aSL2[nI][nPosQtde][2] - nQtdeSC 	,NIL })
			EndIf
		EndIf

		Aadd(aLinhaPed,{ "C6_PRCVEN",	aSL2[nI][nPosVrUnit][2]			,NIL })
		Aadd(aLinhaPed,{ "C6_VALOR",	aSL2[nI][nPosVlrItem][2]		,NIL })
		Aadd(aLinhaPed,{ "C6_TES",		cTes	 						,NIL })
		// CFOP retornada da funcao MaFisCfo
		Aadd(aLinhaPed,{ "C6_CF",		cCFOP			 				,NIL })
		Aadd(aLinhaPed,{ "C6_LOCAL",	aSL2[nI][nPosLocal][2]			,NIL })
		If lCentroDL
      		Aadd(aLinhaPed,{ "C6_CLI",	cLjCliente 						,NIL })
			Aadd(aLinhaPed,{ "C6_LOJA",	cLjLojCli 						,NIL })
		Else
      		Aadd(aLinhaPed,{ "C6_CLI",	aSL1[nPosCli][2] 				,NIL })
			Aadd(aLinhaPed,{ "C6_LOJA",	aSL1[nPosLoj][2] 				,NIL })
	    Endif
		Aadd(aLinhaPed,{ "C6_PRUNIT",	aSL2[nI][nPosPrcTab][2]			,NIL })		// Preco de tabela
		Aadd(aLinhaPed,{ "C6_TPOP",		cC6_TpOp						,NIL })
		Aadd(aLinhaPed,{ "C6_LOTECTL",	aSL2[nI][nPosLoteCTL][2]       ,NIL }) 	// Lote
		Aadd(aLinhaPed,{ "C6_NLOTE",	aSL2[nI][nPosLote][2]          ,NIL }) 	// SubLote
		
		If nPosDtVal > 0
			Aadd(aLinhaPed,{ "C6_DTVALID",	aSL2[nI][nPosDtVal][2]          ,NIL }) 	// Validade do lote
		EndIf
		
		If nPosNSerie > 0
			Aadd(aLinhaPed,{ "C6_NUMSERI",	aSL2[nI][nPosNSerie][2]          ,NIL }) 	// serie
		EndIf
		
		If nPosLocaliz > 0
			Aadd(aLinhaPed,{ "C6_LOCALIZ",	aSL2[nI][nPosLocaliz][2]          ,NIL }) 	// serie
		EndIf
		
		If SC6->(ColumnPos("C6_VDMOST")) > 0 .AND. nPosMostruario > 0
			Aadd(aLinhaPed,{ "C6_VDMOST",	aSL2[nI][nPosMostruario][2]		,NIL })
		EndIf
		
		If SC6->(ColumnPos("C6_VDOBS")) > 0 .AND. nPosObsMostr > 0
			Aadd(aLinhaPed,{ "C6_VDOBS",	aSL2[nI][nPosObsMostr][2]		,NIL })
		EndIf

		If nPosEntreg > 0
			Aadd(aLinhaPed,{ "C6_ENTREG",	aSL2[nI][nPosEntreg][2]		,NIL })
		EndIf
		If nPosTurno > 0 .AND. SC6->(ColumnPos("C6_TURNO")) > 0 .AND. LJAnalisaLeg(47)[1]
			Aadd(aLinhaPed,{ "C6_TURNO",	aSL2[nI][nPosTurno][2]		,NIL })
		EndIf

		If lC6ItemGar  .AND. nPosItemGar > 0
			Aadd(aLinhaPed,{ "C6_ITEMGAR",	aSL2[nI][nPosItemGar][2]		,NIL })
		EndIf

		If lC6OrcGar .AND. nPosOrcRes > 0 .AND. nPosItemGar > 0 .AND. !Empty(aSL2[nI][nPosItemGar][2])
			Aadd(aLinhaPed,{ "C6_ORCGAR",	aSL1[nPosOrcRes][2]		,NIL })
		EndIf

		If nPosFciCod > 0 .And. SC6->(ColumnPos("C6_FCICOD")) > 0
			Aadd(aLinhaPed,{ "C6_FCICOD",	aSL2[nI][nPosFciCod][2]		,NIL })
		EndIf

		If nPosVlImpor > 0 .And. SC6->(ColumnPos("C6_VLIMPOR")) > 0
			Aadd(aLinhaPed,{ "C6_VLIMPOR",	aSL2[nI][nPosVlImpor][2]	,NIL })
		EndIf

		If (aSL2[nI][nPosTes][2] == cTes) .And. (nPosClasFis > 0 .And. !Empty(aSL2[nI][nPosClasFis][2]))
			cClasFis := aSL2[nI][nPosClasFis][2]
		Else
			cClasFis := CodSitTri()
		EndIf
		// Pega sit Trib igual ao faturamento
		Aadd(aLinhaPed,{ "C6_CLASFIS",	cClasFis						,NIL })

		//Campos referente a lista de presente
		If lC6CodLP .And. nPosCodLis > 0
			Aadd(aLinhaPed,{ "C6_CODLPRE", aSL2[nI][nPosCodLis][2]		,NIL })
		EndIf

		If lC6ITLtP .And. nPosItLtPre > 0
			Aadd(aLinhaPed,{ "C6_ITLPRE", aSL2[nI][nPosItLtPre][2]		,NIL })
		EndIf

		If lCFolLocR5 .AND. cPaisLoc == "CHI"
			//Release 11.5 - Chile - Guia de Despacho - F2CHI
			//Quando o produto pertence a um pedido de venda e sera incluido futuramente em uma 
			//Guia de Despacho, atualizar o campo C6_GERANF='N' para que nao esteja disponivel 
			//para geracao de Factura atraves da rotina MATA468N (SIGAFAT).
			Aadd(aLinhaPed,{ "C6_GERANF", "N"		,NIL })
		EndIf

		If (lECommerce .AND. lMvLjIPEn)
        	nPrecoTab := 0
        	nIPIDesc := 0
        	LjxeValPre(@nPrecoTab, 	aSL2[nI][nPosProd][2], aSL1[nPosCli][2], aSL1[nPosLoj][2],;
					nMoedaCor   , aSL2[nI][nPosQtde][2] , , @nIPIDesc,;
					.T. )
			nIPIDesc  :=  ( nIPIDesc *  aSL2[nI][nPosQtde][2])
			//Somente calcula o valor do IPI se não houve alteração na tabela de preço
 			If lMVLjDtIPI
 				//define se a diferença entre o IPI embutido e o calculado será lançado como desconto no total da NF
				If nIPIDesc > 0 .and. (aSL2[nI][nPosPrcTab][2] == nPrecoTab)
					nTotIPIEn += nIPIDesc
				Else
					nIPIDesc := Lj701CIPI(	aSL2[nI][nPosProd][2], aSL2[nI][nPosPrcTab][2], lMVRNDIPI, cMV_LJTESPE, nCasasIPI)
					nIPIDesc   := ( nIPIDesc *  aSL2[nI][nPosQtde][2])
					nTotIPIEn += nIPIDesc
				EndIf
			EndIf
		EndIf

		 //Gera Pedido de Venda com a Qtde. Liberada para faturar? (MV_LJPVLIB: 1=Sim; 2=Nao)
		If SuperGetMv("MV_LJPVLIB", Nil, "1") == "1"
			//Faz o cancelamento da reserva, pois os produtos
			//serao reservados pela liberacao do Pedido de Vendas.
			aReserva := {{	aSL2[nI][nPosReserv][2],;		// Numero da Reserva
							aSL1[nPosLoj][2] ,;				// Codigo da Loja
							aSL2[nI][nPosProd][2],;		// Codigo do Produto
							aSL2[nI][nPosLocal][2],;		// Local (Armazem)
							cFilEnt ,;						// Filial da Reserva
							StrZero(nI, nTamC6It)}}

			aRetRes		:= Lj7CancRes(aReserva, lJob)
			lRet		:= aRetRes[1][2]					// O tamanho do Array de retorno e' fixo
		Else
		 	//Neste caso, nao exclui a Reserva da SC0, pois o pedido foi incluido com o item nao liberado (C6_QTDLIB = 0)
		   	Aadd(aLinhaPed,{ "C6_RESERVA",	aSL2[nI][nPosReserv][2] ,NIL })     // Relaciona o codigo da reserva da SC0
		EndIf

		If !lRet
			If !lJob
				Aviso(STR0031, STR0103, {STR0005}, 2)	// "Atenção"###"Não foi possível efetuar o estorno da Reserva. O Pedido de Venda não será gerado."###"Ok"
				Exit
			Else
				Conout(STR0103)							// "Não foi possível efetuar o estorno da Reserva. O Pedido de Venda não será gerado."
				Exit
			EndIf
		EndIf

		Aadd(aItensPed, aLinhaPed)

		If lECommerce .AND. !( lPosAux )

			//Busca de Posição de TES para substituir pelo TES que não movimenta estoque
			//Busca de Posição da Opeação, para substituir por Simples Remessa
			//Busca de Posição do Codigo Fiscal (CFOP), Setando como Simples Remessa
			Aadd(aPosAux, Ascan(aLinhaPed, {|x| Alltrim(x[1]) == "C6_TES"	}))
			Aadd(aPosAux, Ascan(aLinhaPed, {|x| Alltrim(x[1]) == "C6_CF"	}))
			lPosAux := .T.
       EndIf

		//Verificar se vai fazer o processo novo para MG ou não
		IF LjChkNFS(aSL2)
			aadd( aAx2Itens, aClone(aLinhaPed) )

			IF (nPosAux := Ascan(aLinhaPed, {|x| Alltrim(Upper(x[1])) == "C6_TES"	})) > 0
				aAx2Itens[len(aAx2Itens)][nPosAux][2] := cTesEnt
			Endif
			aSF4Ord := SF4->(GetArea())

			SF4->(DbSetOrder(1))
			SF4->(DbSeek(xFilial("SF4") + cTesEnt))

			If (nPosAux := Ascan(aLinhaPed, {|x| Alltrim(Upper(x[1])) == "C6_CF" })) > 0
				cCFOPEnt := MaFisCfo(,SF4->F4_CF,aDadosCfo)

				If Empty(cCFOPEnt)
					cCFOPEnt := SF4->F4_CF
				EndIf

				aAx2Itens[len(aAx2Itens)][nPosAux][2] := cCFOPEnt

			EndIf

			If (nPosAux := Ascan(aLinhaPed, {|x| Alltrim(Upper(x[1])) == "C6_CLASFIS" })) > 0
				If Empty(aAx2Itens[len(aAx2Itens)][nPosAux][2])
					aAx2Itens[len(aAx2Itens)][nPosAux][2] := CodSitTri()
				EndIf
			EndIf

			RestArea(aSF4Ord)

			nECVezes := 2
		Endif

		//Substitui os valores das posiçoes para gerar o Pedido de Presente
        If  lECommerce .AND. lPosAux .AND. (nPosECPresn > 0) .AND. (aSL2[nI][nPosECPresn][2] == "1")
		    aAxlItens:= aClone(aLinhaPed)
			Aadd(aItPedPres,aAxlItens)

			ATail(aItPedPres)[aPosAux[1]][2]	:=  cTESPRESN
        	ATail(aItPedPres)[aPosAux[2]][2]	:=  cCFOPPRES

			nECVezes := 2
		EndIf

		aLinhaPed := {}
		If lECommerce .AND. lMvLjIPEn .AND. lMVLjDtIPI
			If !lFtvdVer12
				If MaFisFound("NF")
					MaFisAdd( aSL2[nI][nPosProd][2],;	// Produto
							  cTes   ,;	// Tes
							  aSL2[nI][nPosQtde][2] ,;	// Quantidade
							  aSL2[nI][nPosPrcTab][2],;	// Preco unitario
							  0,;	// Valor do desconto
							  "",; 						// Numero da NF original
							  "",; 						// Serie da NF original
							   0,;						// Recno da NF original
							   0,; 						// Valor do frete do item
							   0,; 						// Valor da despesa do item
							   0,; 						// Valor do seguro do item
							   0,; 						// Valor do frete autonomo
							   ( aSL2[nI][nPosPrcTab][2] *  aSL2[nI][nPosQtde][2] ) ,;        // Valor da mercadoria
							   0 )						// Valor da embalagem
					MaFisRecal("",nI)

				EndIf

		   ElseIf lFtvdVer12

				If MaFisFound("NF")
					SB1->(DbSetOrder(1))
					SB1->(DbSeek(xFilial("SB1")+aSL2[nI][nPosProd][2]))

					SF4->(DbSetOrder(1))
					SF4->(DbSeek(xFilial("SF4")+cTes))

					MaFisIniLoad(nI, ;
								{aSL2[nI][nPosProd][2],;	//IT_PRODUTO
								cTes,; 		//IT_TES
								Alltrim(MaSBCampo("CODISS")),; 	//IT_CODISS
								aSL2[nI][nPosQtde][2],;		//IT_QUANT
								"",; 				//IT_NFORI
								"",; 				//IT_SERIORI
								SB1->(RecNo()),;	//IT_RECNOSB1
								SF4->(RecNo()),;	//IT_RECNOSF4
								0  }) 				//IT_RECORI

					MaFisLoad("IT_VALMERC"	,(  aSL2[nI][nPosPrcTab][2] *  aSL2[nI][nPosQtde][2] ) ,nI)
					MaFisLoad("IT_PRCUNI"	, aSL2[nI][nPosPrcTab][2],nI)
					MaFisLoad("IT_DESCONTO"	,0,nI)
					MaFisLoad("IT_FRETE"	,0,nI)
					MaFisLoad("IT_SEGURO"	,0,nI)
					MaFisLoad("IT_DESPESA"	,0,nI)

					MaFisRecal("",nI)

					MaFisEndLoad(nI,2)
				EndIf

			EndIf
		EndIf

		// adicionamos o contador do pedido para obter a linha exata a ser alterada no ponto de entrada LJ7046
		If lLJ7046
			aAdd( aSL2[nI], {"CONTADOR_PED", nI} )
		EndIf

	Next nI
EndIf

//define se a diferença entre o IPI embutido e o calculado será lançado como desconto no total da NF
If  lECommerce .AND. lMvLjIPEn .AND. lMVLjDtIPI .AND. nTotIPIEn > 0
	For nI := 1 to nItens
		nTotIPI += MaFisRet(nI,"IT_VALIPI")
	Next nI

	If (nTotIPI > nTotIPIEn)
		nTotIPI := Max(nTotIPI - nTotIPIEn , 0)

		If lMVRNDIPI
			nTotIPI := Round(nTotIPI,nCasasIPI)     //Trabalha com arredondamento
		Else
			nTotIPI := NoRound(nTotIPI,nCasasIPI)   //Trabalha com truncamento
		EndIf

		If nTotIPI > 0  .and. (  (nCpo := aSCan( aCabPed, { |c| c[1] ==  "C5_DESCONT" } ) )  > 0)
			aCabPed[nCpo][2] := aCabPed[nCpo][2] + nTotIPI
		EndIf
	EndIf

EndIf

If lRet
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de Entrada que podera ser utilizado, para incluir outros³
	//³campos na gravacao do Pedido de Venda.                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lLJ7046 .AND. !lFtvdVer12
		aRet := ExecBlock("LJ7046", .F., .F., {cFilBkp , aSL1 , aSL2 })
		If ValType(aRet[1]) == "A" .And. Len(aRet[1]) > 0
			aCab7046	:= aClone(aRet[1])
			For nI := 1 to Len(aCab7046)
				Aadd(aCabPed, aCab7046[nI])
			Next nI
		EndIf

		If ValType(aRet[2]) == "A" .And. Len(aRet[2]) > 0
			aItens7046	:= aClone(aRet[2])	//retornou uma quantidade de itens superior em relacao a aItensPed
			For nI := 1 to Len(aItens7046)
				// procura pelo campo CONTADOR_PEDIDO no retorno do PE
				nAux := aScan( aItens7046[nI], {|x| x[1] == "CONTADOR_PED"} )
				If nAux > 0	// obtem o valor do campo CONTADOR_PED no retorno do PE
					nAux := aItens7046[nI][nAux][2]
				Else		//senao mantem o legado
					nAux := nI
				EndIf

				For nCpo := 1 to Len(aItens7046[nI])
					Aadd( aItensPed[nAux], aItens7046[nI][nCpo] )
					If lECommerce .AND. (nI <= Len(aItPedPres))
						Aadd( aItPedPres[nAux], aItens7046[nI][nCpo] )
					EndIf
				Next
			Next
		EndIf
		
		// apagamos o ultimo campo que foi criado para proteger o retorno do P.E.
		For nI := 1 to Len(aSL2)
			aSize( aSL2[nI], Len(aSL2[nI])-1 )
		Next
	EndIf

	If lFTVD7046 .AND. lFtvdVer12
		aRet := ExecBlock("FTVD7046", .F., .F., {cFilBkp})
		If ValType(aRet[1]) == "A" .And. Len(aRet[1]) > 0
			aCab7046	:= aClone(aRet[1])
			For nI := 1 to Len(aCab7046)
				Aadd(aCabPed, aCab7046[nI])
			Next nI
		EndIf

		If ValType(aRet[2]) == "A" .And. Len(aRet[2]) > 0
			aItens7046	:= aClone(aRet[2])
			For nI := 1 to Len(aItens7046)
				For nCpo := 1 to Len(aItens7046[nI])
					Aadd(aItensPed[nI], aItens7046[nI][nCpo])
					If lECommerce .AND. (nI <= Len(aItPedPres))
						Aadd(aItPedPres[nI],aItens7046[nI][nCpo])
					EndIf
				Next nCpo
			Next nI
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Foi substituido a execução da EXECAUTO pela gravação manual do Pedido de Venda.               ³
	//³O Motivo foi performance, pois em pedidos com mais de 50 Ítem a demora na execução da Execauto³
	//³inviabiliza o processo, pois fica muito lento.                                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aAxlItens := {}
	aBkpSl1	:= aClone(aSl1)
	For nCont := 1 to nECVezes

		aSl1 := aClone( aBkpSl1 )

		If  (nCont > 1)
			IF LjChkNFS(aSL2)
				aAxlItens	:= aClone(aItensPed)
				nPosAux := Ascan(aCabPed, {|x| Alltrim(Upper(x[1])) == "C5_ORCRES" })
				if nPosAux > 0
					aCabPed[nPosAux][2] := cOrcFilho
				Endif
			Else
				aAxlItens	:= aClone(aItPedPres)

				aCabPed[nPosECMEN][2]	:= cManPad
				aCabPed[nPosECPedS][2]	:= "1"
			Endif
		Else
			IF LjChkNFS(aSL2)
				aAxlItens	:= aClone(aAx2Itens)
				nPosAux := Ascan(aCabPed, {|x| Alltrim(Upper(x[1])) == "C5_ORCRES" })
				if nPosAux > 0
					aCabPed[nPosAux][2] := cOrcPai
				Endif
			Else

				aAxlItens	:= aClone(aItensPed)

				If  (nECVezes == 2) .AND. (nPosECMEN > 0)
					aCabPed[nPosECMEN][2]	:= cManPad
				EndIF
			Endif
		EndIF

		DbSelectArea("SC5")
		SC5->(DbSetOrder(1)) //Filial + Pedido
		cNumSC5 := CRIAVAR("C5_NUM")

		LjGrvLog(cNumPai,"Retorno de numeracao do SC5 - Empresa/Filial: " + cEmpAnt+"/"+cFilAnt ,cNumSC5)

		cMay := "SC5"+ALLTRIM(xFilial("SC5"))+cNumSC5
		FreeUsedCode()
		While SC5->(DbSeek(xFilial("SC5")+cNumSC5)) .OR. !MayIUseCode(cMay)
			If ++nTent > 20
				FreeUsedCode()
			EndIf
			If nTent > 50 //Se nao conseguir ate 50 vezes, aborta o sistema.
				FreeUsedCode()
				Final("Impossivel gerar numero sequencial de PEDIDO correto. INFORME ESSA MENSAGEM PARA O DEPARTAMENTO DE TI.")
			EndIf
			cNumSC5 := CRIAVAR("C5_NUM")
			cMay := "SC5"+ALLTRIM(xFilial("SC5"))+cNumSC5
			LjGrvLog(cNumPai,"Tentou buscar outra numeracao - Empresa/Filial: " + cEmpAnt+"/"+cFilAnt,cNumSC5)
		End
		If __lSX8
			While (GetSX8Len() > nSaveSx8)
				ConfirmSx8()
			End
		Endif

		If Len(aCabPed) > 0
			RecLock("SC5",.T.)
			SC5->C5_NUM		:=	cNumSC5
			For nI := 1 to len(aCabPed)
		 		SC5->&(aCabPed[nI][1])	:= aCabPed[nI][2]
		   	Next nI
		Endif
		FkCommit() // Commit para integridade referencial do SC5
		FreeUsedCode()

		LjGrvLog(cNumPai,"Incluiu o registro no SC5")

		// Grava o número da Solicitação de Compra no Pedido de Venda
		If lGerSolCom
			For nI := 1 to nItens
				nPosC6SolCom	:= Ascan(aItensPed[nI], {|x| AllTrim(x[1]) == "C6_SOLCOM"	})
				If !Empty(aItensPed[nI][nPosC6SolCom][2])
					DbSelectArea("SC1")
					DbSetOrder(1) // Filial+Numero da SC
					// Procura a solicitação de compras
					If DbSeek(xFilial("SC1")+aItensPed[nI][nPosC6SolCom][2])
						// Depois de posicionado, altero a Solicitação de compra com o numero do pedido (C5_Num)
						While ( !Eof() .AND. xFilial("SC1")+aItensPed[nI][nPosC6SolCom][2] == SC1->C1_FILIAL + SC1->C1_NUM )
							RecLock("SC1", .F.)
							REPLACE SC1->C1_PEDRES WITH SC5->C5_NUM
							MsUnlock()
							SC1->(DbSkip())
						EndDo
					EndIf
				Endif
			Next nI
		EndIf
		
		If Len(aAxlItens) > 0
			For nI := 1 to Len(aAxlItens)
				RecLock("SC6",.T.)
				SC6->C6_NUM		:=	cNumSC5
				For nY := 1 to Len(aAxlItens[nI])
					nAux := ColumnPos(aAxlItens[nI][nY][1])
					If  nAux > 0 
						SC6->( FieldPut(nAux, aAxlItens[nI][nY][2]) )
					EndIf
		 		Next nY
		 		SC6->(MsUnlock())
			   	FkCommit() // Commit para integridade referencial do SC6
			   	
			   	nAux := 0
			   	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Quando a função e executa direto pelo Lj7Pedido ele não tem o foco no sc6, precisando passar  ³
				//³o reclock antes de executar a função MaAvalSC6                                                ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			   	
			   	If !SC6->(EOF()) .AND. RecLock("SC6")
					MaAvalSC6("SC6",1,"SC5",lLiber,lTransf,@lLiberOk,@lResidOk,@lFaturOk,nil,nil,nil,nil,nil,lTLVReg,lAvCred)
		 			SC6->(MsUnlock())
		 			
		 			If SC6->C6_QTDLIB > 0
		 				lLiberou := .T. 
		 			EndIf
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³PE para atualizar os dados dos itens da geracao do Pedido.³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lLJ7065
					LjGrvLog( cNumSC5 , " Antes da Execução do PE LJ7065")
					ExecBlock("LJ7065",.F.,.F., { nI } )
					LjGrvLog( cNumSC5 , " Antes da Execução do PE LJ7065")
				EndIf
		   	Next nI
		Endif

		LjGrvLog(cNumPai,"Passou da validação dos itens na SC6")
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Parametros³ExpC1: Alias da tabela dos itens do Pedido de Venda         ³
		³          ³ExpN2: Codigo do Evento                                     ³
		³          ³       [1] Implantacao do Pedido de Venda                   ³
		³          ³       [2] Estorno  do Pedido de Venda                      ³
		³          ³       [3] Liberacao do Pedido de Venda                     ³
		³          ³       [4] Estorno da Liberacao do Pedido de Venda          ³
		³          ³       [5] Preparacao da Nota Fiscal de Saida               ³
		³          ³       [6] Estorno da Nota Fiscal de Saida                  ³
		³          ³ExpC3: Alias do SC5                                         ³
		³          ³ExpL4: Liberacao Parcial                                    ³
		³          ³ExpL5: Transfere Locais                                     ³
		³          ³ExpL6: Verifica se todos os itens foram liberados           ³
		³          ³ExpL7: Verifica os residuos do pedido de venda              ³
		³          ³ExpL8: Verifica se todos os itens foram faturados           ³
		³          ³ExpL9: Atualiza somente os acumulados                       ³
		³          ³ExpNA: Valor a ser adicionado ao limite de credito          ³
		³          ³ExpCB: Alias do SD2 ( Uso Interno para otimizacao )         ³
		³          ³ExpLC: Indica se esta o SC6 esta sendo baixado por un REMITO³
		ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		*/
		If ( cC5_TipLib=="2" .And. (lLiberou .Or. MaTesSel(SC6->C6_TES)) )
			MaAvalSC5("SC5",3,lLiber,lTransf,@lLiberOk,@lResidOk,@lFaturOk)
		EndIf

		MaAvalSC5("SC5",1,lLiber,lTransf,@lLiberOk,@lResidOk,@lFaturOk)
		SC5->(MsUnlock())

		LjGrvLog(cNumPai,"Finalizou a geracao do pedido na SC5")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³PE para atualizar os dados na finalizacao do pedido,subistitui M410STTS ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lLJ7066
			LjGrvLog( cNumSC5 , " Antes da Execução do PE LJ7066")
			ExecBlock("LJ7066",.F.,.F.)
			LjGrvLog( cNumSC5 , " Depois da Execução do PE LJ7066")
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³VerIfica se houveram erros durante a geracao do Pedido.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMsErroAuto
			lRet := !lMsErroAuto
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua a gravacao do Numero do ³
			//³Pedido no Orcamento Filho.     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cPedido   := SC5->C5_NUM
			If nCont == 1			 // Ecomerce sempre vai ter mais de 1
				cPedPai   := cPedido // O primeiro sempre eh o pedido PAI
			Else
				cPedFilho := cPedido // O segundo é o pedido presente e devera ser vinculado
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ajusta as datas da geracao do pedido com a funcao Date(), isso 	   ³
			//³ porque a variavel dDatabase guarda a data em que foi iniciado o JOB³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lJob
				DbSelectArea("SC6")
				DbSetOrder(1)
				If DbSeek(xFilial("SC6")+cPedido)    // Filial + Numero do Pedido
					While ( !Eof() .AND. xFilial("SC6")+cPedido == SC6->C6_FILIAL + SC6->C6_NUM )
						RecLock("SC6",.F.)
						REPLACE C6_SUGENTR WITH Date()
						MsUnlock()

						DbSelectArea("SC9")			// Ajusta tambem a tabela de liberacao
						DbSetOrder(1)				// Filial + Numero do Pedido + Item
						If DbSeek(xFilial("SC9")+SC6->C6_NUM+SC6->C6_ITEM)
							While ( !Eof() .AND. SC9->C9_FILIAL == xFilial("SC9") .AND.;
												 SC9->C9_PEDIDO == SC6->C6_NUM 	  .AND.;
									  			 SC9->C9_ITEM   == SC6->C6_ITEM )
								RecLock("SC9",.F.)
								REPLACE C9_DATALIB WITH Date()
								MsUnlock()

								SC9->(DbSkip())
							End
						EndIf

						SC6->(DbSkip())
					End
				EndIf
			EndIf

			//Tratamento para atualizar o ME4 quando lista de presente.
			//Obs.: Este tratamento é necessário para gerar corretamente o faturamento do pedido
			//Não se reaproveitou o loop do sl2 pois em caso de venda futura (nota de simples faturamento)
			//a nota é faturada na função 'FEmiteNF' e neste momento o ME4 ja deve estar preenchido corretamente.
			If lLstPre .And. lLj8GrvPed .And. lPosL2ITESC6 .And. nPosCodLis > 0
				Lj8GrvPed(aSL2, cNumPai, cOrcFilho, cPedido )
			EndIf

			IF LjChkNFS(aSL2) .and. nCont == 1	//Função que verifica se deve habilitar ou nao o novo processo
				aSL1Tmp	:= SL1->( GetArea() )
				aAreaTmp:= GetArea()

            	aDadosNf:= FEmiteNF(aSL1[nPosCli][2],aSL1[nPosLoj][2], cPedido)		//Vai chamar a função que fatura o pedido

				DbSelectArea("SL1")
				DbSetOrder(1)
				If dbSeek( xFilial("SL1") + cOrcPai )
					RecLock("SL1", .F. )
					SL1->L1_DOCPED := aDadosNf[1]
					SL1->L1_SERPED := aDadosNf[2]
					SL1->L1_DOC    := ""
					SL1->L1_SERIE  := ""
					MsUnlock()
				Endif

				RestArea(aSL1Tmp)
				RestArea(aAreaTmp)
				aSL1Tmp := {}
				aAreaTmp := {}
			Endif
			
			DbSelectArea("SL1")
			DbSetOrder(1)	//Filial + Numero
			If  DbSeek(xFilial("SL1") + cOrcFilho)

			    If (nCont > 1) .And. SC5->(ColumnPos("C5_ECVINCU") > 0)
					Aadd(aSL1Tmp, { "L1_PEDPRS", cPedido })
					//Efetua a gravação no Ped. Presente vinculando com o pedido PAI
					SC5->( RecLock("SC5",.F.) )
					SC5->C5_ECVINCU := cPedPai
					SC5->( MsUnlock() )

				 	DbSelectArea("SC5")
					DbSetOrder(1)	//Filial + Pedido
					//Efetua a gravação no Ped.Pai , granvando o numero do filho
					If SC5->(DbSeek(xFilial("SC5")+cPedPai))
						SC5->( RecLock("SC5",.F.) )
						SC5->C5_ECVINCU := cPedFilho
						SC5->( MsUnlock() )
					EndIf
				Else
					Aadd(aSL1Tmp, { "L1_PEDRES", cPedido })
                EndIf

				Lj7GeraSL( "SL1", aSL1Tmp )

				DbSelectArea("SL2")
				DbSetOrder(1)	//Filial + Numero + Item
				For nI := 1 to Len(aSL2)
					aSL2Tmp := {}
					nPosItem	:= Ascan(aSL2[nI], {|x| AllTrim(x[1]) == "L2_ITEM"	})
					If DbSeek(xFilial("SL2") + cOrcFilho + aSL2[nI][nPosItem][2])
						Aadd(aSL2Tmp, { "L2_PEDRES", cPedido })
						Aadd(aSL2Tmp, { "L2_FILRES", cFilRes })
						Lj7GeraSL( "SL2", aSL2Tmp )
					EndIf
				Next nI
			EndIf
		EndIf

	Next nCont
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Restaura a Filial de Origem.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cFilAnt := cFilBkp
If nRecSM0Bkp > 0
	//Reposiciona corretamente na SM0
	SM0->(DbGoTo(nRecSM0Bkp))
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Retorno da Funcao.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aRet := { lRet, cOrcFilho }
LjGrvLog(cNumPai,"Retorno da geracao do SC5",aRet)

Return aRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LJ7aAuxPgtos ºAutor  ³Vendas Clientes     º Data ³  14/04/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Preenchimento do array aAuxaPgtos que sera' utilizado quando  º±±
±±º          ³ a funcao LJ7Pedido() for acionada atraves do JOB de integracaoº±±
±±º          ³ ERP                                                        	 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ LJGRVBATCH              		                                 º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LJ7aAuxPgtos(aAuxaPgtos)
Local nLinha 	:= 0		//	Numero de parcelas
Local aAuxiliar := {}		//	Array auxiliar que armazena informacoes de pagamento

aAuxaPgtos := {}

DbSelectArea("SL4")
DbSetOrder(1)
DbSeek( xFilial("SL4") + SL1->L1_NUM)
While SL4->(!Eof()) .AND. SL4->L4_FILIAL + SL4->L4_NUM == xFilial("SL4") + SL1->L1_NUM
	nLinha++
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Dinheiro						  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If IsMoney(SL4->L4_FORMA)
		aAdd( aAuxaPgtos, {	SL4->L4_DATA							,;	//01 Data do orcamento
							SL4->L4_VALOR							,;	//02 Valor
							SL4->L4_FORMA							,;	//03 Forma de pagamento
							{}										,;	//04 Array de parcelas
							NIL										,;	//05 Data base
							IIf(cPaisLoc<>"BRA",SL4->L4_MOEDA,NIL)	,;	//06 Moeda
			               	IIf(cPaisLoc<>"BRA",SL4->L4_DATA,NIL)	,;	//07 Data
			               	If(If(SL4->(FieldPos("L4_FORMAID"))>0,.T.,.F.),SL4->L4_FORMAID,Space(01))} )	//08 FormID
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cheque						  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ElseIf AllTrim(SL4->L4_FORMA) == AllTrim(MVCHEQUE)
		aAdd( aAuxaPgtos, {	SL4->L4_DATA							,;	//01 Data do orcamento
							SL4->L4_VALOR							,;	//02 Valor
							SL4->L4_FORMA							,;	//03 Forma de pagamento
							{}										,;	//04 Array de parcelas
							NIL										,;	//05 Data base
							IIf(cPaisLoc<>"BRA",SL4->L4_MOEDA,NIL)	,;	//06 Moeda
			               	IIf(cPaisLoc<>"BRA",SL4->L4_DATA,NIL)	,;	//07 Data
			               	If(If(SL4->(FieldPos("L4_FORMAID"))>0,.T.,.F.),SL4->L4_FORMAID,Space(01))} )	//08 FormID

		aAuxiliar := Array(14)
		aAuxiliar[1]  := SL4->L4_VALOR
		aAuxiliar[2]  := SL4->L4_DATA
		aAuxiliar[3]  := "01"
		aAuxiliar[4]  := SL4->L4_ADMINIS
		aAuxiliar[5]  := SL4->L4_AGENCIA
		aAuxiliar[6]  := SL4->L4_CONTA
		aAuxiliar[7]  := SL4->L4_NUMCART
		aAuxiliar[8]  := SL4->L4_COMP
		aAuxiliar[9]  := SL4->L4_RG
		aAuxiliar[10] := SL4->L4_TELEFON
		aAuxiliar[11] := .T.
		aAuxiliar[12] := .F.
		aAuxiliar[13] := SuperGetMV("MV_SIMB1")
		aAuxiliar[14] := ""

		aAuxaPgtos[nLinha][4] := aClone(aAuxiliar)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cartao de credito/debito/outros	   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Else
		aAdd( aAuxaPgtos, {	SL4->L4_DATA							,;	//01 Data do orcamento
							SL4->L4_VALOR							,;	//02 Valor
							SL4->L4_FORMA							,;	//03 Forma de pagamento
							{}										,;	//04 Array de parcelas
							NIL										,;	//05 Data base
							IIf(cPaisLoc<>"BRA",SL4->L4_MOEDA,NIL)	,;	//06 Moeda
			               	IIf(cPaisLoc<>"BRA",SL4->L4_DATA,NIL)	,;	//07 Data
			               	If(If(SL4->(FieldPos("L4_FORMAID"))>0,.T.,.F.),SL4->L4_FORMAID,Space(01))} )	//08 FormID

		aAuxiliar := Array(7)
		aAuxiliar[1]  := SL4->L4_VALOR
		aAuxiliar[2]  := SL4->L4_DATA
		aAuxiliar[3]  := "01"
		aAuxiliar[4]  := ""
		aAuxiliar[5]  := SL4->L4_ADMINIS
		aAuxiliar[6]  := .T.
		aAuxiliar[7]  := ""

		aAuxaPgtos[nLinha][4] := aClone(aAuxiliar)

	EndIf
	SL4->(DbSkip())
End

If Len(aAuxaPgtos) == 0
	AAdd( aAuxaPgtos, { Ctod("  /  /  "), 0 , "" , "", "", "", "", "", "", .F., 1, Space(04), 0 })
EndIf
Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LOJA701   ºAutor  ³Vendas Clientes     º Data ³  29/04/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função que retorna o Valor do Subtotal para controle do sub-º±±
±±º          ³total quando ocorre erro ou cancela a operacao TEF 		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7GetSubTot()
Local nRet  := nValSubTot

Return (nRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LOJA701   ºAutor  ³Vendas Clientes     º Data ³  29/04/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função que altera o Valor do Subtotal para controle do sub- º±±
±±º          ³total quando ocorre erro ou cancela a operacao TEF 		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7SetSubTot(nValor)

nValSubTot  := nValor

Return NIL

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³Lj7SetLog   ³ Autor³ Vendas Clientes       ³ Data³04/09/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Retorna o Diretorio do arquivo do Log_Tef                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ SIGAFRT                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj7GetLog()
Local cLogTef 	:= ""        	// Retorna o patch do arquivo log
Local lAutoExC	:= IsBlind()	// Verifica se a rotina sera executada via execauto ou nao

If !lAutoExC
	If cGetCliDir == NIL
		cGetCliDir := GetClientDir()
	EndIf
	If cProfStr1 == NIL
	    cProfStr1 := GetPvProfString("Logs TEF","Habilita","01",cGetCliDir + "SIGALOJA.INI")
	EndIF
	If File(cGetCliDir + "SIGALOJA.INI") .AND. cProfStr1 == "01"
		cLogTef := "\AUTOCOM\TEF"+cEmpAnt+cFilAnt+"\"
	Else
		cLogTef := ""
	EndIf
Endif

Return(cLogTef)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7LimpTefºAutor  ³Vendas Clientes     º Data ³  09/30/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que apaga os registros referente a TEF das tabelas   º±±
±±º          ³SL1 e SL4 caso tenha erro na transacao.                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7LimpTef()

Local aSl1 := {}	//Array com campos "" para gravacao no arquivo SL1
Local aSl4 := {}	//Array com campos "" para gravacao no arquivo SL4

AADD(aSl1, {"L1_VENDTEF", ""})
AADD(aSl1, {"L1_DATATEF", ""})
AADD(aSl1, {"L1_HORATEF", ""})
AADD(aSl1, {"L1_DOCTEF", ""})
AADD(aSl1, {"L1_AUTORIZ", ""})
AADD(aSl1, {"L1_NSUTEF", ""})
Lj7GeraSL( "SL1", aSL1, .F., .F. )	//Grava Arquivo SL1

AADD(aSl4, {"L4_VENDTEF", ""})
AADD(aSl4, {"L4_DATATEF", ""})
AADD(aSl4, {"L4_HORATEF", ""})
AADD(aSl4, {"L4_DOCTEF", ""})
AADD(aSl4, {"L4_AUTORIZ", ""})
AADD(aSl4, {"L4_NSUTEF", ""})
AADD(aSl4, {"L4_PARCTEF", ""})

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Grava Arquivo SL4.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

DbSelectArea( "SL4" )
DbSetOrder( 1 )
DbSeek( xFilial( "SL4" ) + SL1->L1_NUM )
While !EOF() .AND. SL4->L4_FILIAL + SL4->L4_NUM == xFilial( "SL4" ) + SL1->L1_NUM
	Lj7GeraSL( "SL4", aSL4, .F. )
	DbSkip()
End

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7PegCupArgºAutor  ³Vendas Clientes     º Data ³  13/01/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Pega o numero do cupom ou fatura da impressora			    º±±
±±º			 ³(Localizaçoes Argentina)    								    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³cRetorno - space com tamanho que o numero do cupom tem que terº±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³nRet - controle da funcao										º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Sigaloja                                                    	º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7PegCupArg(nHdlECF, cRetorno)

Local cSerie   := ""   //serie dependendo do cliente
Local nRet     := 1    //retorno da funcao IFPegCupom

cSerie := Lj7SerArg()

nRet := IFPegCupom( nHdlECF, @cRetorno, "D|"+AllTrim(cSerie))

Return(nRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7ImpNf    ºAutor  ³Vendas Clientes     º Data ³  23/07/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida se pode emitir nota fiscal             			    º±±
±±º			 ³(Localizaçoes Argentina)    								    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Sigaloja                                                    	º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Lj7ImpNf(lImpNfArg)
Local lRet			:= .F.
Local lLibEmiteNF	:= .F.
Local lPvAutNf		:= .F.
Local lEmisNF		:= .F.

If SLG->(FieldPos("LG_PVAUTNF")) > 0
	lPvAutNf := LjGetStation("LG_PVAUTNF")
EndIf

If lPvAutNf
	lEmisNF	:= LjEmiteNF(SM0->M0_CGC,@lLibEmiteNF)
EndIf

If cPaisLoc == "ARG" .AND. !lFiscal .AND. lEmisNF .AND. lPvAutNf
	lRet := .T.
EndIf

lImpNfArg  := lRet

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7CriaEntrMontºAutor³ Vendas CRM        º Data ³  18/10/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Planeja a entrega e montagem dos produtos informado.         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ aItens: Array de tamanho n, sendo:                           º±±
±±º          ³          aItens[n]: O número do item na venda.               º±±
±±º          ³ cNumPai: Número do orçamento pai da venda.                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ Se a OS foi criada ou não.                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGALOJA                                                    	º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Lj7CriaEntrMont( aItens, cNumPai )
	Local cOcorMontagem	:= GetNewPar( "MV_TECOCOM", "" )
	Local cOcorEntrega	:= GetNewPar( "MV_TECOCOA", "" )
	Local cCondPag		:= SuperGetMV( "MV_CONDPAD",, "" )
	Local lLJ7056		:= ExistBlock("LJ7056")							// Ponto de entrada executado logo após a criação da ordem de serviço. Inicialmente criado para que o cliente possa agendar ou controlar o agendamento da ordem de serviço logo após a criação da mesma
	Local lLJ7059		:= ExistBlock("LJ7059")							// Se existe o PE LJ7059. Esse ponto de entrada tem como objetivo permitir que o cliente crie número de série para cada produto informado, possibilitando assim a criação da OS.
	Local lRetorno		:= .T.
	Local cNumOs		:= ""
	Local aOSInfo		:= {}
	Local cErro			:= ""
	Local nRegs       	:= 1
	Local lMultiplos  	:= .F.
	Local nI          	:= 0
	Local nCount		:= 0
	Local aNrsSerie		:= {}
	Local aAreaSB1		:= {}
	Local lFTVD7056		:= ExistBlock("FTVD7056")							// Ponto de entrada executado logo após a criação da ordem de serviço. Inicialmente criado para que o cliente possa agendar ou controlar o agendamento da ordem de serviço logo após a criação da mesma
	Local lFTVD7059		:= ExistBlock("FTVD7059")							// Se existe o PE FTVD7059. Esse ponto de entrada tem como objetivo permitir que o cliente crie número de série para cada produto informado, possibilitando assim a criação da OS.
	//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
	Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida


	// Se não estiver configurado os parâmetros com as informações dos serviços, cancela a criação da OS
	If cOcorMontagem == "" .AND. cOcorEntrega == ""
		lRetorno := .F.
	EndIf

	// Se não estiver configurado a condição de pagamento padrão, cancela a criação da OS
	If Empty(cCondPag)
		lRetorno := .F.
	EndIf

	If lRetorno
		For nCount := 1 To Len( aItens )
			nRegs		:= 1
			lMultiplos	:= .F.
			If SL2->( DbSeek( xFilial("SL2") + cNumPai + aItens[nCount] ) )
				aAreaSB1 := SB1->(GetArea())
				SB1->(DbSetOrder(1))
				SB1->(DbSeek(xFilial("SB1")+SL2->L2_PRODUTO))
				// Produto principal eh configurado como garantia SB1->B1_GARANT = 1 porem Tipo diferente de Garantia
				// Eh passado para funcao somente os produtos configurados conforme Boletim
				// Tirada a consistencia SB1->B1_GARANT<>"1", pois o produto nao precisa ser de Garantia para ser Montagem
			    If (SB1->B1_TIPO == "GE" .And. !Empty(SB1->B1_ADMIN) .And. SB1->B1_GARANT=="1")
			       Loop
			    Endif
				RestArea(aAreaSB1)
				// Se o número de série não estiver preenchido e existir o PE LJ7059 pega os números de série vindos do PE. Verifique que nesse caso é possível haver vários números de série para cada produto, isso é possível, pois o PE possibilita informa um número de série para cada quantidade informada.
				If (Empty( SL2->L2_NSERIE ) .AND. (lLJ7059 .AND. !lFtvdVer12)) .OR. (Empty( SL2->L2_NSERIE ) .And. (lFTVD7059 .AND. lFtvdVer12))
					If !lFtvdVer12
						aNrsSerie := ExecBlock( "LJ7059", .F., .F. )
					ElseIf lFtvdVer12
						aNrsSerie := ExecBlock( "FTVD7059", .F., .F. )
					EndIf

					If ValType(aNrsSerie) != "A" .AND. Len(aNrsSerie) <= 0
						Loop
					Else
						lMultiplos  := .T.
						nRegs       := Len(aNrsSerie)
					EndIf
				ElseIf !Empty(SL2->L2_NSERIE)
					Aadd(aNrsSerie,SL2->L2_NSERIE)
				Endif

				If Len(aNrsSerie) > 0
					// Cria a base instalada para o produto, ou para cada número de série informado no PE
					Lj7BaseInstalada( aNrsSerie )

					// Para cada produto ou para cada número de série informado no PE, adiciona o item da OS que deverá ser criado.
					For nI := 1 to nRegs
						// Se tiver data de entrega, cria um item para entrega
						If SL2->L2_FDTENTR != CToD("//") .AND. !Empty(cOcorEntrega)
								aAdd( aOSInfo, { SL2->L2_PRODUTO, If(lMultiplos, aNrsSerie[nI], SL2->L2_NSERIE), cOcorEntrega, SL2->L2_CODCONT } )
						EndIf

						// Se tiver data de montagem, cria um item para montagem
						If SL2->L2_FDTMONT != CToD("//") .AND. !Empty(cOcorMontagem)
								aAdd( aOSInfo, { SL2->L2_PRODUTO, If(lMultiplos, aNrsSerie[nI], SL2->L2_NSERIE), cOcorMontagem, SL2->L2_CODCONT } )
						EndIf
					Next
					// Zera array apos processo
					aNrsSerie	:= {}
				Endif
			Endif
		Next

		If Len( aItens ) > 0 .AND. Len( aOSInfo ) > 0
			If !LjCriaOS( cNumOS, SL1->L1_CLIENTE, SL1->L1_LOJA, cCondPag, SL1->L1_NUM, aOSInfo, cErro )
				lRetorno := .F.
			Else
			If lLJ7056 .AND. !lFtvdVer12
					ExecBlock( "LJ7056", .F., .F., { cNumOS } )
				EndIf

			If lFTVD7056 .AND. lFtvdVer12
				ExecBlock( "FTVD7056", .F., .F., { cNumOS } )
			EndIf

			EndIf
		EndIf
	EndIf
Return lRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7BaseInstºAutor  ³Vendas Clientes     º Data ³  01/10/09  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Cria a base instalada para os produtos de entrega.         º±±
±±º          ³ Recebe um array com os nos. de serie para geracao de mul-  º±±
±±º          ³ tiplos registros de base instalada.                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SigaLoja                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7BaseInstalada( aNrsSerie )
Local lMultiplo := .F.   // Gera base instalada para cada produto vendido, com base no array recebido
Local aCab040   := {}    // Cabecalho do AA3
Local aItens040 := {}    // Itens AA4
Local nRegs     := 1     // No. de registros de base instalada que serao gerados
Local lRet      := .T.
Local nI

Private lMSErroAuto	:= .F.	//VerIfica se ocorreu algum erro durante a Geracao da base

// Se recebeu o array na chamada da funcao
If ValType(aNrsSerie) == "A" .AND. Len(aNrsSerie) > 0
   lMultiplo := .T.
   nRegs     := Len(aNrsSerie)
Endif

For nI := 1 to nRegs
   cSerie := If(lMultiplo, aNrsSerie[nI], SL2->L2_NSERIE)

	Aadd(aCab040, { "AA3_FILIAL"	, xFilial("AA3")	, NIL } )
	Aadd(aCab040, { "AA3_CODCLI"	, SL1->L1_CLIENTE	, NIL } )
	Aadd(aCab040, { "AA3_LOJA"	 	, SL1->L1_LOJA		, NIL } )
	Aadd(aCab040, { "AA3_CODPRO"	, SL2->L2_PRODUTO	, NIL } )
	Aadd(aCab040, { "AA3_NUMSER"	, cSerie				, NIL } )
	Aadd(aCab040, { "AA3_DTVEN"	, DATE()				, NIL } )

   DbSelectArea('AA3')
   AA3->(DbSetOrder(1))
   If !AA3->(DbSeek(xFilial('AA3') + SL1->L1_CLIENTE + SL1->L1_LOJA + SL2->L2_PRODUTO + cSerie))

      If Type("N") == "N"
         nAnt := n
         n := 1
      EndIf

		MSExecAuto( {|w,x,y,z| TECA040(w,x,y,z)}, NIL, aCab040, aItens040, 3)
      If Type("N") == "N"
         n := nAnt
      EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³VerIfica se houveram erros durante a geracao da base   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMsErroAuto
			lRet := !lMsErroAuto
		Endif
   Endif

   aCab040 := {}
Next

Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7AtuInteºAutor  ³Vendas Clientes     º Data ³  25/03/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Leva os dados da venda para integracao (Processo OffLine)  º±±
±±º          ³ L1,L2,L4,F2,D2,E1,E5,EF e C0								  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7AtuInte(oDadosOff, cNumOrc, cFilProc, lProcOff)

Local oProcessOff 	:= Nil									//Objeto do tipo LJCProcessoOffLine
Local cChave 		:= ""									//Chave da tabela
Local aAreaAtual	:= ""   								//Array que ira guardar os dados do alias atual
Local aArea         := ""									//Array que ira guardar os dados do alias utilizado
Local cPrefixo		:= ""  									//Valor do prefixo
Local cNumE1		:= ""  									//Numero do Titulo
Local cMvLjPref		:= SuperGetMV("MV_LJPREF")  			//Regra para gravacao do SF2->F2_PREFIXO
Local cNumDoc		:= ""									//Numero do documento do orcamento
Local cSerie		:= ""									//Serie do orcamento
Local lTemPedido	:= .F.									//Indica se o orcamento tem pedido
Local aSB2			:= {}									//Array com as chaves do SB2
Local nCount		:= 0									//Variavel auxiliar contador
Local cAuxChave		:= ""									//Variavel auxiliar utilizada para verificar se é o mesmo produto do SL2
Local lAmbOffLn 	:= SuperGetMv("MV_LJOFFLN", Nil, .F.)	//Identifica se o ambiente esta operando em offline

Default oDadosOff 	:= Nil
Default cNumOrc		:= ""
Default lProcOff	:= .T.
Default cFilProc	:= ""

//Verifica se o ambiente esta operando em offline
If lAmbOffLn

	//Guarda a posicao do arquivo atual
	aAreaAtual := GetArea()

	//Instancia o objeto LJCProcessoOffLine se necessario
	If oDadosOff == Nil
		oProcessOff := LJCProcessoOffLine():New("006")
	Else
		oProcessOff := oDadosOff
	EndIf

	//Verifica se foi passado numero do orcamento
	If Empty(cNumOrc)
		cNumOrc := M->LQ_NUM
	EndIf

	//Verifica se foi passado a filial de processamento
	If Empty(cFilProc)
		cFilProc := xFilial("SL1")
	EndIf

	//Insere os dados do processo (registro da tabela) SL1
	DbSelectArea("SL1")

	DbSetOrder(1)

	If (SL1->(DbSeek(cFilProc + cNumOrc)))

		cChave := cFilProc + SL1->L1_NUM
		oProcessOff:Inserir("SL1", cChave, 1, "INSERT")

	EndIf


	//Insere os dados do processo (registro da tabela) SL2
	aArea := SL2->(GetArea())

	DbSelectArea("SL2")

	If (SL2->(DbSeek(cFilProc + SL1->L1_NUM)))

		While !SL2->(EOF()) .AND. SL2->L2_FILIAL + SL2->L2_NUM == cFilProc + SL1->L1_NUM

			cChave := cFilProc + SL2->L2_NUM + SL2->L2_ITEM +SL2->L2_PRODUTO
			oProcessOff:Inserir("SL2", cChave, 1, "INSERT")
			SL2->(DbSkip())

		End

	EndIf

	RestArea(aArea)


	//Insere os dados do processo (registro da tabela) SL4
	aArea := SL4->(GetArea())

	DbSelectArea("SL4")

	If (SL4->(DbSeek(cFilProc + SL1->L1_NUM)))

		While !SL4->(EOF()) .AND. SL4->L4_FILIAL + SL4->L4_NUM == cFilProc + SL1->L1_NUM

			cChave := cFilProc + SL4->L4_NUM + SL4->L4_ITEM
			oProcessOff:Inserir("SL4", cChave, 4, "INSERT")	 //"2"
			SL4->(DbSkip())

		End

	EndIf

	RestArea(aArea)

	//Verifica se eh pedido (Tem reserva)
	If AllTrim(SL1->L1_TIPO) == "P" .AND. Empty(AllTrim(SL1->L1_FILRES)) .AND. Empty(AllTrim(SL1->L1_ORCRES))
		cNumDoc 	:= SL1->L1_DOCPED
		cSerie  	:= SL1->L1_SERPED

		If Alltrim(Upper(cMvLjPref)) == "SF2->F2_SERIE"
			cPrefixo	:= If(Empty(SL1->L1_SERIE), SL1->L1_SERPED, SL1->L1_SERIE)
		Else
			cPrefixo	:= &(cMvLjPref)
		Endif

		If ExistFunc("LJ7NumTit")
			cNumE1 := LJ7NumTit()
		Else
			cNumE1  := cNumDoc
		EndIf
	Else
		cNumDoc 	:= SL1->L1_DOC
		cSerie  	:= SL1->L1_SERIE
		cPrefixo	:= &(cMvLjPref)
		If ExistFunc("LJ7NumTit")
			cNumE1 := LJ7NumTit()
		Else
			cNumE1  := cNumDoc
		EndIf
	EndIf

	//Insere os dados do processo (registro da tabela) SF2
	DbSelectArea("SF2")

	cChave := cFilProc + cNumDoc + cSerie + SL1->L1_CLIENTE + SL1->L1_LOJA
	oProcessOff:Inserir("SF2", cChave, 1, "INSERT")

	//Insere os dados do processo (registro da tabela) SD
	aArea := SL2->(GetArea())

	DbSelectArea("SL2")

	If (SL2->(DbSeek(cFilProc + SL1->L1_NUM)))

		While !SL2->(EOF()) .AND. SL2->L2_FILIAL + SL2->L2_NUM == cFilProc + SL1->L1_NUM

			cChave := cFilProc + cNumDoc + cSerie + SL1->L1_CLIENTE + SL1->L1_LOJA + SL2->L2_PRODUTO + SL2->L2_ITEM

			If (SD2->(DbSeek(cChave)))

				If cAuxChave != cFilProc + SL2->L2_PRODUTO + SL2->L2_LOCAL
					cAuxChave := cFilProc + SL2->L2_PRODUTO + SL2->L2_LOCAL
					AADD(aSB2, cAuxChave)
				EndIf

				oProcessOff:Inserir("SD2", cChave, 3, "INSERT")

			EndIf

			SL2->(DbSkip())

		End

	EndIf

	RestArea(aArea)

	//Insere os dados do processo (registro da tabela) SB2
	aArea := SB2->(GetArea())

	DbSelectArea("SB2")

	For nCount := 1 To Len(aSB2)
		If (SB2->(DbSeek(aSB2[nCount])))
			oProcessOff:Inserir("SB2", aSB2[nCount], 1, "UPDATE")
		EndIf
	Next

	RestArea(aArea)

	//Insere os dados do processo (registro da tabela) SE1, SE5 e SEF
	aArea := SE1->(GetArea())

	DbSelectArea("SE1")

	DbSetOrder(1)

	//E1_FILIAL + E1_PREFIXO + E1_NUM
	If DbSeek(cFilProc + cPrefixo + cNumE1)

		While !SE1->(EOF()) .AND. SE1->E1_FILIAL + SE1->E1_PREFIXO + SE1->E1_NUM  == cFilProc + cPrefixo + cNumE1

			cChave := cFilProc + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO
			oProcessOff:Inserir("SE1", cChave, 1, "INSERT")

			If AllTrim(SE1->E1_TIPO) = "R$"

				cChave := cFilProc + SE1->E1_NATUREZ + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO + DTOS(dDatabase)
				oProcessOff:Inserir("SE5", cChave, 4, "INSERT")

			ElseIf AllTrim(SE1->E1_TIPO) = "CH"

				cChave := cFilProc + SE1->E1_BCOCHQ + SE1->E1_AGECHQ + SE1->E1_CTACHQ + SE1->E1_NUMCART
				oProcessOff:Inserir("SEF", cChave, 1, "INSERT")

			EndIf

			SE1->(DbSkip())

		End

	EndIf

	RestArea(aArea)

	If lTemPedido

		aArea := SL1->(GetArea())

		DbSelectArea("SL1")

		DbOrderNickName("FILORCRES") //L1_FILRES + L1_ORCRES

		If (SL1->(DbSeek(cFilProc + cNumOrc)))

			While !SL1->(EOF()) .AND. SL1->L1_FILRES + SL1->L1_ORCRES == cFilProc + cNumOrc
				//Chama o metodo por recursividade
				Lj7AtuInte(oProcessOff, SL1->L1_NUM, SL1->L1_FILIAL, .F.)
				//Vai para o proximo registro
				SL1->(DbSkip())
			End
		EndIf

		RestArea(aArea)

	EndIf

	//Verifica se eh para processar
	If lProcOff
		//Processa os dados
		oProcessOff:Processar()
	EndIf

	//Restaura a area atual
	RestArea(aAreaAtual)
EndIf


Return Nil
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7StarJobºAutor  ³Vendas Clientes     º Data ³  25/03/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                          				  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/


Function Lj7StarJob()

	IpcGo('FRONTVENDA')

Return()

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³Lj7CaUlCup   ºAutor  ³Vendas Clientes     º Data ³  25/03/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                               º±±
±±º          ³                                          				     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                               º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Lj7CaUlCup(lConfirma)

Local nRet    		:= 0
Local cRet			:= ""
Local nX			:= 0
Local nTamDoc     	:= TamSX3("L1_DOC")[1]
Local cNumCup		:= Space(nTamDoc)
Local cSerie		:= Padr(LjGetStation("LG_SERIE"),TamSX3("LG_SERIE")[1] )// Tamanho da Serie
Local cPDV  		:= Space(TamSX3("L1_PDV")[1])
Local aSL1
Local cLiMsg
Local cSupervisor	:= Space(15)
Local aReserva		:= {}
Local AVALEPRE		:= {}
Local lAutoExC		:= IsBlind()						// Verifica se a rotina sera executada via execauto ou nao

//Localizacoes
Local lCancCup 		:= .F.
Local lInfCup  		:= .T.
Local nOrdSL1  		:= SL1->(IndexOrd())
Local aRet     		:= {}
Local lRet     		:= .T.   							// .T. - Erro no cancelamento do cupom, .F. - Cancelamento com sucesso
Local lReturn  		:= .F.
Local aDadosCrd		:= {}					 			// Dados do cliente para o web service

Local lFRTCancelat  := ExistTemplate("FRTCancela")		// verifica se existe o PONTO DE ENTRADA FRTCancela
Local xRet                                         		// Retorno do PE FRTCANCCF
Local lFrtCancCF    := ExistBlock("FRTCANCCF")     		// Verifica se existe o ponto de entrada FRTCancCF
Local lTouch		:= If( LJGetStation("TIPTELA") == "2", .T., .F. )
Local oObj
Local cUsrSessionID := ""
Local cAntNumCup	:= ""										//Numero do cupom anterior
Local lCancPenCup	:= .F.										//Valida se exclui o penultimo cupom, quando impresso algum Comprovante de Cred. e Deb. (CCD)
Local nTamCup		:= 0										//Tamanho da variável cNumCup
Local lVendTef		:= .F.
Local lTefOk		:= .T.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Release 11.5 - Cartao Fidelidade³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lLjcFid 		:= SuperGetMv("MV_LJCFID",,.F.) .AND.	CrdxInt() 	 //Indica se a recarga de cartao fidelidade esta ativa
Local lCancelPAF	:= .F.								//Verifica cancelamento especifico para PDV PAF-ECF, caso a venda não tenha subido para a retaguarda, aguarda subida para cancelamento efetivo

Private lExcAuto	:= .F.

DEFAULT lConfirma	:= .T.								// Verifica se pede confirmação para cancelamento, Loja140 chama rotina sem pedir confirmação

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se o cupom está fechado³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nRet := IFPegCupom( nHdlECF,@cNumCup )
nTamCup := Len(cNumCup)
cNumCup  := PADR(cNumCup,nTamDoc) // Restaura o tamanho da variavel cNumcup para a comparação com L1_DOC
If nRet <> 0
	HELP(' ',1,'FRT011')	      // "Erro com a Impressora Fiscal. Operação não efetuada.", "Atenção"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Restaura os SetKey's do Fechamento da Venda ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Valtype(aKey) = "A"		
		FRTSetKey(aKey)
	EndIf
	Return lRet
Else
	If lFrtCancCF
		xRet := ExecBlock("FRTCANCCF",.F.,.F.,{cNumCup})
		If ValType(xRet) == "C"
		   cNumCup  := xRet
		Endif
	Endif
Endif

nRet := IFPegPDV(nHdlECF, @cPDV)
cPDV := PADR(cPDV, TamSX3("L1_PDV")[1])
If nRet <> 0
	HELP(' ',1,'FRT011')	      // "Erro com a Impressora Fiscal. Operação não efetuada.", "Atenção"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Restaura os SetKey's do Fechamento da Venda ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Valtype(aKey) = "A"		
		FRTSetKey(aKey)
	EndIf
	Return lRet
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona o SL1 na ultima venda          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SL1")
SL1->(DbSetOrder(2))
IF SL1->(DbSeek(xFilial("SL1")+cSerie+cNumCup+cPDV))
	// Caso haja a chave acima duplicada , busca a ultima venda para cancelar
	// pode haver duplicado caso troque o ecf e não altere o numero de serie.
	While  .T.
		IF SL1->L1_EMISNF == Date()
			Exit
		Else
			SL1->(DbSkip())
			If (xFilial("SL1")+cSerie+cNumCup+cPDV) <> SL1->(xFilial("SL1")+L1_SERIE+L1_DOC+L1_PDV) ;
	    		.OR. SL1->(EOF())
				SL1->(DbSkip(-1))
				Exit
			EndIf
		EndIf
	End
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se o cupom da ultima venda não for o mesmo do ECF nao faz o cancelamento     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Alltrim(cNumCup) <> Alltrim(SL1->L1_DOC)
	cAntNumCup := AllTrim(cNumCup)
	cNumCup  := PADR(StrZero(Val(AllTrim(cNumCup))-1,nTamCup),nTamDoc)
	If !SL1->(DbSeek(xFilial("SL1")+cSerie+cNumCup+cPDV))
		lRet		:= .F.

		// "O último cupom do ECF não corresponde com a última venda. Não será feito o cancelamento do cupom.", "Atenção"
		HELP(' ',1,'FRT035')
	Else
		lCancPenCup := .T.
	EndIf
Else
	lRet := .T.
EndIf

If lRet
	If lConfirma
		If Len(aReserva) == 0
			lRet := MsgYesNo(STR0146 +cNumCup+STR0119, STR0147 ) // "Realiza o CANCELAMENTO do Cupom Fiscal nº " ### " ?", "Atenção"
		Else
			lRet := MsgYesNo(STR0148, STR0147 ) //"Realiza o CANCELAMENTO do Cupom não Fiscal? ""Atenção"
		EndIf
	Else
		lRet := .T.
	EndIf
Endif

//PAFECF: Valida Serie/GT para realizar o cancelamento
If lMVLJPDVPA .AND. (!LJValGT() .OR. !LjVldSerie())
	If !lAutoExC
		MsgStop(STR0164)	//"Cancelamento não realizado!"
	Else
		ConOut(STR0164)		//"Cancelamento não realizado!"
		Help( " ", 1, "Help",, STR0164, 1, 0 )
	EndIf
	lRet := .F.
EndIf

LjRegRefsh("SL1") // Caso orcamento tenha subido e alterado L1_SITUA enquanto esta cancelando

lCancelPAF := IIF(lMVLjPdvPa .AND. SL1->L1_SITUA <> "TX",.T.,.F.)

If !isBlind() .AND. SL1->L1_VENDTEF == "S" .AND. (SL1->L1_CARTAO > 0 .OR. SL1->L1_VLRDEBI > 0)
	If lUsatef
		lVendTef := .T.
	Else
		lVendTef := .F.
	EndIf
EndIf

If lRet .AND. ( !lConfirma .OR. LJProFile(8,@cSupervisor,,,, .T. ) ) //Qdo vier do Loja140 nao deve validar permissao de caixa

	If !lCancelPAF
		aSL1 := {{"L1_SITUA",	"07"}}				// "07" - Solicitado o Cancelamento do Cupom
	Else
		aSL1 := {{"L1_STORC",	"C"}}				// "C" - Sinaliza Venda Cancelada, para gerar SLI apos subir a venda para retaguarda, nesse momento não possui L1_NUMORIG
	EndIf

	FR271BGeraSL("SL1", aSL1)

	If Len(aReserva) == 0

		If lCancPenCup
			nRet := IFEstornVinc(	nHdlECF,AllTrim(SL1->L1_CGCCLI),"","",;
									"Cancelamento de Comprovante de Crédito e Débito",cAntNumCup)
			If nRet <> 0
				MsgAlert(	"Não foi possível efetuar o cancelamento do cupom vinculado. Verifique se o último " +;
							"impresso foi um relatório gerencial caso seja não é permitido o cancelamento " )

				aSL1 := {{"L1_SITUA",	"00"}}	// Retira a solicitação de cancelamento
				FR271BGeraSL("SL1", aSL1)

				// "O Cupom fiscal nº "+cNumCup+", não pode ser cancelado."
				MsgStop(STR0020+cNumCup+STR0021)

				//Restaura os SetKey's do Fechamento da Venda
				If Valtype(aKey) = "A"		
					FRTSetKey(aKey)
				EndIf
				Return lRet
			EndIf
		EndIf

		//Insere MD5 no campo pois no movimento por ECF, ao validar o MD-5 deste deletado deve trazer com ele correto
		aSL1 := {{"L1_PAFMD5", LjxPAFMD5("SL1")}}
		FR271BGeraSL("SL1", aSL1)
				
		/*
		Homologacao 2017 - PAF-ECF 
		Quando tenho cancelamento de CCD ele aumenta o numero de comprovantes
		fazendo com que na hora de gravar o log de cancelamento (SLX) não seja
		gravada corretamente
		*/ 
		nRet := IFCancCup(nHdlECF, cSupervisor,IIF(lCancPenCup,cNumCup,""))
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cancela o TEF na Administradora³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lUsaTEF
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se estiver configurado a CLISITEF, passa o objeto oTEF. ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cTipTEF == TEF_CLISITEF
			Lj140CnAdm(.F., @lVendTef, @oTEF		, @lTefOk)
		Else
			Lj140CnAdm(.F., @lVendTef, /*@oTEF*/	, @lTefOk)
		EndIf
	EndIf

	If nRet == 0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Caso exista Integracao com o SIGACRD, cancela o Credito em aberto     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If CrdXInt()
			If Empty(cUsrSessionID)
				If !lAutoExC
					LJMsgRun(STR0153,, {|| cUsrSessionID := WSCrdLogin( cUserName, cSenha ) } ) //"Aguarde... Efetuando login no servidor ..."
				Else
					cUsrSessionID := WSCrdLogin( cUserName, cSenha )
				EndIf
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Executa um webservice para saber qual o status da analise de credito ³
			//³do cliente. Se for diferente de 4 (fila de crediario) pode cancelar  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			oObj:=WSCRDSTATUS():New()
			oObj:_URL			:= "http://"+AllTrim(LJGetStation("WSSRV"))+"/CRDSTATUS.apw"
			oObj:cCodCli		:= SL1->L1_CLIENTE
			oObj:cLoja			:= SL1->L1_LOJA
			oObj:cUsrSessionID	:= cUsrSessionID

			If oObj:GetStatus()
				If oObj:OWSGETSTATUSRESULT:CSITUACAO <> "4"	// Fila de crediario
		  			aDadosCrd := {}
					aAdd( aDadosCrd, aCrdCliente[2] ) 		// Numero do cartao
					aAdd( aDadosCrd, aCrdCliente[1] )		// CNPJ/CPF

					// Faz o desfazimento da transacao de credito
					CrdxVenda( "3"   ,aDadosCrd  ,If(Empty(SL1->L1_CONTRA),cContrato,SL1->L1_CONTRA),.T.   ,;
					           NIL   ,NIL )
				EndIf
			Else
				Conout(GetWSCError())
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Limpa as variaveis staticas de controle da analise de credito³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Fr271ICrdSet( @cContrato	, @aCrdCliente	,  @aContratos	, @aRecCrd)

		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Pega os dados do SL1 antes de deleta-lo ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cLiMsg := SL1->L1_NUMORIG+"|"+SL1->L1_DOC+"|"+SL1->L1_PDV
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se foi utilizado VP na venda como forma de pagamento ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SL4")
		SL4->(DbSetOrder(1))
		If SL4->(DbSeek(xFilial("SL4")+SL1->L1_NUM))
			While !SL4->(Eof()) .AND. (SL4->L4_FILIAL+SL4->L4_NUM == xFilial("SL4")+SL1->L1_NUM)
				If AllTrim(SL4->L4_FORMA) == "VP"
		   			aAdd(aValePre,{AllTrim(SL4->L4_NUMCART),"2"})
				EndIf
				SL4->(DbSkip())
			End
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se foi vendido algum VP na venda ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SL2")
		SL2->(DbSetOrder(1))
		If SL2->(DbSeek(xFilial("SL2")+SL1->L1_NUM))
			While !SL2->(Eof()) .AND. (SL2->L2_FILIAL+SL2->L2_NUM == xFilial("SL2")+SL1->L1_NUM)
				If SL2->(FieldPos("L2_VALEPRE")) > 0 .AND. !Empty(SL2->L2_VALEPRE)
		   			aAdd(aValePre,{AllTrim(SL2->L2_VALEPRE),"1"})
				EndIf
				SL2->(DbSkip())
			End
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Release 11.5 - Cartão Fidelidade³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lLjcFid
			DbSelectArea("SL2")
			SL2->(DbSetOrder(1))
			If SL2->(DbSeek(xFilial("SL2")+SL1->L1_NUM))
				While !SL2->(Eof()) .AND. (SL2->L2_FILIAL+SL2->L2_NUM == xFilial("SL2")+SL1->L1_NUM)
					If LaFunhProd(SL2->L2_PRODUTO) .AND.	!Empty(SL2->L2_NUMCFID) .AND. !Empty(SL2->L2_DTSDFID) .AND. (SL2->L2_VLRCFID > 0)
			 	   		//Cancelamento de venda de recarga de cartao fidelidade
			 			If !Ca280Exec("CA280ESLD",SL2->L2_NUMCFID,,,SL1->L1_DOC,SL1->L1_SERIE,SL1->L1_LOJA,"4")
			 				aSL1 := {{"L1_SITUA",	"00"}}				// Retira a solicitação de cancelamento
							FR271BGeraSL("SL1", aSL1)
							MsgStop(STR0155 +cNumCup+ STR0156)//// "O Cupom fiscal nº "+cNumCup+", não pode ser cancelado devido a falha na atualização do saldo do cartão fidelidade."
							Return lRet
			 			EndIf
			 			Exit
			 		EndIf
			 		SL2->(DbSkip())
			 	End
			 EndIf

	 		//Cancelamento de venda com forma de pagamamento FID - Cartao fidelidade
			DbSelectArea("SL4")
			SL4->(DbSetOrder(1))
			If SL4->(DbSeek(xFilial("SL4")+SL1->L1_NUM))
				While SL4->(!Eof()) .AND. SL4->L4_NUM == SL1->L1_NUM
					If Alltrim(SL4->L4_FORMA) == "FID"
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Se a venda foi paga com cartao fidelidade, entao o ³
						//³movimento de saida sera estornado da tabela MBN    ³
						//³e o valor devolvido ao respectivo saldo.           ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !(Ca280Exec("CA280ESLD",SL4->L4_NUMCFID,,,SL1->L1_DOC,SL1->L1_SERIE,SL1->L1_LOJA,"3"))
							aSL1 := {{"L1_SITUA",	"00"}}				// Retira a solicitação de cancelamento
							FR271BGeraSL("SL1", aSL1)
							MsgStop(STR0155 +cNumCup+ STR0156)//// "O Cupom fiscal nº "+cNumCup+", não pode ser cancelado devido a falha na atualização do saldo do cartão fidelidade."
							Return lRet
						Endif
	 					Exit
	 				EndIf
	 				SL4->(DbSkip())
				End
			EndIf

		EndIf

		FR271BCancela()

		lFechaCup := .T.

		If Len(aValePre) > 0
			LjEstVP(aValePre)
		EndIf

		If SL1->L1_CREDITO > 0
			If Empty(SL1->L1_DOC)
				cParmDoc := SL1->L1_DOCPED
			Else
				cParmDoc := SL1->L1_DOC
			Endif

			If Empty(SL1->L1_SERIE)
				cParmSer := SL1->L1_SERPED
			Else
				cParmSer := SL1->L1_SERIE
			Endif

                        Frt060ExNCC(SL1->L1_FILIAL,cParmDoc	,cParmSer		,SL1->L1_CLIENTE,;
                        			SL1->L1_LOJA  , .F.		, SL1->L1_NUM	,SL1->L1_OPERADO,;
                        			SL1->L1_EMISNF,SL1->L1_CREDITO)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//|Reinicializa as variaveis estaticas p/ rotina de recebimento de NCC	³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Frt060End()

		//³ Reinicializa as variáveis de Templates                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		uCliTPL := Nil
		uProdTPL:= Nil
        cCodConv:= ""
        cLojConv:= ""
		cNumCartConv := ""

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Define cliente com o padrao do parametro ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nTamSXG  := TamSXG("001")[1]	// Grupo de Cliente
		cCliente := Left(PadR(SuperGetMV("MV_CLIPAD"), nTamSXG),nTamSXG)
		nTamSXG  := TamSXG("002")[1]	// Grupo de Loja
		cLojaCli := Left(PadR(SuperGetMV("MV_LOJAPAD"),nTamSXG),nTamSXG)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Gera o SLI , necessario que a venda tenha subido para a retaguarda, caso nao tenha subido, gera SLI no momento que subir ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMVLjPdvPa .OR. nModulo == 23
			If !lCancelPAF
				FR271BGerSLI("    ", "CAN", cLiMsg, "NOVO")
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ P.E. Apos o Cancelamento        ³
		//³ Tipo      : 1 - Item            ³
		//³             2 - Cupom           ³
		//³ Supervisor: Senha que autorizou ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lFRTCancelat
			uProdTPL := ExecTemplate("FRTCancela",.F.,.F.,{2,cSupervisor,,uProdTPL})
		EndIf
		If ExistBlock("FRTCancela")
			ExecBlock("FRTCancela",.F.,.F.,{2,cSupervisor,NIL,uProdTPL})
		EndIf

	Else
		aSL1 := {{"L1_SITUA",	"00"}}				// Retira a solicitação de cancelamento
		FR271BGeraSL("SL1", aSL1)
		// "O Cupom fiscal nº "+cNumCup+", não pode ser cancelado."
		MsgStop(STR0149+cNumCup+STR0150)
		Return lRet
	Endif
EndIf
SL1->(DbSetOrder(nOrdSL1))

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7BxNccWS   ºAutor  ³Vendas Clientes     º Data ³  04/11/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Chama a baixa da NCC via WebService                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                               º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7BxNccWS(cL1Doc, cL1Serie, cParcela, aRecnoSE1, aVlrReceb)
Local nTamE1_PARCELA

Local cMvLjPref
Local cOperado := xNumCaixa()
Local lParc    := ""

Default cL1Doc   	:= If(Empty(SL1->L1_DOCPED),SL1->L1_DOC,SL1->L1_DOCPED)
Default cL1Serie 	:= If(Empty(SL1->L1_SERPED),SL1->L1_SERIE,SL1->L1_SERPED)
Default cParcela 	:= ""
Default aRecnoSE1	:= {}
Default aVlrReceb	:= {}


nTamE1_PARCELA	:= TamSX3("E1_PARCELA")[01]								// Tamanho do campo E1_PARCELA
cMvLjPref		:= SuperGetMV("MV_LJPREF")								// Regra para gravacao do SF2->F2_PREFIXO
lParc 			:=  cParcela											// Campo E1_PARCELA

cParcela := PadR(SuperGetMV("MV_1DUP"), nTamE1_PARCELA)

While SE1->(DbSeek(xFilial("SE1") + cL1Serie + cL1Doc + cParcela + "NCC"))
	cParcela := CHR(ASC(cParcela)+1)
End

While CHR(ASC(cParcela)) < CHR(ASC(lParc))
	cParcela := CHR(ASC(cParcela)+1)
End

If nModulo == 23 .And. (Type("nNccUsada") == "U" .Or. Type("nNccGerada") == "U") //23=SIGAFRT
	nNccUsada	:= Frt060Ret("NCC_USADA")
	nNccGerada 	:= Frt060Ret("NCC_GERADA")
EndIf
Frt060Alt("NCC_USADA" ,nNccUsada )
Frt060Alt("NCC_GERADA",nNccGerada)
Frt060BxNCC(cL1Doc		, cL1Serie		, cOperado	, SE1->E1_EMISSAO	,;
   			SA1->A1_COD	, SA1->A1_LOJA	, nNccUsada	, Nil				,;
   			nNccGerada	, Nil			, Nil		, cParcela			,;
   			aRecnoSE1	,aVlrReceb)
Return()


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjNitCli  ºAutor  ³Microsiga           º Data ³  14/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Interface para confirmacao do cliente a ser gravado nos ar- º±±
±±º          ³quivos fiscais (Especifico Bolivia)                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpC1 - Nome do cliente utilizado na venda (opcional)       º±±
±±º          ³ExpC2 - NIT do cliente utilizado na venda (opcional)        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³LOJA701C                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LjNitCli(cGetNome,cGetNit,lNfManual)

Local aArea		:= GetArea()
Local cPictNit	:= PesqPict("SA1","A1_CGC")
Local lRet		:= .F.
Local lInfNFMan	:= SF2->(FieldPos("F2_MANUAL")) > 0
Local bValid	:= Nil
Local oCkhBx	:= Nil
Local oGetNit	:= Nil
Local oGetNome	:= Nil
Local oDlg		:= Nil

Default cGetNome  := ""
Default cGetNit   := ""

//Dimensiona corretamente os campos
If Len(cGetNome) == 0
	cGetNome:= Space(TamSX3("A1_NOME")[1])
EndIf
If Len(cGetNit) == 0
	cGetNit	:= Space(TamSX3("A1_CGC")[1])
EndIf

//Validacao da tela
bValid := {||If(!Empty(cGetNome).AND.!Empty(cGetNit),.T.,(MsgStop(STR0133),.F.))} //"Informe corretamente o nome e o NIT"

//Interface
DEFINE MSDIALOG oDlg TITLE STR0134 FROM 178,181 TO 311,520 PIXEL //"Identificação do cliente"

	@ 002,003 TO 052,166 LABEL STR0135 PIXEL OF oDlg //"Dados do cliente para efeitos fiscais"

	@ 013,008 Say STR0136	Size 018,008 COLOR CLR_BLACK PIXEL OF oDlg	//"Nome:"
	@ 012,034 MsGet oGetNome Var cGetNome Size 126,009 PIXEL OF oDlg

	@ 027,008 Say STR0137 	Size 018,008 COLOR CLR_BLACK PIXEL OF oDlg	//"NIT:"
	@ 026,034 MsGet oGetNit Var cGetNit Size 126,009 COLOR CLR_BLACK Picture cPictNit PIXEL OF oDlg

	If lInfNFMan
		@ 040,008 CheckBox oCkhBx Var lNfManual Prompt STR0138 Size 065,008 PIXEL OF oDlg //"Nota Fiscal manual"
	EndIf

	DEFINE SBUTTON FROM 054,108 TYPE 1 ENABLE OF oDlg Action (If(Eval(bValid),(lRet := .T.,oDlg:End()),.F.))
	DEFINE SBUTTON FROM 054,138 TYPE 2 ENABLE OF oDlg Action (oDlg:End())

ACTIVATE MSDIALOG oDlg CENTERED

Return (.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7AjustStºAutor  ³Microsiga           º Data ³  16/08/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Ajusta a string que vai gravar o tipo de tributacao do item º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpC1 - Situacao tributaria do item                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³LOJA701C                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7AjustSt(cSitTrib)

Local cSitSFT	:= ""
Local cAliqIcm	:= ""

DEFAULT cSitTrib := ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³No caso de Tributado , tem que ser da mesma aliquota ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If "T" $ cSitTrib
	cAliqIcm:=StrTran(cSitTrib," ","")
	cSitSFT := StrTran(cAliqIcm,".","")
	cSitSFT := SubStr(cSitSFT,2,Len(cSitSFT))
	cAliqIcm:= SubStr(cAliqIcm,2,Len(cAliqIcm))
	If Len(cSitSFT) == 1 .OR. Len(SubStr(cAliqIcm,1,At(".",cAliqIcm)-1)) == 1
		cSitSFT := "0"+cSitSFT
	EndIf
	cSitTrib := "T"+PadR(cSitSFT,4,"0")
ElseIf "S" $ cSitTrib
	cAliqIcm	:= StrTran(cSitTrib," ","")
	cSitSFT 	:= StrTran(cAliqIcm,".","")
	cSitSFT 	:= SubStr(cSitSFT,2,Len(cSitSFT))
	cAliqIcm	:= SubStr(cAliqIcm,2,Len(cAliqIcm))
	If Len(cSitSFT) == 1 .OR. Len(SubStr(cAliqIcm,1,At(".",cAliqIcm)-1)) == 1
		cSitSFT := "0"+cSitSFT
	EndIf
	cSitTrib := "S"+PadR( cSitSFT ,4,"0")
ElseIf SubStr(cSitTrib,1,Len(cSitTrib)) $ "F#I#N"
	cSitTrib += "1"
EndIf

Return(Nil)



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LA701GrvVPºAutor  ³Leandro Nogueira    º Data ³  30/09/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Grava o movimento de venda perdida                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Loja701                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LA701GrvVp(oMoviVp,cNumOrc,cDoc,cSerie)

Local cNumVenPer:= 0					// Sequencial do codigo do movimento de venda perdida
Local nSaveSx8 	:= GetSx8Len()			// Numeracao do SX8
Local nY		:= oMoviVp:GetTotMov()	//Total de movimentos de venda perdida armazenados no objeto collection
Local cOldAlias := Alias()
Local nX        := 0
Local lRet		:= .T.
Local nItem		:= 0
Local nTent		:= 0

Default oMoviVp	:= NIL
Default	cNumOrc := ""
Default	cDoc	:= ""
Default	cSerie	:= ""

cNumVenPer:= GetSxENum("MBR","MBR_CODIGO")

DbSelectArea("MBR")
If oMoviVp <> NIL
	For nX := 1 to nY

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Obter chave do item atraves do indice da colecao³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nItem:= oMoviVp:GetNumItem (nX)

		If oMoviVp:GetAtivoVp (nItem)

			cMay := xFilial( "MBR" ) + cNumVenPer
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se dois movimentos de venda perdida iniciam ao mesmo tempo a MayIUseCode impede que ambos utilizem o mesmo numero.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nTent := 0
			While MBR->( DbSeek( xFilial( "MBR" ) + cNumVenPer ) ) .OR. !MayIUseCode( cMay )
				If ++nTent > 20
					MsgAlert(STR0153+ CHR(10)+CHR(13)+;//"Impossivel gerar número sequencial de movimento de venda perdida."
								STR0154) //"O movimento de venda perdida nao sera registrado !"
					lRet := .F.
					Return lRet
				EndIf
				While ( GetSX8Len() > nSaveSx8 )
					ConfirmSx8()
				End
				cNumVenPer:= GetSxENum("MBR","MBR_CODIGO")
				FreeUsedCode()
				cMay := Alltrim( xFilial( "MBR" ) ) + cNumVenPer
			End

			DbSelectArea("MBR")

			Begin Transaction

			RecLock("MBR", .T.)

			REPLACE MBR_FILIAL	WITH   xFilial ("MBR")
			REPLACE MBR_CODIGO 	WITH   cNumVenPer
			REPLACE MBR_DOC 	WITH   cDoc
			SerieNfId("MBR",1,"MBR_SERIE",dDataBase,LjEspecieNF(),cSerie)								
			REPLACE MBR_MOTIVO	WITH   oMoviVp:GetCdMotVp(nItem)
			REPLACE MBR_NUMORC  WITH   cNumOrc
			REPLACE MBR_PROD	WITH   oMoviVp:GetProdVp (nItem)
			REPLACE MBR_ITEM	WITH   oMoviVp:GetItemVp (nItem)
			REPLACE MBR_QUANT	WITH   oMoviVp:GetQtdeVp (nItem)
			REPLACE MBR_JUSTIF	WITH   oMoviVp:GetJustVp (nItem)
			REPLACE MBR_AVDISP	WITH   oMoviVp:GetDispVp (nItem)
			REPLACE MBR_LOJA	WITH   oMoviVp:GetLoja	 (nItem)
			REPLACE MBR_VEND	WITH   oMoviVp:GetVend	 (nItem)
			REPLACE MBR_CODCLI	WITH   oMoviVp:GetcodCli (nItem)
			REPLACE MBR_EMISSA	WITH   oMoviVp:GetEmissao(nItem)

			DbCommit()
			MsUnLock()

			End Transaction


			LA701IntVp ()

		Else
			lRet := .F.
		EndIf
	Next nX
EndIf

DbSelectArea(cOldAlias)

ConfirmSx8()

oMoviVp := LA701KilVp ()

Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³LA701IntVp³ Autor ³ Leandro Nogueira		³ Data ³20/10/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Envia movimento de venda perdida para a integracao  		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Venda Assistida	                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LA701IntVp ()

Static cTipo 		:= ""												//Como os dados serao integrados no processo offline
Static oProcessOff 	:= Nil												//Objeto do tipo LJCProcessoOffLine
Static lAmbOffLn 	:= SuperGetMv("MV_LJOFFLN", Nil, .F.)				//Identifica se o ambiente esta operando em offline
Static lMvLjPdvPa 	:= LjxBGetPaf()[2]// Indica se é pdv

//Verifica se o ambiente esta em off-line
If lAmbOffLn .AND. lMvLjPdvPa
	//Instancia o objeto LJCProcessoOffLine
	oProcessOff := LJCProcessoOffLine():New("032")

	//Determina o tipo de operacao
	If INCLUI
		cTipo := "INSERT"
	ElseIf ALTERA
		cTipo := "UPDATE"
	Else
		cTipo := "DELETE"

		//Considera os registros deletados
		SET DELETED OFF
	EndIf

	If !Empty(cTipo)
		//Insere os dados do processo (registro da tabela)
		oProcessOff:Inserir("MBR", xFilial("MBR") +;
									MBR->MBR_CODIGO+;
									MBR->MBR_NUMORC+;
									MBR->MBR_DOC+;
									MBR->MBR_SERIE+;
									MBR->MBR_PROD+;
									MBR->MBR_ITEM, 1, cTipo)

		//Processa os dados
		oProcessOff:Processar()
	EndIf

	//Desconsidera os registros deletados
	SET DELETED ON
EndIf


Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³Lj7FatRes     ³ Autor ³ Vendas Clientes      ³ Data ³ 21/10/2010 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Fator para calculo do valor total da venda                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1 - Valor total da reserva								   ³±±
±±³          ³ExpN2 - Valor total                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ aRet = Array com fator da venda e fator da reserva              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFRT                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7FatRes(nVlrTotRe, nVlrTotal,nFrete)

Local nFatorRes	:=	0 		//Fator reserva
Local nFatorVen	:=	0		//Fator venda
Local aRet 		:= {}		//Retorno da funcao

Default nVlrTotRe := 1
Default nVlrTotal := 1
Default nFrete	 := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³	 Nas vendas vindas  do SigaFrt, o FRETE	³
//³		precia ser somado ao total da venda   ³
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿

nVlrTotRe += nFrete
nVlrTotal += nFrete

nFatorRes := (nVlrTotRe/nVlrTotal)
nFatorVen := (1-nFatorRes)

If nFatorVen == 0
	aRet := {1, nFatorRes}
Else
	aRet := {nFatorVen, nFatorRes}
Endif

Return(aRet)

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³ LC701QtdSC	 ºAutor³ Vendas CRM        º Data ³  17/02/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna quantidade da solicitacao de compras do item         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³ ExpC1 - Quantidade da solicitacao de compras                 º±±
±±º			 ³ ExpC2 - Controla continuacao do processo                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ ExpN1 - Retorna quantidade da solicitacao de compras do item º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA                                                    	º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function LC701QtdSC(cNSolCom, cProduto)
Local nQtdeSC       := 0				// Quantidade da solicitacao de compras
Local lContinua		:= .T.            	// Controla continuacao do processo

Default	cNSolCom	:= ""  				// Numero da solicitacao de compras
Default	cProduto	:= ""             	// Codigo do produto

/*Posiciona na solicitacao de compras gerada ³
	para o item da venda		*/
DbSelectArea("SC1")
DbSetOrder(1) //C1_FILIAL+C1_NUM+C1_ITEM
If DbSeek(xFilial("SC1") + cNSolCom)
	While !Eof() .AND. (SC1->C1_NUM == cNSolCom) .AND. lContinua
    	If SC1->C1_PRODUTO == cProduto
       		nQtdeSC := 	SC1->C1_QUANT
			lContinua := .F.
		Endif
		DbSkip()
	End
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validacao de seguranca, pois nao  pode³
//³retornar menor que zero               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nQtdeSC < 0
	nQtdeSC := 0
EndIf

Return nQtdeSC

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7ChkGdp		 ºAutor³ Vendas CRM        º Data ³  10/06/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verificar no orcamento PAI se sera gerada a Guia de Despacho, º±±
±±º		     ³de acordo com o tipo de entrega de cada item da venda. 		º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³ ExpC1 - Numero do Orcamento					                º±±
±±º			 ³ ExpL2 - Indica se a execucao eh via JOB		                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ ExpC1 - Tipo da Guia de Despacho que sera gerada				º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA - Chile - Release 11.5                             	º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7ChkGdp (cNumOrc,lJob)

Local cTipo 	:= GDP_NO   //Tipo da Guia de Despacho
Local nItensGdp := 0        //Contador de itens da Guia de Despacho
Local nItens	:= 0       	//Contador de itens da venda

Default cNumOrc	:= M->LQ_NUM
Default lJob		:= .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Release 11.5 - Chile - Guia de Despacho - F2CHI     			³
//³Verificar no orcamento PAI se sera gerada a Guia de Despacho ³
//³de acordo com o tipo de entrega de cada item da venda.      	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lCFolLocR5 .AND. cPaisLoc == "CHI"
	aAreaSL2:=SL2->(GetArea())
	DbSelectArea("SL2")
	DbSeek(xFilial("SL1")+cNumOrc)
	While !SL2->(Eof()) .AND. xFilial("SL1") + cNumOrc == SL2->L2_FILIAL + SL2->L2_NUM
		If SL2->L2_ENTREGA == "3" .AND. !Empty(SL2->L2_RESERVA)
			nItensGdp++
		Endif
		nItens++
		SL2->(DbSkip())
  	End

	SL2->(RestArea(aAreaSL2))
	If nItensGdp == 0
		cTipo:=GDP_NO
	ElseIf nItensGdp==nItens
		cTipo:=GDP_TOTAL
	Else
		cTipo:=GDP_PARCIAL
	EndIf
EndIf

Return cTipo


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³Lj7GrvMotDesc³ Autor ³ Vendas Clientes      ³ Data ³ 02/12/2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Grava o motivo de desconto 					                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1 - Serie do documento     								   ³±±
±±³          ³ExpN2 - Número do documento                                      ³±±
±±³          ³ExpN3 - Número do orçamento                                      ³±±
±±³          ³ExpN4 - Tipo de Motivo : 'O' - Orçamento / '' - Venda            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ NIL												               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGALOJA                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7GrvMotDesc( cSerie , cDoc , cNumOrc, cTipo)

Local nX	   := 0

Default cSerie 	:= ""
Default cDoc   	:= ""
Default cNumOrc	:= ""
Default cTipo  	:= ""	     // cTipo : 'O'- orçamento / '' - venda   ; mais tarde o valor deste será usado como filtro no relatorio

If AliasIndic("MDU") .AND. AliasIndic("MDT") .AND. ExistFunc("LOJA7001") .AND. ExistFunc("Lj7GetMot")
		OGrvMtoDes := Lj7GetMot()
		If !OGrvMtoDes == Nil
			For nX := 1 to      OGrvMtoDes:oDadosCDes:Count()
				If OGrvMtoDes:oDadosCDes:Elements(nX):lAtivo
					DbSelectArea("MDU")
				    RecLock("MDU",.T.)

					REPLACE MDU_FILIAL  WITH xFilial("MDU")
					REPLACE MDU_CODIGO  WITH OGrvMtoDes:oDadosCDes:Elements(nX):cCodigo
					REPLACE MDU_OBS  	WITH OGrvMtoDes:oDadosCDes:Elements(nX):cObs
					REPLACE MDU_PRODUT  WITH OGrvMtoDes:oDadosCDes:Elements(nX):cProduto
					SerieNfId("MDU",1,"MDU_SERIE",dDataBase,LjEspecieNF(),cSerie)					
					REPLACE MDU_DOC  	WITH cDoc
					REPLACE MDU_DATA  	WITH dDatabase

					If OGrvMtoDes:oDadosCDes:ACOLECAO[nX][1] == 99999
						REPLACE MDU_TIPO WITH STR0143	//VALOR
			       	Else
					 	REPLACE MDU_TIPO WITH STR0144	//ITEM
					EndIf

					If (MDU->(FieldPos("MDU_STATUS"))) > 0
						REPLACE MDU->MDU_STATUS WITH cTipo
					EndIf

					If (MDU->(FieldPos("MDU_NUMORC"))) > 0
					    REPLACE MDU->MDU_NUMORC WITH cNumOrc
					EndIf
					MsUnlock()

				   	If FindFunction("LJ7MovInt") 					// Inicia o processo de integracao Off-Line³
				   		LJ7MovInt()
				   	Endif
				ElseIf (MDU->(FieldPos("MDU_NUMORC"))) > 0
					DbSelectArea("MDU")
					DbSetOrder(3)
					If DbSeek(xFilial("MDU")+cNumOrc)
					    RecLock("MDU",.F.)
						SerieNfId("MDU",1,"MDU_SERIE",dDataBase,LjEspecieNF(),cSerie)
						REPLACE MDU_DOC  	WITH cDoc
						MsUnlock()
					EndIf
			    EndIf
			Next

		EndIf
		OGrvMtoDes := Nil 		//³Zera Objeto³
		Lj7SetMot(@OGrvMtoDes)
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³Lj7PesqAltMot³ Autor ³ Vendas Clientes      ³ Data ³ 02/12/2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Pesquisa se existe um motivo de desconto e se existir altera    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1 - Número do documento     								   ³±±
±±³          ³ExpN2 - Série do documento                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ aRet	:= Array que retorna se existe ou não o motivo de desconto ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGALOJA                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7PesqAltMot( cSerie , cDoc , cNumOrc )
Local lRet	   	 := .F.                                                     // Variável de Retorno
Local lMotDesc   := FindFunction("Lj7Mv_Desc")  .AND. Lj7Mv_Desc()      	// Testa se na retaguarda tbem existe o motivo de desconto
Local cDocPesq	 := ""														// Conterá o cNumOrc se existir o Indice 3 da tabela MDU
Local aMDU_NUMORC:= TamSx3("MDU_NUMORC")									// Verifica se existe o campo no SX3 e pega as informações do campo
Local nTamNumOrc := IIF(Len(aMDU_NUMORC)> 0,aMDU_NUMORC[1],TamSx3("L1_NUM")[1]) // Tamanho do campo MDU_NUMORC

If lMotDesc

	SIX->(DbSetOrder(1))
	If SIX->(DbSeek("MDU3"))  // Verifica se o UPDLOJ89 foi aplicado
		If AllTrim( SIX->CHAVE )  == "MDU_FILIAL+MDU_NUMORC"
			cDocPesq	:= PadR(cNumOrc,nTamNumOrc)		// Ajusta ao Tamanho do campo MDU_NUMORC
			lRet		:= .T.
		EndIf
	EndIf

	DbSelectArea("MDU")
	MDU->(DbSetOrder(2))  // Doc + Serie
	If MDU->(DbSeek(xFilial("MDU") + cDoc + cSerie)) //Verifica se existe já na retaguarda um motivo de desconto já importado pelo PDV para a mesma venda
		lRet := .F.
	EndIf

	If lRet

		MDU->(DbSetOrder(3)) 	// NumOrc
		If MDU->(DbSeek(xFilial("MDU") + cDocPesq))	   // cDocPesq == cNumOrc

			While !MDU->(Eof()) .AND. MDU->MDU_NUMORC == cDocPesq

				RecLock("MDU",.F.)

				If (MDU->(FieldPos("MDU_STATUS")) > 0) //Testa se o campo no banco
					REPLACE MDU->MDU_STATUS WITH ""
				EndIf

				If (MDU->(FieldPos("MDU_NUMORC")) > 0) //Testa se o campo no banco
			    	REPLACE MDU->MDU_NUMORC WITH cNumOrc
				EndIf

				REPLACE MDU->MDU_DOC   WITH cDoc       // Atualiza o campo doc que está em branco e quando a venda é finaliza este é preenchido
				SerieNfId("MDU",1,"MDU_SERIE",dDataBase,LjEspecieNF(),cSerie)	// Atualiza o campo serie que está em branco e quando a venda é finalizada este é preenchido

				MsUnlock()
				MDU->(DbSkip())
			EndDo

		Else
			lRet := .F.
		EndIf
	EndIf

EndIf

Return lRet


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    Lj7Arred    Autor ³ Vendas Cliente         ³ Data ³10.05.2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Executa a correcao dos arredondamentos do item             ³±±
±±³          ³ Utiliza o Array aSaveDecLJ para armazenar os centesimos    ³±±
±±³          ³ que foram truncados.Função baseada na MaItArred da MatxFis ³±±
±±³ 																	  ³±±
±±³ nP     = Se vier com 1 , limpa o array Statico na posição nPos,       ³±±
±±³          mas se nPos não for passado, limpa todo o Array              ³±±
±±³                                                                       ³±±
±±³ nPos   = 1 -> Se refere a calculo de arredondamento do Desconto normal³±±
±±³          ( CTRL+B)												   	  ³±±
±±³                                                                       ³±±
±±³ nPos   = 2 -> Se refere a calculo de arredondamento do Desconto       ³±±
±±³          financeiro ( E4_DESCFIN )                                    ³±±
±±³                                                                       ³±±
±±³ nPos   = 3 -> Se refere a calculo de arredondamento do Acrescimo      ³±±
±±³          financeiro ( E4_ACRSFIN )                                    ³±±
±±³                                                                       ³±±
±±³ nPos   = 4 -> Se refere a calculo de arredondamento do Item           ³±±
±±³                                                                       ³±±
±±³ nValor = Valor a ser arredondado e seu valor centesimal guardado em   ³±±
±±³          array de diferenças                                          ³±±
±±³                                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Lj7Arred(nP,nPos,nValor,lArred)

Local nDec      := 2
Local nDifItem	:= 0
Local nRndPrec  := Iif (GetNewPar("MV_RNDPREC", 10)<3, 10, GetNewPar("MV_RNDPREC", 10))	//Precisao para o arredondamento
Local nValArred := 0
Local nX        := 0
DEFAULT nValor 	:= 0
DEFAULT nP 		:= 0
DEFAULT nPos    := 0
DEFAULT lArred	:= .F.

If Len(aSaveDecLj) == 0  .OR. nP == 1
    If nPos == 0
	    aSaveDecLj := Array(10,2)
	    For nX := 1 To Len(aSaveDecLj)
			aSaveDecLj[nX][1] := nX
			aSaveDecLj[nX][2] := 0
	    Next
    Else
		aSaveDecLj[nPos] := {nPos,0}
	EndIf
EndIf

nDifItem := 0

If nValor <> 0

	nValArred := NoRound(NoRound(nValor,nRndPrec),nDec,@nDifItem,10)

	If nDifItem > 0
		aSaveDecLj[nPos][2]	+= nDifItem  // Salva a diferenca a partir da segunda casa
		If ( aSaveDecLj[nPos][2] ) >= (50/(10**(nDec + 2))) 	// Se a dif for maior que 0.005 vai somar
			nValArred 	  := nValArred + (1/10**nDec) 			// Adiciona 1 centavo ao vlr calculado
			aSaveDecLj[nPos][2] -= (1/10**nDec)
			lArred		:= .T.		// Sinaliza que esse item sofreu um arredondamento
		EndIf
	EndIf

EndIf

Return nValArred


/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao Lj7CanDAVOS    Autor ³ Vendas Cliente         ³ Data ³27/09/2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Quando utilizado o conceito de DAV-OS para Oficina de Con-  ³±±
±±³          ³serto (MV_LJDAVOS == .T.) guarda a DAV inicial e cancela a  ³±±
±±³          ³ mesma para que seja gerado um novo orçamento de acordo com ³±±
±±³			 ³Requisito XLI do Ato Cotepe								  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Lj7CanDAVOS()

RecLock("SL1" , .F. )
REPLACE SL1->L1_STORC WITH "C" 	//Deve-se cancelar o orçamento pois este deve ser mostrado na relação de DAVs Emitidos do Menu Fiscal
MsUnlock()

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³Lj7ImpRG      ³ Autor ³Vendas Cliente        ³ Data ³ 12/26/2012 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Gera o Relatorio Gerencial                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1 - Numero do Handle              						   ³±±
±±³          ³ExpN2 - array com os valores do conteudo                         ³±±
±±³          ³ExpN3 - Codigo da OS                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ lRet= Retorna se o relatorio foi gerado com sucesso             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGALOJA  -  Template de Otica                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj7ImpRG(nHandle,aValores,cOs)

Local lRet			:= .F.		// Recebe Retorno
Local cConteudo		:= ""		// Recebe o Conteudo
Local nVias			:= 1		// Recebe a Quantidade de Vias a serem impressas
Local nTotal		:= 0		// Recebe o Total
Local nCount 		:= 0		// Contador

//ÚÄÄÄÄÄÄÄÄÄÄ¿
//³Cabecalho ³
//ÀÄÄÄÄÄÄÄÄÄÄÙ
cConteudo :=  CTRL+ "Nº O.S.: "+ cOs + CTRL
cConteudo +=  "Código           DESCRIÇÃO     UN. VL UNIT R$ /VLITEM R$" + CTRL
cConteudo +=  "------------------------------------------------------------" + CTRL

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Itens do Relatorio ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nCount := 1 To Len(aValores)

	nTotal += aValores[nCount][6]

	cConteudo += cValToChar(aValores[nCount][2])+"  "+ PAD(aValores[nCount][3],15)+ "  "+ ;
	cValToChar(aValores[nCount][4])+cValToChar(aValores[nCount][7]) +" X "+ ;
	AllTrim(Transform(aCols[nCount][5],"@E 999,999.99")) +"   "+ ;
	AllTrim(Transform(aCols[nCount][6],"@E 999,999.99")) + CTRL

Next nCount

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Totalizador ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cConteudo +=  CTRL + "------------------------------------------------------------" + CTRL
cConteudo +=  "TOTAL R$                                          "+ AllTrim(Transform(nTotal,"@E 999,999.99"))+ CTRL

cConteudo +=  "------------------------------------------------------------" + CTRL

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Imprime Relatorio Gerencial ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If IFRelGer(nHandle,cConteudo,nVias) == 0
	lRet := .T.
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    | LjCFciParam ³Autor ³ Vendas e DL			³ Data ³ 07/10/2013	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Verifica se os parametros necessários para o funcionamento da   ³±±
±±³			 |adequação a legislação sobre FCI estão corretamente configurados³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1:= LjCFciParam()										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³ExpA1 = Array com os resultados da funcionalidade de FCI	 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ LOJA701C / LOJXFUNC											  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjCFciParam()
Local aRet := {}

//Retorno as validacoes de dicionarios para as funcionalidades da FCI
aRet := {	SuperGetMv( "MV_FISFRAS",, .T.)												,;
			SuperGetMv( "MV_FCIMOD" ,, "" )												,;
			AliasInDic("CFD")															,;
			SD2->(FieldPos("D2_FCICOD") ) > 0											,;
			SD2->(FieldPos("D2_VLIMPOR")) > 0											,;
			SLR->(FieldPos("LR_VLIMPOR")) > 0 .And. SL2->(FieldPos("L2_VLIMPOR")) > 0	,;
			SD1->(FieldPos("D1_FCICOD") ) > 0											,;
			SLR->(FieldPos("LR_FCICOD") ) > 0 .And. SL2->(FieldPos("L2_FCICOD")) > 0	,;
			SuperGetMv( "MV_FISAUCF",, .T.)}

Return aRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    | LjCRetFci  ³Autor ³ Vendas e DL			³ Data ³ 07/10/2013	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Altera o valor de importação e codigo de FCI de acordo com a    ³±±
±±³			 |configuração do produto (com ou sem rastro), priorizando as	  ³±±
±±³			 |informações digitadas pelo usuario na tela da venda.			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1:= LjCRetFci(cProduto,cLote,cLoteCtl,nVlImp,cFciCod)	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 - Codigo do produto 									  ³±±
±±³          ³ExpC2 - Codigo do Sub-Lote de rastro do produto				  ³±±
±±³          ³ExpC3 - Codigo do Lote de rastro do produto					  ³±±
±±³          ³ExpN4 - Valor de importação do produto para a FCI				  ³±±
±±³          ³ExpC5 - Codigo da FCI do produto 								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³Nil														 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³LOJA701C														  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjCRetFci(cProduto,cLote,cLoteCtl,nVlImp,cFciCod,cClasFisc,nItem)

Local nNwVlImp	:= 0
Local cNwFciCod	:= ""
Local cCodOrig	:= ""
Local lRet 		:= .F.
Local nNwICMS  	:= 0	// Retorno do %ICMS do LOTE/PRODUTO SD5

DEFAULT cProduto 	:= ""
DEFAULT cLote		:= ""
DEFAULT cLoteCtl	:= ""
DEFAULT nVlImp		:= 0
DEFAULT cFciCod		:= ""
DEFAULT cClasFisc	:= ""
DEFAULT nItem		:= 0

If !Empty(cProduto) .AND. nItem > 0
	
	If Rastro(cProduto)
		SPEDRastro2(cLote, cLoteCtl, cProduto, @nNwVlImp, 0, .T., @cNwFciCod,nil,nil ,nil,nil,@cCodOrig )
	Endif

	//So utiliza o retorno da SPEDRastro2() se nao tiver digitado na venda:
	nVlImp	:= Iif( nVlImp > 0, nVlImp, nNwVlImp )
	cFciCod	:= Iif( !Empty(cFciCod), cFciCod, cNwFciCod )

	If !Empty( cCodOrig )
		MaFisAlt("IT_CLASFIS",cCodOrig + Substr(cClasFisc,2),nItem, .T.,,,,/*lRecal*/.T.)
		lRet := .T.
	EndIf

EndIf

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} Lj7SetParceiros
Seta dados Parceiros e itens para envio de e-mail

@param   aSetParceiro				Array com dados para envio de e-mail
@author  Varejo
@version P11.8
@since   02/12/2013
@return  Nil
@obs
@sample
/*/
//-------------------------------------------------------------------
Function Lj7SetParceiros(aSetParceiro)

Default aSetParceiro := {}

aParceiros := aSetParceiro

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} Lj7GetParceiros
Get dados Parceiros e itens para envio de e-mail

@param   aSetParceiro				Array com dados para envio de e-mail
@author  Varejo
@version P11.8
@since   02/12/2013
@return  Nil
@obs
@sample
/*/
//-------------------------------------------------------------------
Function Lj7GetParceiros()
Return aParceiros

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao    | LjChkNFS   ³Autor ³ Vendas e DL			³ Data ³ 04/12/2013	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³verifica se o parametro MV_LJVFNFS existe e qual seu conteudo   ³±±
±±³			 |se o parametro existir e for verdadeiro ou se o parametro nao	  ³±±
±±³			 |foi criado e a filial pertencer ao estado de MG ativa o proces- ³±±
±±³			 |so de geração de NFS na venda futura (legislação estadual)      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1:= LjChkNFS() 											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ N/A                       									  ³±±
±±³          ³                               								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³Logico													 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³LOJA701C / LOJA140											  ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjChkNFS(aSL2)
Local lRet		:= .F.
Local lLjVfNFS	:= SuperGetMV("MV_LJVFNFS",,.F.) //Habilita ou desabilita a utilização da emissao de nota na venda futura.
Local lLjLEG66	:= LJAnalisaLeg(66)[1]
Local lMVLJPVLIB:= .F.
Local cMVLJPVLIB:= AllTrim(SuperGetMV("MV_LJPVLIB",,"1"))
Local cMsg		:= ""
Local nX		:= 0
Local nPos		:= 0

DEFAULT aSL2	:= {}

lMVLJPVLIB:= cMVLJPVLIB == "1"
lRet := lLjVfNFS .And. lMVLJPVLIB .And. lLjLEG66

LjGrvLog( NIL, " Verifica geração de Nota de Simples Faturamento - Parâmetro MV_LJVFNFS", lLjVfNFS)
LjGrvLog( NIL, " Verifica geração de Nota de Simples Faturamento - Parâmetro MV_LJPVLIB", cMVLJPVLIB)
LjGrvLog( NIL, " Verifica geração de Nota de Simples Faturamento - Estado [" + AllTrim(SM0->M0_ESTCOB) + "] do SIGAMAT liberado para uso ? ", lLjLEG66)

If lRet
	If Len(aSL2) > 0
		If (nPos := ascan(aSL2[1], {|x| Alltrim(Upper(x[1])) == "L2_ENTREGA"})) > 0
			For nX := 1 to len(aSL2)
				If aSL2[nX][nPos][2] <> '3'
					lRet := .F.
				Endif
			Next nX
		Endif
	Endif
Else
	
	LjGrvLog( Nil, " Verifica geração de Nota de Simples Faturamento - Retorno : Nota não será gerada")
			
	cMsg := " Para geração de Nota de Simples Faturamento - Configure :" + CHR(10) + CHR(13) +;
			" 1 - MV_LJVFNFS com .T. "  + CHR(10) + CHR(13) +;
			" 2 - MV_LJPVLIB com 1 (pedido deve ser gerado liberado) "  + CHR(10) + CHR(13) +;
			" 3 - Solicitar liberação, a partir de análise de legislação, da UF [ Atualmente a UF " + IIF(lLjLEG66,"","não ") + "está liberada]"
	LjGrvLog( Nil, cMsg)

	If !lMsgChkNFS
		Conout(cMsg)
		lMsgChkNFS := .T.
	EndIf 
Endif

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao    | FEmiteNF  ³Autor ³ Vendas e DL			³ Data ³ 04/12/2013	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³efetua o faturamento de um determinado pedido, que ja exista e  ³±±
±±³			 |esteja devidamente liberado para ser faturado                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ aNf:= FEmiteNF(cPar1, cPar2, cPar3)	  						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cPar1 - Codigo do cliente   									  ³±±
±±³          ³ cPar2 - Codigo da loja do cliente							  ³±±
±±³          ³ cPar3 - numero do pedido a ser faturado						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³Array de dois elementos									 	  ³±±
±±³     	 ³aRet[1] = numero da nota fiscal emitida 					 	  ³±±
±±³     	 ³aRet[2] = serie da nota fiscal emitida					 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³LOJA701C														  ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function FEmiteNF(_cCliente,_cLoja,_cPedido)
Local aAreaAnt	 	:= GetArea()
Local aAreaSC5	 	:= SC5->(GetArea())
Local aAreaSC6	 	:= SC6->(GetArea())
Local aAreaSC9	 	:= SC9->(GetArea())
Local aAreaSE4	 	:= SE4->(GetArea())
Local aAreaSB1	 	:= SB1->(GetArea())
Local aAreaSB2	 	:= SB2->(GetArea())
Local aAreaSF4	 	:= SF4->(GetArea())
Local aRet			:= {"",""}
Local aPvlNfs	 	:= {}
Local _cSeek      	:= ''
Local _nPrcVen    	:= 0
Local _nRegDAK   	:= 0
Local lMostraCtb 	:= .F.
Local lAglutCtb  	:= .F.
Local lCtbOnLine 	:= .F.
Local lCtbCusto  	:= .F.
Local lReajuste  	:= .F.
Local nCalAcrs   	:= 1
Local nArredPrcLis	:= 1
Local cRot       	:= ProcName()
Local cModAtu		:= cModulo
Local nModAtu		:= nModulo
Local _cSerie		:= SuperGetMV('MV_LJVFSER',,'UNI')
Local _cNota		:= ''

If lMostraCtb == Nil
	InitStVa()
Endif

lFaturado   := .F.
cModulo 	:= 'FAT'
nModulo		:= 5

LjGrvLog( _cPedido, "Inicio - Gera Nota de Simples Faturamento -  MV_LJVFNFS. dDataBase: ",dDataBase)

dDataBase := Date() //atualiza a dt para nao ter problemas de divergencia qndo o GrvBatch nao eh reiniciado de um dia para o outro

SC5->(DbSetOrder(3)) //C5_FILIAL, C5_CLIENTE, C5_LOJACLI, C5_NUM
If SC5->(MsSeek(xFilial('SC5')+_cCliente+_cLoja+_cPedido,.F.))
	SC6->(DbSetOrder(1)) //C6_FILIAL, C6_NUM, C6_ITEM, C6_PRODUTO
	_cSeek := xFilial('SC6')+_cPedido
	If SC6->(MsSeek(_cSeek,.F.))
		While SC6->(!Eof()) .And. SC6->C6_FILIAL+SC6->C6_NUM == _cSeek
			SC9->(DBSetOrder(2)) //C9_FILIAL, C9_CLIENTE, C9_LOJA, C9_PEDIDO, C9_ITEM
			If SC9->(MsSeek(xFilial('SC9')+_cCliente+_cLoja+SC6->C6_NUM+SC6->C6_ITEM,.F.))
				// Posiciona na condicao de pagamento
				SE4->(DBSetOrder(1))
				SE4->(MsSeek(xFilial('SE4')+SC5->C5_CONDPAG,.F.))

				// Posiciona no produto
				SB1->(DBSetOrder(1))
				SB1->(MsSeek(xFilial('SB1')+SC6->C6_PRODUTO,.F.))

				// Posiciona no saldo em estoque
				SB2->(DBSetOrder(1))
				SB2->(MsSeek(xFilial('SB2')+SC6->C6_PRODUTO+SC6->C6_LOCAL,.F.))

				// Posiciona no TES
				cTes := SC6->C6_TES
				SF4->(DBSetOrder(1))
				SF4->(MsSeek(xFilial('SF4')+cTes,.F.))

				//Converte o valor unitario em Reais quando pedido em outra moeda
				_nPrcVen := SC9->C9_PRCVEN
				If (SC5->C5_MOEDA <> 1)
					DbSelectArea("SM2")
					SM2->(DbSetOrder(1))
					If SM2->(DbSeek(DTOS(dDataBase)))
						_nPrcVen := SC9->C9_PRCVEN * SM2->M2_MOEDA2
					Else
						_nPrcVen := xMoeda(_nPrcVen,SC5->C5_MOEDA,1,dDataBase)
					EndIf
				EndIf

				// Monta array para gerar a nota fiscal
				Aadd(aPvlNfs,{	SC9->C9_PEDIDO,;
								SC9->C9_ITEM,;
								SC9->C9_SEQUEN,;
								SC9->C9_QTDLIB,;
								_nPrcVen,;
								SC9->C9_PRODUTO,;
								.F.,;
								SC9->(RecNo()),;
								SC5->(RecNo()),;
								SC6->(RecNo()),;
								SE4->(RecNo()),;
								SB1->(RecNo()),;
								SB2->(RecNo()),;
								SF4->(RecNo()),;
								SC6->C6_LOCAL,;
								_nRegDAK,;
								SC9->C9_QTDLIB2})
			EndIf
			SC6->( DBSkip() )
		EndDo
	Else
		CONOUT(STR0175 + trim(_cPedido) ) //"Não pode faturar o pedido "
		LjGrvLog(_cPedido,STR0175 + trim(_cPedido))
		Aviso(cRot,STR0176+trim(_cPedido)+STR0177+trim(_cCliente)+"/"+trim(_cLoja)+STR0178,{"&Abandonar"}) //#STR0176->"Pedido " #STR0177->" do Cliente " #STR0178->" não pode ser faturado."
	EndIf
Else
	CONOUT( STR0176 + trim(_cPedido) + STR0179 ) //#STR0176->"Pedido " #STR0179->"não localizado"
	LjGrvLog(_cPedido,STR0176 + trim(_cPedido) + STR0179)
	Aviso(cRot,STR0176+trim(_cPedido)+STR0177+trim(_cCliente)+"/"+trim(_cLoja)+STR0180,{"&Abandonar"})//#STR0176->"Pedido " #STR0177->" do Cliente " #STR0180->" não econtrado."
EndIf

If !Empty(aPvlNfs)
	LjGrvLog(_cPedido, " Antes da Execução da Função MaPvlNFS ")
	Conout(" Antes da Execução da Função MaPvlNFS - Pedido #" + _cPedido)
	
	LjGrvLog(_cPedido,	" Função MaPvlNFS = variáveis -> aPvlNfs," +;
						" _cSerie	, lMostraCtb , lAglutCtb," +;
						" lCtbOnLine, lCtbCusto	, lReajuste , nCalAcrs ," +;
						" nArredPrcLis, lAtuSA7lECF",;
						{ aPvlNfs	, _cSerie	, lMostraCtb , lAglutCtb ,;
						lCtbOnLine	, lCtbCusto	, lReajuste  , nCalAcrs  ,;
						nArredPrcLis, lAtuSA7lECF })
	
	_cNota := MaPvlNFS(	aPvlNfs		, _cSerie	, lMostraCtb , lAglutCtb ,;
						lCtbOnLine	, lCtbCusto	, lReajuste  , nCalAcrs  ,;
						nArredPrcLis, lAtuSA7lECF)
	_cNota := AllTrim(_cNota)
	
	SX6->(MSRUnlock())
	LjGrvLog(_cPedido, " Depois da Execução da Função MaPvlNFS ")
	Conout(" Depois da Execução da Função MaPvlNFS  - Nota #" + _cNota)
Else
	LjGrvLog(_cPedido, " Array necessário para geração da nota em branco")
EndIf

cModulo	:= cModAtu
nModulo	:= nModAtu

If !Empty(_cNota)
	_cNota := Padr( _cNota, TamSx3('D2_DOC')[1])
	aRet := { _cNota, _cSerie }
	LjGrvLog(_cPedido, " Nota Gerada -> aRet ", aRet)
	DbSelectArea("SF2")
	SF2->(DbSetOrder( 1 )) //F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA+F2_FORMUL+F2_TIPO
	If SF2->(DbSeek( xFilial( "SF2" ) + _cNota + _cSerie + SL1->L1_CLIENTE + SL1->L1_LOJA ))
		RecLock("SF2", .F.)
		SF2->F2_DUPL := _cNota
		SF2->(MsUnLock())
	EndIf
Else
	LjGrvLog(_cPedido, " A nota não foi gerada. ")
EndIf

// Retorna as areas originais
RestArea(aAreaSF4)
RestArea(aAreaSB2)
RestArea(aAreaSB1)
RestArea(aAreaSE4)
RestArea(aAreaSC9)
RestArea(aAreaSC6)
RestArea(aAreaSC5)
RestArea(aAreaAnt)

LjGrvLog( _cPedido, "Fim - Gera Nota de Simples Faturameto -  MV_LJVFNFS. dDataBase: ",dDataBase)
LjGrvLog( _cPedido, "Fim - Gera Nota de Simples Faturameto -  MV_LJVFNFS. cNota: ",_cNota)

If !Empty(_cNota)
	aRet := { Padr( _cNota, TamSx3('D2_DOC')[1]), _cSerie }
	LjGrvLog(_cPedido, " Nota Gerada -> aRet ", aRet)
Else
	LjGrvLog(_cPedido, " A nota não foi gerada. ")
EndIf

Return aRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao    | InitStVa  ³Autor ³ Vendas e DL			³ Data ³ 04/12/2013	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Salva o conteudo das variaveis do pergunte efetua a leitura 	  ³±±
±±³			 |do pergunte de faturamento, preparando as variaveis utilizadas  ³±±
±±³			 |na função de emissao da nota fiscal de saida, restaurando o con-³±±
±±³			 |teudo das variaveis de pergunte em seguida.					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ N/A						  									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³N/A														 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³LOJA701C														  ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function InitStVa()

Local aPerg			:= {}
Local _nX			:= 0

Private xVar
Private cNomVar		:= ""

For _nX := 1 to 60
	cNomVar := "MV_PAR" + StrZero( _nX )
	xVar := &(cNomVar)
	aadd( aPerg, xVar )
Next _nX

Pergunte('MT460A',.F.)

lMostraCtb  := MV_PAR01 == 1
lAglutCtb   := MV_PAR02 == 1
lCtbOnLine  := MV_PAR03 == 1
lCtbCusto   := MV_PAR04 == 1
lReajuste   := MV_PAR05 == 1
LAtuSA7lECF := .F.

For _nX := 1 to 60
	cNomVar := "MV_PAR" + StrZero( _nX )
	xVar := aPerg[ -nX ]
	&(cNomVar) := xVar
Next _nX

Return Nil

//--------------------------------------------------------
/*/{Protheus.doc} LjItGE
Funcao responsavel em verificar se o item eh do tipo Garantia Estendida
@param   cProduto	Codigo do Produto que sera validado
@author  Varejo
@version P11.5
@since   17/01/2014
@return  lRet
/*/
//-------------------------------------------------------
Function LjItGE(cProduto)

Local lRet		:= .F.								//Define se o item eh do tipo Garantia Estendida
Local cTipoGE	:= SuperGetMV("MV_LJTPGAR",,"GE")	//Tipo do produto Garantia Estendida
Local nTmB1Tipo	:= 0								//Tamanho do campo B1_TIPO
Local aB1Area	:= SB1->( GetArea() )

Default cProduto:= ""

//armazenamos em cache o tamanho do campo B1_TIPO
nTmB1Tipo := GetSx3Cache("B1_TIPO","X3_TAMANHO")

cTipoGE := PadR(cTipoGE, nTmB1Tipo)

If nModulo == 23
	DbSelectArea("SBI")
	SBI->( DbSetOrder(2) )	//BI_FILIAL + BI_TIPO + BI_COD
	lRet := SBI->( MsSeek(xFilial("SBI") + cTipoGE + cProduto) )
Else
	DbSelectArea("SB1")
	SB1->( DbSetOrder(2) )	//B1_FILIAL + B1_TIPO + B1_COD
	If SB1->( MsSeek(xFilial("SB1") + cTipoGE + cProduto) )
		lRet := .T.
	EndIf
EndIf

RestArea(aB1Area)

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LjVFEGeraPed ºAutor³Vendas Clientes     º Data ³  05/05/14  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Gera Pre-Nota de Entrada e Pedido de Venda Para VFE - Venda º±±
±±º          ³Fora do Estad  											  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ExpA1 := LjVFEGeraPed( ExpA1 ) 						      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpC1 - Array com os pedidos					              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ Nil														  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SigaLoja/FrontLoja                                         º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjVFEGeraPed( aPedido )
Local nContPed	:= 0							// Contador Pedidos
Local nI 			:= 0							// Contador
Local nJ 			:= 0							// Contador
Local nY			:= 0							// Contador
Local nPos			:= 0							// Posicao
Local nOpc 		:= 0							// Opcao execauto
Local aAreaSC5 	:= SC5->( GetArea() )		// AreaSC5
Local aAreaSC6 	:= SC6->( GetArea() )		// AreaSC6
Local aAreaSC9 	:= SC9->( GetArea() )		// AreaSC6
Local cFilBkp		:= cFilAnt						// Bkp Filial
Local cFilPed		:= ""							// Filial Pedido
Local cNumSC5		:= ""							// Numero do Pedido	- Inclusao
Local nTamC6It	:= TamSx3("C6_ITEM")[1]		//Tamanho do Campo C6_ITEM
Local cMay			:= ""							// Verificar se nao esta utilizando a numeração
Local cNFiscal	:= ""							// Numeracao Nota Entrada
Local aCabPed		:= {}							// Cabeçalho Pedido
Local aLinhaPed	:= {}							// (1)Item Pedido
Local aItensPed	:= {}							// Itens Pedido
Local aSF1			:= {}							// Cabecalho Entrada
Local aSD1			:= {}							// Itens Entrada
Local cFilSC6		:= xFilial("SC6")				// Armazena Filial SC6
Local lLiber 		:= .F.							// Compatibilizacao com o SIGAFAT
Local lTransf		:= .F.      					// Compatibilizacao com o SIGAFAT
Local lLiberOk 	:= .T.							// Compatibilizacao com o SIGAFAT
Local lResidOk 	:= .T.							// Compatibilizacao com o SIGAFAT
Local lFaturOk 	:= .F.							// Compatibilizacao com o SIGAFAT
Local lTLVReg  	:= .F.							// Compatibilizacao com o SIGAFAT
Local cMV_CLIPAD	:= PadR(SuperGetMV("MV_CLIPAD"),TamSX3("F1_FORNECE")[1])	// Cliente padrao
Local cMV_LOJAPAD	:= PadR(SuperGetMV("MV_LOJAPAD"),TAMSX3("F1_LOJA")[1])		// Loja do cliente padrao
Local cCondPad	:= PadR(SuperGetMV("MV_CONDPAD"),TamSX3("L1_CONDPG")[1])	// Condicao de pagamento padrao
Local nTent 		:= 0										// Tentativas para pegar a numeracao do SC5
Local nSaveSx8 		:= GetSx8Len()								// Numeracao do SX8

Private lMSErroAuto	:= .F.						//VerIfica se ocorreu algum erro durante a Geracao do PV
Private aXCabec:= {}
Private aXItens:= {}
Private aLinha:= {}


Default aPedido := {}

If SuperGetMv("MV_LJVFE", Nil, .F.) .AND. SC5->(ColumnPos("C5_FILVFE")) > 0

	DbSelectArea("SC5")
	DbSetOrder(1)

	For nContPed := 1 To Len(aPedido)

		If DbSeek(xFilial("SC5")+aPedido[nContPed][1])

			If !Empty(SC5->C5_FILVFE)

				/*
					Entrada
				*/
				// Troca Filial
				cFilAnt := SC5->C5_FILVFE

				cNFiscal := MA461NumNf(.T.,"",cNFiscal)

				AADD(aXCabec,{"F1_FILIAL"	, xFilial("SF1")	, Nil})
				AADD(aXCabec,{'F1_DOC'		, cNFiscal			, Nil})
				AADD(aXCabec,{'F1_SERIE'		, '1'				, Nil})
				AADD(aXCabec,{'F1_FORNECE'	, cMV_CLIPAD		, Nil})
				AADD(aXCabec,{'F1_LOJA'		, cMV_LOJAPAD		, Nil})
				AADD(aXCabec,{'F1_EMISSAO'	, dDataBase		, Nil})
				AADD(aXCabec,{'F1_COND'		, cCondPad			, Nil})

				DbSelectArea("SC6")
				DbSetOrder(1)
				If DbSeek(cFilSC6+aPedido[nContPed][1])

					While SC6->(!Eof()) .AND. SC6->C6_FILIAL == cFilSC6 .AND. SC6->C6_NUM == aPedido[nContPed][1]

						aLinha := {}

						AADD(aLinha,{'D1_FILIAL'		, xFilial("SD1")			, Nil})
						AADD(aLinha,{'D1_DOC'		, cNFiscal					, Nil})
						AADD(aLinha,{'D1_SERIE'		, "1"						, Nil})
						AADD(aLinha,{'D1_FORNECE'	, cMV_CLIPAD				, Nil})
						AADD(aLinha,{'D1_LOJA'		, cMV_LOJAPAD				, Nil})
						AADD(aLinha,{'D1_ITEM'		, SC6->C6_ITEM			, Nil})
						AADD(aLinha,{'D1_COD'		, SC6->C6_PRODUTO			, Nil})
						AADD(aLinha,{'D1_QUANT'		, SC6->C6_QTDVEN			, Nil})
						AADD(aLinha,{'D1_VUNIT'		, SC6->C6_PRCVEN			, Nil})
						AADD(aLinha,{'D1_TOTAL'		, SC6->C6_VALOR			, Nil})

						AADD(aXItens, aLinha)

						SC6->( DbSkip() )

					EndDo

				EndIf

				MSExecAuto({|x,y,z| MATA140(x,y,z)}, aXCabec, aXItens, 3)

				If lMsErroAuto
					mostraerro()
				EndIf

				/*
					Saída
				*/
				// Armazena Cab/SC5
				aCabPed := {}
				Aadd(aCabPed,{ "C5_FILIAL",		""						,NIL })
				Aadd(aCabPed,{ "C5_NUM",			""						,NIL })
				Aadd(aCabPed,{ "C5_TIPO",		"N"						,NIL })
				Aadd(aCabPed,{ "C5_CLIENTE",	SC5->C5_CLIENTE		,NIL })
				Aadd(aCabPed,{ "C5_LOJACLI",	SC5->C5_LOJACLI		,NIL })
				Aadd(aCabPed,{ "C5_CLIENT",		SC5->C5_CLIENT		,NIL })
				Aadd(aCabPed,{ "C5_LOJAENT",	SC5->C5_LOJAENT		,NIL })
				Aadd(aCabPed,{ "C5_TRANSP",		SC5->C5_TRANSP		,NIL })
				Aadd(aCabPed,{ "C5_VEICULO",	SC5->C5_VEICULO		,NIL })
				Aadd(aCabPed,{ "C5_TIPOCLI",	SC5->C5_TIPOCLI		,NIL })
				Aadd(aCabPed,{ "C5_EMISSAO",	SC5->C5_EMISSAO		,NIL })
				Aadd(aCabPed,{ "C5_VEND1",		SC5->C5_VEND1			,NIL })
				Aadd(aCabPed,{ "C5_CONDPAG",	SC5->C5_CONDPAG		,NIL })
				Aadd(aCabPed,{ "C5_ORCRES",		SC5->C5_ORCRES		,NIL })
				Aadd(aCabPed,{ "C5_FRETE",		SC5->C5_FRETE			,NIL })
				Aadd(aCabPed,{ "C5_SEGURO",		SC5->C5_SEGURO		,NIL })
				Aadd(aCabPed,{ "C5_DESPESA",	SC5->C5_DESPESA		,NIL })
				Aadd(aCabPed,{ "C5_TPFRETE",	SC5->C5_TPFRETE		,NIL })
				Aadd(aCabPed,{ "C5_DESC1"	, 	SC5->C5_DESC1			,NIL })
				Aadd(aCabPed,{ "C5_DESCONT"	,	SC5->C5_DESCONT		,NIL })
				Aadd(aCabPed,{ "C5_MOEDA",		SC5->C5_MOEDA			,NIL })
				Aadd(aCabPed,{ "C5_TIPLIB",		SC5->C5_TIPLIB		,NIL })
				Aadd(aCabPed,{ "C5_TPCARGA",	SC5->C5_TPCARGA		,NIL })
				Aadd(aCabPed,{ "C5_GERAWMS",	SC5->C5_GERAWMS		,NIL })
				Aadd(aCabPed,{ "C5_MENPAD"	,	SC5->C5_MENPAD		,NIL })
				If  SC5->( FieldPos("C5_ECPRESN") > 0 )
					Aadd(aCabPed,{ "C5_ECPRESN",	SC5->C5_ECPRESN	,NIL })
				EndIf


				// Troca de Filial do sistema
				cFilAnt := SC5->C5_FILVFE

				//Numeração Pedido
				cNumSC5 := CRIAVAR("C5_NUM")
				cMay := "SC5"+ALLTRIM(xFilial("SC5"))+cNumSC5
				FreeUsedCode()
				While SC5->(DbSeek(xFilial("SC5")+cNumSC5)) .OR. !MayIUseCode(cMay)
					If ++nTent > 20
						FreeUsedCode()
					EndIf
					If nTent > 50 //Se nao conseguir ate 50 vezes, aborta o sistema.
						FreeUsedCode()
						Final("Impossivel gerar numero sequencial de PEDIDO correto. INFORME ESSA MENSAGEM PARA O DEPARTAMENTO DE TI.")
					EndIf
					cNumSC5 := CRIAVAR("C5_NUM")
					cMay := "SC5"+ALLTRIM(xFilial("SC5"))+cNumSC5
				End
				If __lSX8
					While (GetSX8Len() > nSaveSx8)
						ConfirmSx8()
					End
				Endif

				//Troca Filial do pedido
				nPos := aScan( aCabPed , {|x| Alltrim(Upper(x[1])) == "C5_FILIAL"} )
				aCabPed[nPos][2] := xFilial("SC5")

				//Troca numeração
				nPos := aScan( aCabPed , {|x| Alltrim(Upper(x[1])) == "C5_NUM"} )
				aCabPed[nPos][2] := cNumSC5

				//Grava Cabeçalho Pedido de Venda
 				If Len(aCabPed) > 0
					RecLock("SC5",.T.)
					For nJ := 1 To Len(aCabPed)
				 		SC5->&(aCabPed[nJ][1])	:= aCabPed[nJ][2]
				   	Next nJ
				Endif
				FkCommit() // Commit para integridade referencial do SC5

				// Itens Pedido
				DbSelectArea("SC6")
				DbSetOrder(1)
				If DbSeek(cFilSC6+aPedido[nContPed][1])

					While SC6->(!Eof()) .AND. SC6->C6_FILIAL == cFilSC6 .AND. SC6->C6_NUM == aPedido[nContPed][1]

						aLinhaPed := {}

						Aadd(aLinhaPed,{ "C6_FILIAL",	xFilial("SC5")	   				,NIL })
						Aadd(aLinhaPed,{ "C6_NUM",		cNumSC5							,NIL })
						Aadd(aLinhaPed,{ "C6_ITEM",		SC6->C6_ITEM						,NIL })
						Aadd(aLinhaPed,{ "C6_PRODUTO",	SC6->C6_PRODUTO		  			,NIL })
						Aadd(aLinhaPed,{ "C6_DESCRI",	SC6->C6_DESCRI					,NIL })
						Aadd(aLinhaPed,{ "C6_UM",		SC6->C6_UM							,NIL })
						Aadd(aLinhaPed,{ "C6_QTDVEN",	SC6->C6_QTDVEN					,NIL })
						Aadd(aLinhaPed,{ "C6_QTDLIB",	SC6->C6_QTDLIB				 	,NIL })
						Aadd(aLinhaPed,{ "C6_PRCVEN",	SC6->C6_PRCVEN					,NIL })
						Aadd(aLinhaPed,{ "C6_VALOR",	SC6->C6_VALOR						,NIL })
						Aadd(aLinhaPed,{ "C6_TES",		SC6->C6_TES						,NIL })
						Aadd(aLinhaPed,{ "C6_CF",		SC6->C6_CF							,NIL })
						Aadd(aLinhaPed,{ "C6_LOCAL",	SC6->C6_LOCAL						,NIL })
						Aadd(aLinhaPed,{ "C6_CLI",		SC6->C6_CLI 						,NIL })
						Aadd(aLinhaPed,{ "C6_LOJA",		SC6->C6_LOJA 						,NIL })
						Aadd(aLinhaPed,{ "C6_PRUNIT",	SC6->C6_PRUNIT					,NIL })
						Aadd(aLinhaPed,{ "C6_TPOP",		SC6->C6_TPOP						,NIL })
						Aadd(aLinhaPed,{ "C6_LOTECTL",	SC6->C6_LOTECTL      			,NIL })
						Aadd(aLinhaPed,{ "C6_ENTREG",	SC6->C6_ENTREG					,NIL })
						Aadd(aLinhaPed,{ "C6_CLASFIS",	SC6->C6_CLASFIS					,NIL })
						If SC6->(FieldPos("C6_NLOTE")) > 0
							Aadd(aLinhaPed,{ "C6_NLOTE",	SC6->C6_NLOTE			 	   	,NIL })
						EndIf
						If SC6->(FieldPos("C6_VDMOST")) > 0
							Aadd(aLinhaPed,{ "C6_VDMOST",	 SC6->C6_VDMOST				,NIL })
						EndIf
						If SC6->(FieldPos("C6_VDOBS")) > 0
							Aadd(aLinhaPed,{ "C6_VDOBS",	 SC6->C6_VDOBS				,NIL })
						EndIf
						If SC6->(FieldPos("C6_TURNO")) > 0
							Aadd(aLinhaPed,{ "C6_TURNO",	SC6->C6_TURNO					,NIL })
						EndIf
						If SC6->(FieldPos("C6_ITEMGAR")) > 0
							Aadd(aLinhaPed,{ "C6_ITEMGAR",	SC6->C6_ITEMGAR				,NIL })
						EndIf
						If SC6->(FieldPos("C6_ORCGAR")) > 0
							Aadd(aLinhaPed,{ "C6_ORCGAR",	SC6->C6_ORCGAR				,NIL })
						EndIf
						If SC6->(FieldPos("C6_FCICOD")) > 0
							Aadd(aLinhaPed,{ "C6_FCICOD",	SC6->C6_FCICOD				,NIL })
						EndIf
						If SC6->(FieldPos("C6_VLIMPOR")) > 0
							Aadd(aLinhaPed,{ "C6_VLIMPOR",	SC6->C6_VLIMPOR				,NIL })
						EndIf

						Aadd(aItensPed, aLinhaPed)

						SC6->( DbSkip() )

					EndDo

					For nI := 1 To Len(aItensPed)
						RecLock("SC6",.T.)
						For nY := 1 to Len(aItensPed[nI])
							If  (FieldPos(aItensPed[nI][nY][1]) > 0)
								SC6->( FieldPut(FieldPos(aItensPed[nI][nY][1]), aItensPed[nI][nY][2]) )
							EndIf
				 		Next nY
				 		SC6->(MsUnlock())
					   	FkCommit() // Commit para integridade referencial do SC6

		   	        	RecLock("SC6",.F.)
		   	        	MaAvalSC6("SC6",1,"SC5",lLiber,lTransf,@lLiberOk,@lResidOk,@lFaturOk,,,,,,lTLVReg)
						SC6->(MsUnlock())

				   	Next nI

				EndIf

				MaAvalSC5("SC5",1,lLiber,lTransf,@lLiberOk,@lResidOk,@lFaturOk)
				SC5->(MsUnlock())

			EndIf

		EndIf

		cFilAnt := cFilBkp

	Next nContPed

EndIf

cFilAnt := cFilBkp

RestArea(aAreaSC5)
RestArea(aAreaSC6)
RestArea(aAreaSC9)

Return

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³Lj701CIPI   º Autor ³ Vendas CRM         º Data ³  10/03/2014 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Retorna o preço de venda do Item (abatido o valor do IPI)   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cProduto - Código do Produto                                 º±±
±±º          ³ nPrecoIPI - Preço do IPI                                     º±±
±±º          ³ lMVRNDIPI - Arredonda/Trunca IPI                             º±±
±±º          ³ cTES - TES e-commerce                                        º±±
±±º          ³ nCasasIPI - Casas do IPI                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ TOTVS                                                        º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Lj701CIPI(cProduto, nPrecoIPI, lMVRNDIPI, cTES, ;
                          nCasasIPI)
Local aArea 		:= GetArea()  //workarea
Local nValIPIEn 	:= 0 //Valor IPI Embutido
Local aAreaSB1 	:= NIL //Area SB1
Local aAreaSF4 	:= NIL //Area SF4

Default nPrecoIPI := 0
Default cProduto := ""
Default lMVRNDIPI := SuperGetMV("MV_RNDIPI", NIL, .F.)
Default cTES := SuperGetMV("MV_LJTESPE", NIL, "501")
Default nCasasIPI := 0


aAreaSB1 := SB1->(GetArea())

DbSelectArea("SB1")
SB1->( DbSetOrder(1) )	//B1_FILIAL + B1_COD
If SB1->( DbSeek(xFilial("SB1") + cProduto) )  .AND. Substr(cTES,1, 1) <> "&"
	//Busca na TES de pedido se está sinalizado para calcular IPI
	aAreaSF4 := SF4->(GetArea())
	//Busca a TES do Item

	SF4->(DbSetOrder(1)	)
	If SF4->(DbSeek(xFilial("SF4") + cTES ))  .And. SF4->(!Empty(F4_IPI) .And. F4_IPI <> "N")

		nValIPIEn	:=  nPrecoIPI   * ( SB1->B1_IPI/100)	//Apura a Base do IPI

		If lMVRNDIPI
			nValIPIEn := Round(nValIPIEn,nCasasIPI)     //Trabalha com arredondamento
		Else
			nValIPIEn := NoRound(nValIPIEn,nCasasIPI)   //Trabalha com truncamento
		EndIf

	EndIf
	RestArea(aAreaSF4)
EndIf

RestArea(aAreaSB1)

RestArea(aArea)

Return nValIPIEn

//------------------------
/*/{Protheus.doc} Lj701CNFCe
Efetua a transmissão da NFC-e para o TSS (TSS->Sefaz).
@Type Function
@param   cCodFil	, caracter , Filial da venda realizada
@param   cNumOrc	, caracter , Numero do orçamento
@param   cDoc		, caracter , Numero do documento Nfc-e
@param   cSerie		, caracter , Serie do documento Nfc-e
@param   cPDV		, caracter , Pdv da venda
@param   lTefOk		, lógico , Operação TEF
@param   cKeyNFCe	, caracter , Chave de acesso NFc-e TSS
@author  Varejo
@version P11
@since   07/01/2015
@return  lNFCeRet	, lógico , .T. = Sucesso na transmissão / .F. = Erro na transmissão da NFC-e
/*/
//------------------------
Static Function Lj701CNFCe(	cCodFil, cNumOrc, cDoc, cSerie,	cPDV, lTefOk, cKeyNFCe, cMsgErro )

Local nNFCeRet	:= 0
Local lNFCeRet	:= .T.
Local lLjGrvOn  := SuperGetMV("MV_LJGRVON", Nil, .T.)
Local aNfceSL1	:= {}
Local lAutoExC	:= IsBlind()	// Verifica se a rotina sera executada via execauto ou nao
Local lRetNCC	:= .T. 			//indica se as funcoes de NCC foram executadas com sucesso (NFC-e)
Local cDocCred	:= ""			//PREFIXO+NUM+PARCELA+TIPO+LOJA do titulo CR que sera usado para compensacao (NFC-e)
Local nRecnoSE1	:= 0			//R_E_C_N_O_ do titulo do tipo CR que foi gerado (NFC-e)
Local nMsDecimal:= MsDecimais(1)

Default cCodFil	:= ""
Default cNumOrc	:= ""
Default cDoc	:= ""
Default cSerie	:= ""
Default cPDV	:= ""
Default lTEFOk	:= .T.
Default cKeyNFCe:= ""
Default cMsgErro:= ""

//Processa a NFC-e
nNFCeRet := LjNFCeGera(cCodFil, cNumOrc, @cKeyNFCe, Nil, Nil, @cMsgErro)

LjGrvLog(cNumOrc,"Retorno do envio da transmissao da NFC-e ",nNFCeRet)
LjGrvLog(cNumOrc,"Chave gerada na transmissao da NFC-e ",cKeyNFCe)

aNFCeSL1 := { {"L1_KEYNFCE" , cKeyNfce	} }
Lj7GeraSL("SL1", aNfceSL1, .F.)

/*
Situacoes nNFCeRet:
( 1 ) > NFC-e processada com sucesso
( 0 ) >	NFC-e enviada para o TSS, porem nao houve resposta do TSS (TSS offline)
(-1 ) > NFC-e rejeitada
*/

If nNFCeRet <> 1

	lNFCeRet := .F.

	If !lAutoExC
		MsgInfo(STR0196,STR0147) //"Houve problema na transmissão da NFC-e. Por favor, efetuar as devidas alterações ou gravar este como orçamento." //"Atenção"
	Else
		ConOut(STR0196 + "(Orc: " + SL1->L1_NUM + " - Doc.: " + cDoc + ")") //"Houve problema na transmissão da NFC-e. Por favor, efetuar as devidas alterações ou gravar este como orçamento."
	EndIf

	LjGrvLog(cNumOrc,"NFCe ERRO :",cMsgErro)

	If SLX->(ColumnPos("LX_MODDOC")) == 0 //Caso o campo nao exista
		//Altera campos chaves para o cancelamento da NFC-e
		aSL1 := { {"L1_STORC", "A"  },;
				  {"L1_SITUA", "RX" },;
				  {"L1_TIPO" , "V"	} }

		Lj7GeraSL( "SL1", aSL1, .F., .F. )
	EndIf

ElseIf !lLjGrvOn .AND. nNccUsada > 0 .And. !IsInCallStack("Lj7Pedido")

	// O bloco abaixo somente devera ser executado quando o sistema estiver configurada para emissao da NFC-e
	// Pois nesse caso, o sistema nao efetua a venda de forma sincrona, sendo assim, quando se paga uma venda com
	// uma NCC, a baixa da mesma deve ser realizada, antes do processamento da venda que eh realizado pelo LjGrvBatch

	//Gera nova NCC para o cliente, caso seja necessario

	LjGrvLog(cNumOrc,"Vai realizar a baixa das NCCs",aNCCItens)

	lRetNCC := StaticCall( WSFRTNCC	, FrtIncluiNCC		,;
					aNCCItens		, 	nNccUsada		, nNccGerada		, SL1->L1_DOC		,;
					SL1->L1_SERIE	,	SL1->L1_OPERADO	, SL1->L1_EMISSAO	, SL1->L1_CLIENTE	,;
					SL1->L1_LOJA	)

	LjGrvLog(cNumOrc,"Retorno se incluiu NCC",nNccGerada)

	If lRetNCC
		//Inclui tipo CR para as NCCs usadas na venda
		lRetNCC := StaticCall( WSFRTNCC		, FrtIncluiCR		,;
							SL1->L1_SERIE	, @cDocCred			, @nRecnoSE1	, SL1->L1_DOC		,;
							SL1->L1_SERIE	, SL1->L1_CLIENTE	, SL1->L1_LOJA	, SL1->L1_CREDITO	,;
							SL1->L1_OPERADO	, nNccUsada			, nNccGerada   	, aNccItens			)

			LjGrvLog(cNumOrc,"Retorno se incluiu o CR",nNccGerada)

			//Efetua a compensacao
			If lRetNCC
				
				StaticCall(	LOJXFUNC , LjInMovNCC	,;
							aNccItens, nMsDecimal	, cDocCred , nRecnoSE1	,;
							nNccUsada, nNccGerada	, SL1->L1_NUM )

				LjGrvLog(cNumOrc,"Retorno se conseguiu baixar a NCC")
			Else
				MsgStop(STR0193) //"Não foi possível realizar a inclusão do título do tipo CR referente a NCC"
			EndIf
	Else
		MsgStop(STR0194) //"Não foi possível realizar a inclusão da Nota de Crédito"
	EndIf
EndIf

//limpa o objeto oNFCe que é instanciado no LOJNFCE.PRW
If ExistFunc("LjNFCeFree")
	LjNFCeFree()
EndIf

Return lNFCeRet

//------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Lj7DupNfce
Duplica os registro de SL1, SL2 e SL4 da venda atual para posteriormente ser cancelada.
Neste caso o registro novo é quem será utilizado para servir de cancelamento da NFC-e,
e o registro original será mantido para finalização da venda.
Obs.: É restaurada as alias e tabeals da venda original.
@type Function
@author  Varejo
@version P11
@since   19/01/2015
@return  nNewRecno , numerico , Numero de Recno do novo registro da tabela SL1
/*/
//------------------------------------------------------------------------------------------------
Static Function Lj7DupNFCe()

Local aAreaSL1 := SL1->(GetArea())
Local aAreaSL2 := SL2->(GetArea())
Local aAreaSL4 := SL4->(GetArea())
Local aSL1     := {}
Local nNewRecno:= 0

//Replicar tabelas da venda (SL1, SL2 e SL4), seu retorno é o recno do novo registro na tabela SL1
If ExistFunc("F271GCopyVenda")
	nNewRecno := F271GCopyVenda(SL1->(L1_FILIAL+L1_NUM))
	SL1->(DBGoTo( nNewRecno ))

	//Altera campos chaves para o cancelamento da NFC-e (nota) atual que foi rejeitada (registro novo ["copia"])
	aSL1 := { {"L1_STORC", "A"  },;
			  {"L1_SITUA", "RX" },;
			  {"L1_TIPO" , "V"	}}
	Lj7GeraSL( "SL1", aSL1, .F., .F. )

	RestArea(aAreaSL1)
	RestArea(aAreaSL2)
	RestArea(aAreaSL4)
Else
	ConOut(STR0195) //"O Fonte FRTA271G.PRW não esta atualizado. Favor atualiza-lo."
EndIf

Return nNewRecno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7LocTribºAutor  ³Vendas Clientes     º Data ³ 01/07/2014  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Recalculo dos valores totais para atualizacao do orcamento  º±±
±±º          ³e rateio dos itens   (Localizado)                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA (Localizado)                                      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Lj7LocTrib( aTaxJuros )
Local nPos         	:= 0
Local aSL1 			:= {}					// Array para gravar as informacoes no SL1
Local nI 			:= 0
Local lMvLjJurCc	:= .F.					// Verifica se o juros da administradora esta ativo
Local nNFTOTAL 		:= 0
Local nVlrFSD		:= 0					// Valor do frete + seguro + despesas
Local nitem 		:= 0

//Valida se pode usa Taxa Administrativa por Cartão de Crédito
If SuperGetMv("MV_LJJURCC",NIL,.F.) .AND. (aTaxJuros[1] > 0)
	lMvLjJurCc := .T.
EndIf

If MaFisFound("NF") .And. lMvLjJurCc
	nVlrFSD	:= Lj7CalcFrete()

	//Atuualiza campos da tabela SL2
	DbSelectArea("SL2")
	SL2->( DbSetOrder(1) )
	SL2->( DbSeek(xFilial("SL2") + SL1->L1_NUM) )
	While !SL2->(Eof()) .AND. xFilial("SL2") + SL1->L1_NUM == SL2->L2_FILIAL + SL2->L2_NUM
		nItem++
		RecLock("SL2", .F.)

		If MaFisFound("IT", nItem)
			REPLACE L2_VALFRE  WITH MaFisRet(nItem,"IT_FRETE")
			REPLACE L2_SEGURO  WITH MaFisRet(nItem,"IT_SEGURO")
			REPLACE L2_DESPESA WITH MaFisRet(nItem,"IT_DESPESA")
			REPLACE L2_CF 	   With MaFisRet(nItem,"IT_CF")
			REPLACE L2_VLRITEM WITH MaFisRet(nItem, "IT_VALMERC") - MaFisRet(nItem, "IT_DESCONTO")
			REPLACE L2_VRUNIT  WITH NoRound( SL2->L2_VLRITEM / MaFisRet(nItem, "IT_QUANT") , TamSX3("D2_PRCVEN")[2] )
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualizacao dos campos do SL2 com o calculo dos impostos retornados   ³
		//³ pela MATXFIS                                                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    For nI := 1 To Len(aImpsSL2[nItem][3])
	    	If aImpsSL2[nItem][3][nI][4] > 0 .AND. aImpsSL2[nItem][3][nI][3] > 0
	        	REPLACE &(aImpsSL2[nItem][3][nI][6]) WITH aImpsSL2[nItem][3][nI][4]   //Valor do imposto
	     		REPLACE &(aImpsSL2[nItem][3][nI][7]) WITH aImpsSL2[nItem][3][nI][3]   //Base do imposto
				REPLACE &("L2_ALQIMP"+Substr(aImpsSL2[nItem][3][nI][7],10,1)) WITH MaFisRet(nItem,"IT_ALIQIV"+Substr(aImpsSL2[nItem][3][nI][7],10,1))
			EndIf
		Next nI

		SL2->( MsUnlock() )
		SL2->(DbSkip())
	End

	DbSelectArea( "SL1" )
	nNFTOTAL := MaFisRet(,"NF_TOTAL")
	aSL1 := {}
	aAdd( aSL1, { "L1_VLRTOT"	, A410Arred( ( nNFTOTAL - nVlrFSD ), "L1_VALIMP1",nMoedaCor) } )
	aAdd( aSL1, { "L1_VALBRUT"	, A410Arred( ( nNFTOTAL - nVlrFSD ), "L1_VALIMP1",nMoedaCor) } )
	aAdd( aSL1, { "L1_VLRLIQ"	, nNFTOTAL } )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se existe os campos de base e valor de impostos	se nao tem carregado na array aSL1 incluir zerado para nao  ³
	//³ficar sujeira quando eh modificado um orçamento ja gravado                                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nI := 1 To 9
		cValImpCam := "L1_VALIMP" + StrZero(nI,1)
		cBasImpCam := "L1_BASIMP" + StrZero(nI,1)
		If SL1->( FieldPos( cValImpCam ) ) > 0 .AND. SL1->( FieldPos( cBasImpCam ) ) > 0
			If Ascan(aSL1,{|x| AllTrim(x[1]) == cValImpCam}) == 0 .AND. Ascan(aSL1,{|x| AllTrim(x[1]) == cBasImpCam}) == 0
				Aadd(aSL1,{cValImpCam,0})   //Valor do imposto
				Aadd(aSL1,{cBasImpCam,0})   //Base de imposto
			EndIf
		EndIf
	Next nI

	Lj7GeraSl( "SL1", aSL1, .F., .F. )

	aSL1 := {}

	//Atualiza o valor e base dos campos de impostos (L1_VALIMP1, L1_VALIMP2, L1_VALIMP3,...L1_BASIMP1, L1_BASIMP2, L1_BASIMP2,...)
    For nI := 1 To Len(aImpsSL1)
    	If aImpsSL1[nI][3] > 0 .AND. aImpsSL1[nI][5] > 0

    		//Valor do imposto
    		nPos := Ascan(aSL1,{|x| Trim(x[1]) == aImpsSL1[nI][2]})
			If nPos > 0
				aSL1[nPos][2] += aImpsSL1[nI][3]
			Else
				Aadd(aSL1,{aImpsSL1[nI][2],aImpsSL1[nI][3]})
			EndIf

    		//Base do imposto
    		nPos := Ascan(aSL1,{|x| Trim(x[1]) == aImpsSL1[nI][4]})
			If nPos > 0
				aSL1[nPos][2] += aImpsSL1[nI][5]
			Else
				Aadd(aSL1,{aImpsSL1[nI][4],aImpsSL1[nI][5]})
			EndIf
		EndIf
	Next nI

	Lj7GeraSl( "SL1", aSL1, .F., .F. )

EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjVlNumDocºAutor  ³ VArejo             º Data ³ 15/09/2014  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida numero do documento digitado.                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA (Localizacao Argentina)                           º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LjVlNumDoc(cNumDoc)
Local lRet 		:= .T.
Local cDigValid := "0123456789" //Digitos validos
Local nX 		:= 0

cNumDoc := AllTrim(cNumDoc)

If !Empty(cNumDoc)
	For nX:=1 to Len(cNumDoc)
		If !(SubStr(cNumDoc,nX,1) $ cDigValid)
			lRet := .F.
			MsgAlert(STR0184) //"Informe apenas valores numéricos"
			Exit
		EndIf
	Next nX
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjTelaCardºAutor  ³ Varejo             º Data ³ 15/09/2014  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Aplica o acrescimo do cartao de credito nas referencias da º±±
±±º          ³ MatxFis e efetua os recalculos para saber o valor Total da º±±
±±º          ³ venda e exibe a tela com os valores a serem cobrados no(s) º±±
±±º          ³ cartoes.                                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA (Localizacao)                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LjTelaCard(aTaxJuros, aPgtosBKP, aPgSintBKP, nTotParBkp, nSubTotBkp, nTotalBkp, aDadosCF, cTipoCli, nSaveSx8)
Local lRet 		:= .T.
Local aColunas	:= { {STR0185,STR0186,STR0187,STR0188,STR0189,STR0190},{30,100,40,40,25,30} } //"ID Cartão"###"Administradora"###"Forma de Pagamento"###"Data"###"Parcelas"###"Valor"
Local oDlg    	:= Nil
Local oBrowse 	:= Nil
Local aItCartoes:= {}
Local lTelaOK   := .F.
Local aBKPImpsV := aClone(aTotImpsV)
Local nitem 	:= 1
Local n_ValTotal:= 0
Local n_VlrTxJur:= 0
Local nProp 	:= 0
Local nAcrecProp:= 0
Local nX 		:= 0
Local nPos 		:= 0
Local nValImpSum:= 0 //Valor de imposto a ser somado nos cartoes
Local nTotVenda := 0
Local nProporc 	:= 0
Local nVlrProp 	:= 0
Local nQtdParc 	:= 0
Local nTotCdCc  := 0
Local aPosPgtos := {}
Local nAuxSumTot:= 0
Local nAuxSumPar:=0
Local nVlrDif 	:= 0
Local aTaxJurBkp:= aClone(aTaxJuros)
Local n_TotalBkp:= 0
Local nDiffTotal:= 0
Local nVlCardAux:= 0

//Faz Backup dos valores antes de altera-los
MaFisSave() //Faz backup da MatxFis, antes de alterar seus valores de referencia

n_ValTotal := MaFisRet(  , "NF_VALMERC" ) - MaFisRet(  , "NF_DESCONTO" )
n_VlrTxJur := aTaxJuros[4]

//MaFisAlt( "NF_ACRESCI", n_VlrTxJur ) //Alimenta essa referencia na MatxFis para que depois esse valor de acrescimo seja utilizado no fonte LOJXFUNC para gravar o campo F2_VALACRS
MaFisLoad( "NF_ACRESCI", n_VlrTxJur, Nil) //Alimenta essa referencia na MatxFis para que depois esse valor de acrescimo seja utilizado no fonte LOJXFUNC para gravar o campo F2_VALACRS

//Loop para incluir o acrescimo da taxa do cartao e recalcular os IMPOSTOS
While MaFisFound("IT",nItem)
	//Calcula o Acrescimo Proporcional
	nProp := (MaFisRet( nItem , "IT_VALMERC" ) - MaFisRet( nItem , "IT_DESCONTO" )) / n_ValTotal

	nAcrecProp := n_VlrTxJur * nProp
	MaFisAlt( "IT_DESCONTO", MaFisRet( nItem, "IT_DESCONTO" ) - nAcrecProp, nItem)

	nItem++
End


MaFisReprocess(2)
n_TotalBkp := Lj7T_Total(2) + nNCCUsada //Guarda backup do total da venda para verifica se o mesmo sera modificado apos os recalculos executados no Laco abaixo pela funcao "Lj7RecalImp"

//Acerta os valores Totias (Cabecalho) da MatxFis
nX:= 1
While MaFisFound("IT",nX)
	If !MaFisRet( nX, "IT_DELETED" )
		MaFisEndLoad(nX,1)
	EndIf
	nX++
End
StaticCall( MATXFIS, MaIt2cab )

nX := 1
//Loop para incluir o acrescimo da taxa do cartao e recalcular os IMPOSTOS
While MaFisFound("IT",nX)
	//Recalcula os impostos variaveis (Localizacoes), atualiza array "aTotImpsV"
	Lj7RecalImp(nX,1,,,,,,.T.,,.T.)
	nX++
End

//Verifica se o Total da Venda foi ajustado devido arredondamentos executados no Laco anterior que chama a funcao Lj7RecalImp para todos os itens
If ( nDiffTotal := (n_TotalBkp - Lj7T_Total(2)) ) <> 0

	nAuxSumTot := 0

	//Ajusta valores de pagamento
	For nX:=1 To Len(aPgtosSint)
		If AllTrim(aPgtosSint[nX][1]) $ _FORMATEF
			aPosPgtos := {}

			nQtdParc := aPgtosSint[nX][2]

			nAuxSumTot += nDiffTotal

			//Atualiza o array aPgtosSint
			aPgtosSint[nX][6][1] -= nDiffTotal
			aPgtosSint[nX][3] := TransForm( aPgtosSint[nX][6][1], PesqPict("SL4","L4_VALOR") )

			nVlrParc := NoRound( nDiffTotal / nQtdParc, 2 ) //Calcula o valor a ser somado nas parcelas do cartao

			nAuxSumPar := 0
			nPos := 1

			//Atualiza o array aPgtos
			While ( nPos := Ascan(aPgtos, {|x| AllTrim(x[3])+AllTrim(x[8]) == AllTrim(aPgtosSint[nX][1])+AllTrim(aPgtosSint[nX][4])}, nPos ) ) > 0
				aPgtos[nPos][4] := aClone( aPgtosSint[nX][6] )
				aPgtos[nPos][2] -= nVlrParc
				nAuxSumPar += nVlrParc
				aAdd( aPosPgtos, nPos )
				nPos++
			End

			//Verifica se ficou algum residuo, soma na ultima parcela
			If nAuxSumPar <> nDiffTotal
				nVlrDif := nDiffTotal - nAuxSumPar
				nPos := aPosPgtos[Len(aPosPgtos)]
				aPgtos[nPos][2] -= nVlrDif
				nAuxSumTot += nVlrDif
			EndIf

			Exit
		EndIf
	Next nX

	Lj7T_TotPar(2, Lj7T_TotPar(2)-nDiffTotal ) //Atualiza o Total das parcelas da Venda

	//Atualiza informacoes na tela
	oPgtos:SetArray( aPgtos )
	oPgtosSint:SetArray( aPgtosSint )
	oPgtosSint:Refresh()
	oPgtos:Refresh()

	aTaxJuros[2] := aTaxJuros[2] - nDiffTotal
EndIf


//Atualiza os arrays "aImpsSL1" e "aImpsSL2" utilizados na gravacao dos impostos
Lj7PrepGrvImp()

If n_VlrTxJur > 0
	Lj7T_Subtotal(2, ( Lj7T_Total(2) - n_VlrTxJur) )
EndIf

//---------------------------------------------------------
// Faz os ajustes dos valores pagos em cartao (CD e CC)
//---------------------------------------------------------
If nValImpSum > 0 //Se existir novo valor adicional de imposto, faz o rateio deste valor

	nTotVenda := Lj7T_Total(2)
	AEval( aPgtosSint, { |x| If(AllTrim(x[1]) $ _FORMATEF, nTotCdCc+= x[6][1] , Nil) } ) //Total pago com CD e CC
	nAuxSumTot := 0

	//Rateia o valor do imposto adicional calculado devido atingir o valor minimo para calculo de determinado imposto
	//Rateia apenas para a forma de pagamento CD e CC
	For nX:=1 To Len(aPgtosSint)
		If AllTrim(aPgtosSint[nX][1]) $ _FORMATEF
			nPosSint := nX
			aPosPgtos := {}

			nQtdParc := aPgtosSint[nX][2]
			nProporc := aPgtosSint[nX][6][1] / nTotCdCc //Calcula a proporcionalidade do cartao
			nVlrProp := NoRound(nValImpSum * nProporc, 2) //Valor proporcional calculado, a ser somado no cartao

			nAuxSumTot += nVlrProp

			//Atualiza o array aPgtosSint
			aPgtosSint[nX][6][1] += nVlrProp
			aPgtosSint[nX][3] := TransForm( aPgtosSint[nX][6][1], PesqPict("SL4","L4_VALOR") )

			nVlrParc := NoRound( nVlrProp / nQtdParc, 2 ) //Calcula o valor a ser somado nas parcelas do cartao

			nAuxSumPar := 0
			nPos := 1

			//Atualiza o array aPgtos
			While ( nPos := Ascan(aPgtos, {|x| AllTrim(x[3])+AllTrim(x[8]) == AllTrim(aPgtosSint[nX][1])+AllTrim(aPgtosSint[nX][4])}, nPos ) ) > 0
				aPgtos[nPos][4] := aClone( aPgtosSint[nX][6] )
				aPgtos[nPos][2] += nVlrParc
				nAuxSumPar += nVlrParc
				aAdd( aPosPgtos, nPos )
				nPos++
			End

			//Verifica se ficou algum residuo, soma na ultima parcela
			If nAuxSumPar <> nVlrProp
				nVlrDif := nVlrProp - nAuxSumPar
				nPos := aPosPgtos[Len(aPosPgtos)]
				aPgtos[nPos][2] += nVlrDif
				nAuxSumTot += nVlrDif
			EndIf
		EndIf
	Next nX

	//Verifica se ainda ficou algum residuo, soma no ultimo cartao
	If nAuxSumTot <> nValImpSum
		nX--
		nVlrDif := nValImpSum - nAuxSumTot

		//Atualiza o array aPgtosSint
		aPgtosSint[nPosSint][6][1] += nVlrDif
		aPgtosSint[nPosSint][3] := TransForm( aPgtosSint[nX][6][1], PesqPict("SL4","L4_VALOR") )

		//Atualiza o array aPgtos
		nPos := aPosPgtos[Len(aPosPgtos)]
		aPgtos[nPos][4] := aClone( aPgtosSint[nPosSint][6] )
		aPgtos[nPos][2] += nVlrDif

		nAuxSumTot += nVlrDif
	EndIf

	Lj7T_TotPar(2, Lj7T_TotPar(2)+nValImpSum ) //Atualiza o Total das parcelas da Venda

	//Atualiza informacoes na tela
	oPgtos:SetArray( aPgtos )
	oPgtosSint:SetArray( aPgtosSint )
	oPgtosSint:Refresh()
	oPgtos:Refresh()


	aTaxJuros[2] := aTaxJuros[2] + nValImpSum

EndIf

//Monta vetor com elementos do Browse
For nX:=1 To Len(aPgtosSint)
	If AllTrim(aPgtosSint[nX][1]) $ _FORMATEF
		nVlCardAux := If( ValType(aPgtosSint[nX][6][1]) == "C", Val(Replace(aPgtosSint[nX][6][1],",",".")) , aPgtosSint[nX][6][1] )
		aAdd( aItCartoes, { 	aPgtosSint[nX][4],;			//01 - ID Cartao
							 	aPgtosSint[nX][6][5],;		//02 - Administradora
							 	aPgtosSint[nX][1],;			//03 - Forma de Pagamento
							 	aPgtosSint[nX][5],;			//04 - Data
							 	aPgtosSint[nX][6][3],;		//05 - Parcelas
							 	nVlCardAux } )				//06 - Valor
	EndIf
Next nX

DEFINE DIALOG oDlg TITLE STR0191 FROM 180,180 TO 500,800 PIXEL //"Cartão de débito e crédito"

@ 05, 05 SAY STR0192 SIZE 100, 7 OF oDlg PIXEL //"Relação de valores pagos com cartão"

oBrowse := TCBrowse():New( 15 , 05, 300, 130,,aColunas[1],aColunas[2],oDlg,,,,,{||},,,,,,,.F.,,.T.,,.F.,,, )
oBrowse:SetArray(aItCartoes)
oBrowse:bLine := {||{ aItCartoes[oBrowse:nAt,01],;
                       aItCartoes[oBrowse:nAt,02],;
                       aItCartoes[oBrowse:nAt,03],;
                       aItCartoes[oBrowse:nAt,04],;
                       aItCartoes[oBrowse:nAt,05],;
                       Transform(aItCartoes[oBrowse:nAT,06],'@E 99,999,999,999.99') } }

DEFINE SBUTTON oBtnOK     FROM 150, 005 TYPE 1 ACTION (lTelaOK := .T.,oDlg:End()) ENABLE OF oDlg
DEFINE SBUTTON oBtnCancel FROM 150, 050 TYPE 2 ACTION (lTelaOK := .F.,oDlg:End()) ENABLE OF oDlg

oDlg:LESCCLOSE := .F. //Desabilita a tecla ESC

ACTIVATE DIALOG oDlg CENTERED

If lTelaOK .And. cPaisLoc == "ARG"
	If cTipoCli == "F" .And. Lj7T_Total(2) >= SuperGetMV("MV_LIMCFIS") .And. !aDadosCF[7]
		//Exibe a tela para indicar o tipo e numero de documento quando consumidor final e
		//venda maior que o determinado no parametro MV_LIMCFIS.
		lTelaOK := LjGetDocCF(@aDadosCF,nSaveSx8)
	EndIf
EndIf

If !lTelaOK
	//Restaura os valores originais, quando o usuario clicar no botao "Cancelar"
	//Caso a tela seja cancelada, sao retornado os valores anteriores da MatxFis
	MaFisRestore() //Retorna o backup da MatxFis, antes de alterar seus valores de referencia

	nItem := 1
	//Loop para incluir o acrescimo da taxa do cartao e recalcular os IMPOSTOS
	While MaFisFound("IT",nItem)
		//Recalcula os impostos variaveis (Localizacoes), atualiza array "aTotImpsV"
		Lj7RecalImp(nItem,1,,,,,,.T.,,.T.)
		nItem++
	End

	//Atualiza os arrays "aImpsSL1" e "aImpsSL2" utilizados na gravacao dos impostos
	Lj7PrepGrvImp()

	//Retorna o backup dos arrays "aPgtos" e "aPgtosSint"
	aPgtos 		:= aClone(aPgtosBKP)
	aPgtosSint	:= aClone(aPgSintBKP)
	oPgtos:SetArray( aPgtos )
	oPgtosSint:SetArray( aPgtosSint )
	oPgtosSint:Refresh()
	oPgtos:Refresh()

	//Restaura os Totais da Venda
	Lj7T_TotPar(2, nTotParBkp) //Retorna o backup do Total das parcelas da Venda
	Lj7T_Subtotal(2, nSubTotBkp) //Retorna o backup do SubTotal da Venda
	Lj7T_Total(2, nTotalBkp) //Retorna o backup do Total da Venda

	aTaxJuros := aClone(aTaxJurBkp)

	lRet := .F.
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjGetDocCFºAutor  ³ Varejo             º Data ³ 15/01/2015  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Exibe a tela para indicar o tipo e numero de documento     º±±
±±º          ³ quando consumidor final e venda maior que o determinado no º±±
±±º          ³ parametro MV_LIMCFIS.                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA (Localizacao Argentina)                           º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LjGetDocCF(aDadosCF,nSaveSx8)
Local lRet 		:= .T.
Local cMay		:= "" // Codigo que sera utilizado para a gravacao do endereco do Consumidor Final
Local aAreaMAD	:= {} // Salva area do MAD
Local nTent		:= 0  // Numero de tentativas, para gerar numero sequencial

//Exibe a tela para indicar o tipo e numero de documento quando consumidor final e
//venda maior que o determinado no parametro MV_LIMCFIS.
If !Lj7DocsCF(@aDadosCF)
	lRet := .F.
EndIf

If lRet
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Gera o codigo que sera utilizado para a gravacao do endereco do consumidor final³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cMay := Alltrim( xFilial("MAD") ) + aDadosCF[5]
	FreeUsedCode()

	DbSelectArea("MAD")
	aAreaMAD := GetArea()
	DbSetOrder(1)

	While DbSeek( xFilial("MAD") + aDadosCF[5] ) .OR. !MayIUseCode( cMay )
		If ++nTent > 20
			MsgStop(STR0035) //"Nao foi possivel gerar numero sequencial de endereco corretamente."
			lRet := .F.
			Exit
		EndIf

		While (GetSX8Len() > nSaveSx8)
			ConfirmSx8()
		End
		aDadosCF[5] := GetSxeNum("MAD","MAD_CODEND")
		FreeUsedCode()
		cMay := Alltrim( xFilial("MAD") ) + aDadosCF[5]
	End
	RestArea(aAreaMAD)
	If lRet
		aDadosCF[7] := .T.
	EndIf
EndIf

Return lRet


/*/{Protheus.doc} LjRlBckDBF
Restaura os registros de um determinado Alias, de forma similar a um Rollback,
porém é necessário fazer a cópia dos registros através da função LjBkpReg.
Essa função substitui o DisarmTransaction(), pois em DBF não há controle de Transação.
@param	 aDados
@author  Varejo
@version P11
@since   25/04/2015
/*/
Static Function LjRlBckDBF(aDados)

Local nTotReg	:= 0	//total de registros que serao restaurados
Local nReg		:= 0	//contador de registro
Local nTotCampo	:= 0	//total de campos de cada registro
Local nCampo	:= 0	//contador de campo
Local nTotAlias	:= 0	//total de tabelas que serão restauradas
Local nAlias	:= 0	//contador de tabelas
Local cAlias 	:= ""	//Alias da tabela
Local aArea		:= {}

Default	aDados	:= {}

/*
ESTRUTURA DO ARRAY aDados
[][1] ALIAS DA TABELA
[][2][]	- ARRAY DE REGISTROS (valores e R_E_C_N_O_)
[][2][][1][] - ARRAY DE VALORES DE CADA CAMPO DO REGISTRO
[][2][][2] - R_E_C_N_O DO REGISTRO
*/

nTotAlias := Len(aDados)

For nAlias := 1 to nTotAlias
	cAlias := aDados[nAlias][1]	//indica o Alias que será restaurado

	aArea := (cAlias)->( GetArea() )		//armazena a area corrente da tabela que será restaurada

	nTotReg := Len( aDados[nAlias][2] )		//indica o total de registros que será restaurado

	For nReg := 1 to nTotReg

		nTotCampo := Len( aDados[nAlias][2][nReg][1] )		//indica o total de campos

		(cAlias)->( DbGoto(aDados[nAlias][2][nReg][2]) )	//posiciona no registro a ser restaurado atraves do R_E_C_N_O_
		RecLock(cAlias, .F.)
		For nCampo := 1 to nTotCampo
			(cAlias)->( FieldPut(nCampo, aDados[nAlias][2][nReg][1][nCampo]) )	//restaura o valor de cada campo
		Next
		(cAlias)->( MsUnlock() )

	Next

	RestArea(aArea)
Next

Return Nil


/*/{Protheus.doc} LjBkpReg
Faz a cópia dos valores e do R_E_C_N_O_ do registro, para que em casos de erro,
seja feita a restauração do mesmo, já que em DBF não há Controle de Transação
@param	 cAlias	 Indica o Alias do registro, o qual será feita a cópia
@author  Varejo
@version P11
@since   25/04/2015
@return  aReg - [1]vetor com os valores e o [2]R_E_C_N_O_ do registro
/*/
Static Function LjBkpReg(cAlias)

Local nTotCampo := 0	//totais de campo do registro
Local nCampo 	:= 0	//contador de campo
Local xValor			//valor do campo
Local aRet		:= {}	//vetor com os [1]vetor de valores dso campos e [2]R_E_C_N_O_ do registro
Local aCampos	:= {}	//vetor com os valores de cada campo

Default cAlias	:= Alias()

nTotCampo := (cAlias)->( FCount() )

For nCampo := 1 to nTotCampo
	xValor := (cAlias)->( FieldGet(nCampo) )
	Aadd( aCampos, xValor )
Next

aRet := { aCampos, (cAlias)->(Recno()) }

Return aRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjEspecieNF ºAutor³Vendas Clientes     º Data ³  23/06/15   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função que verifica qual o tipo de Especie de Nota Fiscal   º±± 
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ExpA1 := LjEspecieNF( ) 					    	          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Nil                        					              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ cEspecie													  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SigaLoja/FrontLoja                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/   

Function LjEspecieNF()
 
Local lNFServ	:= .F.
Local cEspecie	:= ""
 
If LjEmitNFCe()
   					
	//Especie da NFC-e
	cEspecie	:= "NFCE"
	
ElseIf lNFServ

	//Para NF de "Servico" grava a especie como RPS (Recibo Provisorio de Servico)
	cEspecie	:= "RPS"
	 	
ElseIf LjAnalisaLeg(18)[1]

	//Se for o Estado de Piauí, grava ECF
	cEspecie	:= "ECF"
	
Else 

	// Especie do tipo Cupom Fiscal
	cEspecie	:= "CF"
	
EndIf

Return cEspecie

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºFuncao    ³LjxTotItensºAutor  ³  Vendas Clientes   º Data ³  20/08/2015 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Retorna o total dos itens de reserva                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Nenhum													   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Valor Total dos Itens de reserva		 		               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ LOJXFUNC                                                    º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjxTotRes()
Local aArea 	:= GetArea()            // Armazena area atual (alias, order e recno)
Local nSomItens	:= 0					// Total de itens
Local nReserva	:= 0
Local cL2Entrega:= ""
              
DbSelectArea( "SL2" )
SL2->(DbSetOrder( 1 ))
SL2->(DbSeek( xFilial( "SL2" ) + SL1->L1_NUM ))

While !SL2->(Eof()) .AND. ( xFilial( "SL2" ) + SL1->L1_NUM == SL2->L2_FILIAL + SL2->L2_NUM )
	
	cL2Entrega := AllTrim(SL2->L2_ENTREGA)
	
	If !Empty(cL2Entrega) .And. (cL2Entrega <> "2") 
		nReserva += SL2->L2_VLRITEM
	EndIf
	
	SL2->(DbSkip())
End
RestArea(aArea)

Return nReserva

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºFuncao    ³LjxPropRes ºAutor  ³  Vendas Clientes   º Data ³  20/08/15   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Retorna valor proporcional do para o item atual             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpN1 - Numerico contendo valor total dos itens        	   º±±
±±º          ³ExpN2 - Numerico contendo os valores do frete                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Valor proporcional do frete de cada item		               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ LOJXFUNC                                                    º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjxPropRes(nReserva, nValor,	lScreen, nDescProp, nAcresProp)

Local nValItem 		:= 0    // Valor do item
Local nVlProp 		:= 0	// Valor proporcional do item

Default nReserva		:= 0
Default nValor		:= 0
Default lScreen		:= .T.  // Verifica se foi chamada pela LJGRVBATCH
Default nDescProp		:= 0	// Desconto proporcional do item
Default nAcresProp  	:= 0	// Acrescimo proporcional do item

//Quando e chamada pela LjGrvBatch a soma dos itens (nReserva) ja esta considerando o desconto proporcional.
If !lScreen
	//Pega o Valor do Item ja calculado do PDV
	nValItem := SL2->L2_VLRITEM
Else
	nValItem := (SL2->L2_VRUNIT * SL2->L2_QUANT) - nDescProp + nAcresProp
EndIf

nVlProp  := (nValItem / nReserva) * nValor

Return nVlProp

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma       ³CrdCpvFin ºAutor  ³Vendas Clientes     º Data ³  06/10/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.          ³ Executa a Impressao do Comprovante de Financiamento quando º±±
±±º               ³ a Retaguarda estiver inacessivel (AD Off-Line).            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso            ³Interfaces de Venda                                         º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function ImpAcrsAux()
Local aComprov 	    := {}                            			// Array com os dados a serem impressos no comprovante de recebimento
Local cNome			:= ""                            			// Nome do cliente a ser impresso
Local cTicket		:= ""                            			// Texto nao-fiscal enviado ao ECF
Local cMV_FORMCRD   := "FI"   									//Formas de pagamento que devem ter analise
Local nX			:= 0                             			// Controle de loop
Local aArea			:= GetArea()                     			// Area atual
Local nQtdParcel    := 0                             			// Quantidade de parcelas do recebimento
Local lVerEmpres    := Lj950Acres(SM0->M0_CGC)					// Verifica as filiais da trabalharam com acrescimento separado
Local nDiasPagto	:= 0										// Dias da condicao de pagamento
Local nValorL4 		:= 0										// Maior valor da parcela
Local nAcrsFin 		:= 0   										// % de acrescimo financeiro
Local nL4ValTot		:= 0										// Valor total financiado
Local cFormaPgto	:= Alltrim(SL1->L1_FORMPG)					// Forma de pagamento da venda
Local nRetECF		:= 0

// Verifica se o cadastro do cliente existe localmente na base de dados do Caixa
DbSelectArea("SA1")
If	DbSeek(xFilial("SA1")+SL1->L1_CLIENTE+SL1->L1_LOJA)
	cNome := SA1->A1_NREDUZ
Endif

DbSelectArea("SL4")
DbSetOrder(1)
If	DbSeek(xFilial("SL4")+SL1->L1_NUM)
	While ! SL4->(Eof()) .AND. xFilial("SL4") == SL4->L4_FILIAL .AND. SL1->L1_NUM == SL4->L4_NUM

		IF Alltrim(SL4->L4_FORMA) $ cMV_FORMCRD

			nQtdParcel ++
			cFormaPgto := SL4->L4_FORMA

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alteracao para enviar os parametros corretos para alteracao de comprovante   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (lVerEmpres .OR. (SuperGetMV("MV_LJICMJR",,.F.) .AND. cPaisLoc == "BRA"))

				nL4ValTot += NoRound(SL4->L4_VALOR)
				nValorL4  += NoRound(SL4->L4_VALOR)
				nAcrsFin  += NoRound(SL4->L4_ACRSFIN)

		   		DbSelectArea("SE4")
		   		DbSetOrder(1)
		   		If DbSeek(xFilial("SE4") + SL1->L1_CONDPG)
	         		nDiasPagto	:= SE4->E4_LIMACRS
 	       		Endif
	   		Endif
		Endif

		SL4->(DbSkip())
	End

EndIf

If AllTrim(cFormaPgto ) == cMV_FORMCRD
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Confirguracao do comprovante de credito                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aAdd( aComprov, "" )
	aAdd( aComprov, "" )
	aAdd( aComprov, "       C O M P R O V A N T E   D E  " )													//"       C O M P R O V A N T E   D E  "
	aAdd( aComprov, "        F I N A N C I A M E N T O 	" ) 													//"        F I N A N C I A M E N T O 	"
	aAdd( aComprov, "" )

	aAdd( aComprov, "" )
	aAdd( aComprov, "Data: " + Dtoc(SL1->L1_EMISSAO) + " Hora: " + IIF(!Empty(SL1->L1_HORA),SL1->L1_HORA,Time()) ) 		//"Data: "###" Hora: "
	aAdd( aComprov, "Estabel.: " + SM0->M0_CODIGO + "-" + FwCodFil() + "-" + Alltrim(SM0->M0_NOME) )	//"Estabel.: "
	aAdd( aComprov, "PDV:  " + Alltrim(SLG->LG_PDV) ) 					//"PDV:  "

	If !Empty(cNome)
		aAdd( aComprov, "Cliente : " + cNome ) 									//"Cliente : "
	Endif

	// Imprimir o CPF do cliente
	If !Empty(SL1->L1_CGCCART)
		If Len(ALLTRIM(SL1->L1_CGCCART)) <= 14
			aAdd( aComprov, "CPF     : "  + SL1->L1_CGCCART ) 					//"Cpf     : "
		Else
			// Imprimir o codigo do Cartao do cliente
			aAdd( aComprov, "Cartao  : " + SL1->L1_CGCCART ) 					//"Cartao  : "
		Endif
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se trabalhar com o conceito de acrescimo separado, ³
	//³imprime comprovante de financiamneto               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	If nAcrsFin > 0
		nValorL4 := nValorL4 + nAcrsFin
	Endif

	aAdd( aComprov, "Forma Pgto.: " + Tabela("24",cFormaPgto,.F.) ) 		//"Parcelas: "
	If nDiasPagto == 0
		aAdd( aComprov, "            Para pagto a prazo de R$ " + Alltrim(Transform(nValorL4,PesqPict("SL2","L2_VLRITEM"))) )
		aAdd( aComprov, "            dividido em " + Alltrim(STR(nQtdParcel,0)) + " parcelas." )
	Else
		aAdd( aComprov, "            Pagto a vista em ate " + Alltrim(STR(nDiasPagto,0)) + " dias R$ " + Alltrim(Transform(nL4ValTot,PesqPict("SL1","L1_VLRTOT"))))
		aAdd( aComprov, "     ou em " + Alltrim(STR(nQtdParcel,0)) +  "parcelas de R$ " + Alltrim(Transform(nValorL4,PesqPict("SL2","L2_VLRITEM"))) )
	EndIf
	aAdd( aComprov, "" )
	aAdd( aComprov, "         Confirmo que pagarei " )													//"         Confirmo que pagarei "
	aAdd( aComprov, "          a importancia acima " )													//"          a importancia acima "
	aAdd( aComprov, "" )
	aAdd( aComprov, "" )
	aAdd( aComprov, "----------------------------------------" )
	aAdd( aComprov, "              Assinatura "  ) 													//"              Assinatura "

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza o comprovante nas linhas de valor total e parcelas com outro texto³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aAdd( aComprov, "" )
	aAdd( aComprov, Replicate( "=", 40 ) )

	For nX := 1 to Len(aComprov)
		 cTicket += aComprov[nX] + Chr(10)
	Next nX

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se não conseguir imprimir um cupom nao fiscal, manda um     ³
	//³Relatorio Gerencial para o ECF  (Alguns ECF, por exemplo a  ³
	//³Sweda, não permite que seja vinculado um cupom nao fiscal   ³
	//³a um outro cupom nao fiscal)                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nRetECF := IFRelGer( nHdlECF, cTicket, 1 )
	If nRetECF <> 0
		// "Não foi possível imprimir o comprovante de financiamento. Verifique o ECF e solicite a re-impressão."
		MsgStop(STR0049)
	Endif
EndIf

RestArea( aArea )  //Restauro a area original

Return Nil

//--------------------------------------------------------
/*/{Protheus.doc} LjCodSiTEF()
Retorna informacoes da tabela MDE referente ao codigo de retorno do SiTEF.
@param cOpc			Opcao de busca a ser realizada (MDE_TIPO). Ex.: CC=Cartao de Credito; CD=Cartao de Debito; RD=Rede

@author  Varejo
@version P11.8
@since   08/03/2016
@return	 aRet
/*/
//--------------------------------------------------------
Function LjCodSiTEF(cOpc)

Local aRet 		:= {}
Local aIndices	:= {}	// Contem os indices da tabela (ORDEM, CHAVE, NICKNAME)

aIndices := TableIndex("MDE")
DbSelectArea("MDE")

If Ascan(aIndices,{|x| x[1] == "3"}) 
	MDE->(DbSetOrder(3)) // MDE_FILIAL+MDE_TIPO+MDE_CODSIT
	If MDE->(DbSeek(xFilial("MDE")+cOpc))
		While !MDE->(EoF()) .And. xFilial("MDE")+cOpc == MDE->MDE_FILIAL+MDE->MDE_TIPO
			Aadd( aRet, { MDE->MDE_CODSIT, AllTrim(MDE->MDE_DESC) } )
			MDE->(DbSkip())
		End
	EndIf
Else
	MDE->(DbSetOrder(1)) // MDE_FILIAL+MDE_CODIGO
	If MDE->(DbSeek(xFilial("MDE")))
		While !MDE->(EoF()) .And. cOpc == MDE->MDE_TIPO
			Aadd( aRet, { MDE->MDE_CODSIT, AllTrim(MDE->MDE_DESC) } )
			MDE->(DbSkip())
		End
	EndIf
EndIf

Return aRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºFuncao    ³LjReAbreVA ºAutor  ³  Varejo            º Data ³  20/10/15   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Controla se abre a tela do Venda Assistida automaticamente  º±±
±±º          ³ para uma nova venda apos finalizar um atendimento.          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³nTipo - 1-Salvar como orcamento                              º±±
±±º          ³        2-Salvar como venda                                  º±±
±±º          ³        3-Salvar como pedido                                 º±±
±±º          ³nOpc  - nOpc da rotina (3-Atendimento; 4-Finaliza venda)     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ .T. Abre a tela automaticamente para uma nova venda.        º±±
±±º          ³ .F. Nao abre a tela automaticamente para uma nova venda.    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA - Venda Assistida                                  º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function LjReAbreVA(nTipo, nOpc)
Local lReabreTela := .T.

If ExistBlock("LJ701Mbr")
	lReabreTela := ExecBlock( "LJ701Mbr", .F., .F., {nTipo, nOpc} )
Else
	//Por padrao somente reabre a tela para realizar uma nova venda quando for Atendimento.
	//Qdo. for Finalizacao de Venda, nao reabre a tela automaicamente.
	lReabreTela := If(nOpc==3,.T.,.F.)
EndIf

MBrChgLoop(lReabreTela)

Return

//--------------------------------------------------------
/*/{Protheus.doc} LjVldUlVnd()
Valida se a ultima venda está de acordo com o ECF
caso o ECF esteja OK e a venda não OK ( queda de energia)
cancelo o ultimo cupom.
@type	 Function
@author  Varejo
@version P11.8
@since   13/06/2016
@return	 lRet , lógico , retorna se cancelou ou não o cupom
@obs	 Nao precisa validar o CCD pois se este for impresso as tabelas
		 do sistema já estão finalizadas ( ou seja venda finalizada )
/*/
//--------------------------------------------------------
Function LjVldUlVnd()
Local aAreaSL1		:= {}
Local nRet    		:= 0
Local nTamDoc		:= TamSX3("L1_DOC")[1]
Local nIndice		:= 0
Local cNumCup		:= Space(nTamDoc)
Local lRet     		:= .T.   							// .T. - Cancelamento com sucesso; .F. - Erro no cancelamento do cupom
Local lFindReg		:= .F.
Local cCodEst		:= ""
Local cIndex		:= ""
Local cIndFName		:= ""
Local cChave		:= ""
Local cCond			:= ""
Local cQuery		:= ""
Local cAlSL1		:= "SL1TMP"

DbSelectArea("SL1")
aAreaSL1 := SL1->(GetArea())

If SL1->(ColumnPos("L1_NUMCFIS")) > 0

	nRet	:= IFPegCupom( nHdlECF,@cNumCup )
	cNumCup	:= PADR(cNumCup,nTamDoc) // Restaura o tamanho da variavel cNumcup para a comparação com L1_DOC
	If nRet <> 0
		HELP(' ',1,'FRT011')	      // "Erro com a Impressora Fiscal. Operação não efetuada.", "Atenção"
		lRet := .F.
	Endif

	If lRet
		cCodEst := LjGetStation("CODIGO")
		
		#IFDEF TOP
			If Select(cAlSL1) > 0
				(cAlSL1)->(DbCloseArea())
			EndIf
			
			cQuery := " SELECT "
			cQuery += " L1_NUM "
			cQuery += " FROM " + RetSQLName("SL1") + " SL1 "
			cQuery += " WHERE "
			cQuery += " SL1.D_E_L_E_T_ = '' AND SL1.L1_FILIAL = '"+xFilial("SL1")+"'"
			cQuery += " AND SL1.L1_NUMCFIS = '" + cNumCup + "' AND SL1.L1_ESTACAO = '" + cCodEst + "'"
			cQuery += " AND SL1.L1_DOC = '' "
			
			cQuery := ChangeQuery(cQuery)
			DBUseArea(.T., "TOPCONN", TCGenQry(,,cQuery),cAlSL1, .F., .T.)
			(cAlSL1)->(DbGoTop())
			
			If !Empty(AllTrim((cAlSL1)->L1_NUM))
				SL1->(DbSetOrder(1))
				lFindReg := SL1->(DbSeek(xFilial("SL1")+(cAlSL1)->L1_NUM))
			EndIf
			
			(cAlSL1)->(DbCloseArea())
		#ELSE
			cIndex	:= CriaTrab(Nil,.F.)
			cChave	:= "L1_FILIAL+L1_NUMCFIS+L1_ESTACAO"
			cCond	:= "L1_FILIAL = '"+xFilial("SL1")+"' .AND. L1_NUMCFIS = '" + cNumCup + "' .AND. L1_ESTACAO = '" + cCodEst + "' .AND. Empty(Trim(L1_DOC)) "
			IndRegua("SL1",cIndex,cChave,,cCond)
			DbSelectArea("SL1")
			nIndice := RetIndex("SL1")
			cIndFName := cIndex+OrdBagExt()
			SL1->(DbSetIndex(cIndFName))
			SL1->(DbSetOrder(nIndice+1))
			lFindReg := SL1->(DbSeek(xFilial("SL1")+cNumCup+cCodEst))				
		#ENDIF
		
		If lFindReg
			RecLock("SL1",.F.)
			REPLACE SL1->L1_NUMCFIS WITH ""	//Retorno o campo ao normal para evitar algum dado impreciso posteriormente
			SL1->(MsUnlock())

			nRet := IFCancCup( nHdlECF )
		EndIf
		
		If !Empty(cIndex)
			FErase(cIndFName)
			SL1->(DbCloseArea())
			
			DbSelectArea("SL1")
			RetIndex("SL1")
			SL1->(DbClearFilter())
		EndIf
	EndIf
EndIf

RestArea(aAreaSL1)

lRet := (nRet == 0)

Return lRet

//----------------------------------------------------------
/*/{Protheus.doc} LJRDLJXTEF
Funcao que verifica a data do fonte LOJXTEF para saber se o 
atributo cCodRede (Rede) existe no objeto oTef:aRetCartao

@type function

@author  Varejo
@version P11.8
@since   06/10/2016

@param	
@return lRet
/*/
//----------------------------------------------------------
Function LJRDLJXTEF()
Local lRet 			:= .F.
Local aFonteInfo	:= GetAPOInfo("LOJXTEF.PRW")

If Len(aFonteInfo) > 0
	lRet := aFonteInfo[4] > CTOD("19/10/2016")
EndIf

Return lRet

//---------------------------------------------------------------
/*/{Protheus.doc} LJDOCSAIDA
Funcao TEMPORARIA que exibe a pergunta "Cupom ou Nota" na 
finalizacao da venda, e se nota for selecionada, 
ela verifica se o sistema esta configurado para emissao.
@type function
@author  Varejo
@version P12.1.14
@since   20/01/2017
@return aRet - [1]tipo do documento [2]se permite emissao de NF
/*/
//---------------------------------------------------------------
Static Function LJDocSaida()

Local nDocSai	:= 1	//1-Cupom Fiscal 2-Nota Fiscal 3-Cancela
Local lEmiteNF	:= .F.	//Indica se é permitido emissao de Nota Fiscal
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local aRet		:= {}	//[1]-Documento de Saida selecionado [2]-Se permitido emitir Nota Fiscal
Local lEmisNF	:= ( LjEmiteNF(SM0->M0_CGC, .F.) .OR. lFtvdVer12 )	// Verifica se a empresa se enquadra na LjEmiteNF


//se Usuario Nao Fiscal, ja atribui o doc de saida como Nota Fiscal
If lFiscal
	nDocSai := Aviso( STR0053, STR0054, {STR0055, STR0056, STR0058} )
	//"Documento Fiscal de Saida"##"Qual Documento Fiscal de Saida sera impresso na venda?"##"Cupom"##"Nota"##"Cancela"
Else
	If lEmisNF
		nDocSai := 2
	Else
		nDocSai := 1
		lEmiteNF := .F.
	EndIf
EndIf

//se o usuario selecionou Nota Fiscal, verifica se o sistema esta configurado para permitir sua emissao
If nDocSai = 2
	lEmiteNF := LjNFFimVd(	.T. /*lCria*/	, .F. /*lEmiteCF*/	, .T. /*lFinaliza*/ , /*cA1Est*/,;
							/*cA1Pessoa*/	, /*nRefLJ7087*/	, /*lLJ7087*/		, nDocSai	)
EndIf

Aadd( aRet, nDocSai)
Aadd( aRet, lEmiteNF)

Return aRet

//----------------------------------------------------------
/*/{Protheus.doc} Lj7PedTEF
Função responsável por executar a transação TEF quando venda 
com item do tipo entrega.

@type		function
@param		aTefBKP		: Backup das informações do TEF
			lTemTefPend	: Possui TEF pendente 
			lTefAbort	: Se não pergunta ou realiza o TEF 
			apos a LJ7Pedido
			aNSUVndTef	: Informações das transições TEF 
			lTefManuPed	: Se utiliza TEF Manual e se sera 
			executado cancelamento da venda qdo pedido
@author		felipe.martinez
@version	P12.1.14
@since		20/02/2017
@return 	aRet:	[1] - TEF realizado com sucesso?
					[2] - Continua a processar a função LJ7Pedido?
/*/
//----------------------------------------------------------
Static Function Lj7PedTEF(	aTefBKP		,lTemTefPend	,lTefAbort	,aNSUVndTef	,;
							lTefManuPed , lCartao )
Local aRet			:= {.F.,.F.}				//[1]-TEF ok?, [2]-Continua o processamento da lj7Pedido?
Local lTefOk		:= .F.						//Transação TEF realizada com sucesso.
Local lCont7Ped		:= .T.						//Se o processo do LJ7Pedido será executado apos o TEF (para nao dar Returno no meio do fonte)
Local lSemRede		:= .F.
Local nX			:= 0
Local nY			:= 0
Local aReb			:= {}
Local cNumPai		:= SL1->L1_NUM
Local lAutomato		:= If(Type("lAutomatoX") <> "L",.F.,lAutomatoX)
Local lSelTefManu   := .F.	//Valida se foi selecionado o TEF Manual

Default aTefBKP		:= {}
Default lTemTefPend	:= .F.
Default lTefAbort	:= .F.
Default aNSUVndTef	:= {}
Default lTefManuPed	:= .F.
Default lCartao		:= .F.

lCartao	:= LJXVERTEF(.F.)

If lUsaTef .AND. lCartao .AND. cTipTEF $	TEF_SEMCLIENT_DEDICADO 	+ ";" + ;
											TEF_COMCLIENT_DEDICADO 	+ ";" + ;
											TEF_DISCADO 			+ ";" + ;
											TEF_CLISITEF
	
	aParcTef := {} // Array private declarado no fonte LOJA701
	//Monta os array's para validação do tef
	LjMnReb(@aReb, @aParcTef)
	LjGrvLog(cNumPai,"Vai realizar a transacao TEF do PEDIDO ",aPgtos)
	If cTipTef == TEF_CLISITEF
		oTEF:Operacoes("V"			, aReb			, @lTemTefPend	, @aTefBKP		,;
						cNumPai		, NIL			, @aPgtos		, @aPgtosSint	,;
						@oPgtos		, @oPgtosSint	)

		lTefOk := oTef:lTefOk
		lSelTefManu := !lTefOk
		If !SuperGetMv("MV_TELAFIN",,.T.)
			If !LJVERADM( @lSemRede, .T.,lTefManuPed, Nil ,lSelTefManu ) .And. SuperGetMV("MV_TEFPEND",,"0") == "0"
				LjCancTEF()
				lTefOk := .F.
				LjGrvLog(cNumPai,"transacao Tef Cancelada",lTefOk)
			EndIf
		EndIf
	Else
		lTefOk := LOJA010T( "V" , ,aReb)
	EndIf

	LjGrvLog(cNumPai,"RETORNO DA TRANSACAO TEF ",lTefOk)
	If Valtype(lTefOk) <> "L"
		lTefOk := .F.
	Else
		LjGrvLog(cNumPai,"Objeto oTef",oTef)
	EndIf

	If !lTefOk
		If cTipTef <> TEF_CLISITEF
			//HOMOLOGACAO: Enviar o desfazimento da operação TEF para impedir transações pendentes no Sitef
			If TEF_lEnvDF()
				If LOJA010T("F","D")
					MsgAlert(STR0047) 	//"Transação TEF não efetuada!"
				EndIf
			//Na versào 3.00 do TEF qdo quando ocorre erro nao e necessario cancelar enviei o desfazimento, respeito as versoes anteriores do Sitef
			ElseIf !(SuperGetMV("MV_TEFVERS") == "03.00")
				If LOJA010T("F","N")	//Antigamente esta função nao retornava verdadeiro ou falso
					MsgAlert(STR0047) 	//"Transação TEF não efetuada!"
				EndIf
			EndIf
		EndIf

		If !SuperGetMV("MV_TEFMANU",,.T.) .OR. lSemRede
			lTelaTefPed	:= .T.
			lCont7Ped	:= .F.
		Else
			If !LojaOk(STR0011) //"Continua Manualmente?"
				LjGrvLog(cNumPai,"Continua Manualmente igual a 'Nao'")
				lTelaTefPed := .T.
				lTefManuPed := .F.
				lCont7Ped	:= .F.
			EndIf
			If lCont7Ped //Mantendo integridade, onde antes havia um 'Return' meio do fonte
				LjGrvLog(cNumPai,"Continua Manualmente igual a 'Sim'")
				//Não é necessário chamar o tef ou efetuar a pergunta de continua manualmente novamente, pois ja foi perguntado agora
				lTefAbort := .T.
				If ExistFunc("LjxTelaNSU")//Nao precisa fazer outras validações pois a variavel só vem .T. caso venda com cartao e Tef Manual
					For nX := 1 To Len(aPgtos)
						If Alltrim(aPgtos[nX][3]) $ _FORMATEF .AND. lUsaTef
							nY := Ascan(aNSUVndTef, {|x| AllTrim(x[1])+x[2] == AllTrim(aPgtos[nX][3])+aPgtos[nX][8]}) //Forma + ID
							If nY > 0
								aNSUVndTef[nY][3] += aPgtos[nX][2]
							Else
								Aadd(aNSUVndTef,{AllTrim(aPgtos[nX][3]),aPgtos[nX][8],aPgtos[nX][2],""}) //Forma , ID , Valor , NSU digitada
							EndIf
						EndIf
					Next nX
					If Len(aNSUVndTef) > 0
						For nX := 1 to Len(aNSUVndTef)
							LjGrvLog(cNumPai, "Lj7Pedido - Chamada da Tela para Digitação da NSU - TEF Manual")
							LjxTelaNSU(@aNSUVndTef[nX])
							LjGrvLog(cNumPai, "Lj7Pedido - Chamada da Tela para Digitação da NSU - Retorno:" , aNSUVndTef)
						Next nX
					EndIf
				EndIf
			EndIf
		EndIf		
	EndIf	
ElseIF  cTipTEF == "1"
	If lCont7Ped
		If ExistFunc("LjxTelaNSU")
			For nX := 1 To Len(aPgtos)
				If Alltrim(aPgtos[nX][3]) $ _FORMATEF
					nY := Ascan(aNSUVndTef, {|x| AllTrim(x[1])+x[2] == AllTrim(aPgtos[nX][3])+aPgtos[nX][8]}) //Forma + ID
					If nY > 0
						aNSUVndTef[nY][3] += aPgtos[nX][2]
					Else
						Aadd(aNSUVndTef,{AllTrim(aPgtos[nX][3]),aPgtos[nX][8],aPgtos[nX][2],""}) //Forma , ID , Valor , NSU digitada
					EndIf 
				EndIf
			Next nX
			If Len(aNSUVndTef) > 0
				For nX := 1 to Len(aNSUVndTef)
					LjGrvLog(cNumPai, "Lj7Pedido - Chamada da Tela para Digitação da NSU - TEF Manual")
					
					If !lAutomato
						LjxTelaNSU(@aNSUVndTef[nX])
					Else
						aNSUVndTef[nX][4] := "1" //Para teste automatizado simula que foi informado um NSU//
					EndIf

					LjGrvLog(cNumPai, "Lj7Pedido - Chamada da Tela para Digitação da NSU - Retorno:" , aNSUVndTef)
				Next nX
			EndIf
		EndIf
	EndIf
EndIf

If lCont7Ped .And. ExistFunc("LjGuardaTef")
	LjGuardaTef(cNumPai)
EndIf

aRet := {lTefOk,lCont7Ped}

Return aRet

//----------------------------------------------------------
/*/{Protheus.doc} LJ7MFilhos
Função responsável gerar array com os orçamentos filhos

@type		function
@author		felipe.martinez
@version	P12.1.14
@since		02/03/2017
@return 	aRet:	[1] - Continua a processar a função LJ7Pedido?
					[2] - Array com os orçamentos filhos
/*/
//----------------------------------------------------------
Static Function LJ7MFilhos(	cLojaLocal	,lJob		,aRelGer	, aRelGar	,;
							cB1M996		,cImpRGer	,aProdAlter	, lAlterOrc	,;
							nValRes		,cTpGeraGdp	,lImpCNFLoc	, aBkpTable	,;
							aAuxaPgtos	,nFatorVen	, nFatorRes	, lVendErro	,;
							aTaxJuros	,nFrete		)
Local aRet			:= {}
Local aLojas		:= {}											// Ajusta o array com as informacoes dos orcamentos das outras lojas
Local aBkpLoja		:= {}											// Guarda uma copia do aLojas caso ocorra algum erro no PE LJ7049
Local aAuxLoja		:= {}
Local aSL2			:= {}
Local aArquivos 	:= {}											// Array com o retorno da funcao Lj7GeraOrc()
Local aSL4Total		:= {} 											// Totalizador Forma de Pagamento
Local aArqAux2		:= {}
Local aBkpSL2		:= {}
Local lFecVenLst	:= .F. 											// Variavel que fecha a venda da lista de presentes sem SLJ cadastrado
Local lVerLojLst    := .F.											// Variavel que verifica se existe loja cadastrada.
Local lAchou        := .F.                                         	// Variavel de Controle para alt. orçamento
Local lContinua     := .T.											// Variavel verificação de comparação para alt. orçamento
Local lLj7TudoOK	:= .T.											// Responsável por informar se irá continuar o LJ7Pedido ou encerrar devido a erro
Local lSB1Posic		:= .F.											// Foi posicionado corretamente o SB1
Local lLastOrc		:= .F. 											// Validacao de ultimo orcamento
Local cLojaRes 		:= ""											// Loja da Reserva
Local cQuebra		:= ""											// Quebra para geracao dos Pedidos de Venda
Local cTurno		:= ""
Local cCodCont		:= ""											// Codigo do Contato
Local nPos			:= 0
Local nPosCpo		:= 0											// Posicao do campo da reserva
Local nA            := 0                                           	// Variavel auxiliar
Local nX			:= 0
Local nSLJRecno		:= 0
Local nCredito 		:= 0 											// Total de Credito
Local nDecsAux		:= 0											// Numerio de casas decimais
Local uLJPERet		:= Nil											// Retorno do PE LJ7049
Local lLstPre		:= SuperGetMV("MV_LJLSPRE",,.F.) .AND. LjUpd78Ok()	// Lista de Presentes - Ativa
Local lGE			:= SuperGetMv("MV_LJIMPGF",,.F.) .AND. LjUP104OK() 	// Validação do Conceito Garantia Estendida
Local cMvLjTGar		:= SuperGetMV("MV_LJTPGAR",,"GE")              	// Define se é tipo GE
Local cMvLjTSF		:= SuperGetMV("MV_LJTPSF",,"SF")				// Tipo servico financeiro
Local cTpQuebra		:= SuperGetMV("MV_LJTPPED",, "1")				// Define o Tipo de Quebra para os Pedidos de Venda:
Local cMV_B1M996	:= GetNewPar("MV_B1M996", "")					// Campo da tabela SB1 que identifica venda para Orgaos Publicos. Tratamento Apuração de PIS/COF.
Local lB1M996		:= SB1->(ColumnPos(cMV_B1M996)) > 0				// Identifica se o campo configurado no parametro "MV_B1M996" existe na tabela SB1.
Local lLj7049		:= ExistBlock("LJ7049")							// VerIfica se existe o Ponto de Entrada
Local lFTVD7049		:= ExistBlock("FTVD7049")						// VerIfica se existe o Ponto de Entrada
Local lAutoExC		:= IsBlind()									// Verifica se a rotina sera executada via execauto ou nao
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local lEmitNfce		:= LjEmitNFCe()		// Sinaliza se utiliza NFC-e

Default cLojaLocal	:= ""
Default lJob		:= .F.
Default aRelGer		:= {}											// Array do Relatório Gerencial
Default aRelGar 	:= {}											// Array do Relatório de Garantia
Default cB1M996		:= ""
Default cImpRGer	:= ""
Default aProdAlter	:= {}
Default lAlterOrc	:= .F.
Default nValRes		:= 0
Default cTpGeraGdp	:= GDP_NO
Default lImpCNFLoc	:= .F.											// Indica que sera impresso o comprovante nao fiscal
Default aBkpTable	:= {}
Default aAuxaPgtos	:= {}
Default nFatorVen	:= 0
Default nFatorRes	:= 0
Default lVendErro	:= .F.	

nDecsAux := iif(lJob,MsDecimais(1),nDecimais)

DbSelectArea("SLJ")
SLJ->(DbSetOrder(3))	//Filial + Empresa + Filial
If SLJ->(DbSeek(xFilial("SLJ") + cEmpAnt + cFilAnt))
	cLojaLocal	:= SLJ->LJ_CODIGO
	nSLJRecno	:= SLJ->(Recno())
Else
	//Verificação Lista de Presentes se estiver vendendo um item da Lista de Presentes
	//sem a Identificação de Lojas Cadastrada (SLJ) a venda nao sera concluida.
	If lLstPre .AND. !lJob
    	lVerLojLst := .T.
    EndIf
EndIf
//Seleciona o indice para pesquisa dentro do Loop
SLJ->(DbSetOrder(1))	//"LJ_FILIAL+LJ_CODIGO"
SB1->(dbSetOrder(1))	//"B1_FILIAL+B1_COD"
DbSelectArea("SL2")
SL2->(DbSetOrder(1))	//"L2_FILIAL+L2_NUM+L2_ITEM+L2_PRODUTO"
SL2->(DbSeek( xFilial("SL2") + SL1->L1_NUM ))
While !SL2->(Eof()) .AND. (SL2->L2_FILIAL + SL2->L2_NUM == xFilial("SL2") + SL1->L1_NUM)
	
	lSB1Posic := SB1->(DbSeek(xFilial("SB1")+SL2->L2_PRODUTO))
	
	//Se o produto de vendas estiver amarrado a um
	//produto de garantia add para imprimir Relatorio gerencial
	If lGE 
	 	If !Empty(SL2->L2_GARANT)
	 		aRelGer := LjxGetRGer()
			AADD(aRelGer, {SL2->L2_PRODUTO,SL2->L2_DESCRI,Str(a410Arred(SL2->L2_VRUNIT * SL2->L2_QUANT,"L2_VLRITEM"), TamSX3("L2_VLRITEM")[1],nDecsAux),SL2->L2_NSERIE})
			LjxSetRGer( aRelGer )

		ElseIf lSB1Posic .And. SB1->B1_TIPO == cMvLjTGar
			aRelGar := LjxGetRGar()
			AADD(aRelGar, {SL2->L2_PRODUTO,SL2->L2_DESCRI,Str(a410Arred(SL2->L2_VRUNIT * SL2->L2_QUANT,"L2_VLRITEM"), TamSX3("L2_VLRITEM")[1],nDecsAux),SL2->L2_NSERIE})
			LjxSetRGar( aRelGar )
		EndIf
	EndIf

	//Verifica configuracao do produto referente a Venda para Orgaos Publicos
	If lB1M996 .And. lSB1Posic .And. cB1M996 <> "1" 
		cB1M996	:=	SB1->(FieldGet(ColumnPos(cMV_B1M996)))
	EndIf

	If lSFinanc .AND. cMvLjTSF == SB1->B1_TIPO
		MG8->(DbSetOrder(2))
		If MG8->(DbSeek(xFilial("MG8")+SL2->L2_PRODUTO))
			If !Empty(MG8->MG8_RDMAKE)
				cImpRGer:=MG8->MG8_RDMAKE
			EndIf
		EndIf
	EndIf

	If Len(aProdAlter) > 0 .AND. lAlterOrc
		For nA := 1 To Len(aProdAlter)
			If !(lAchou)
				If (aProdAlter[nA][1] + aProdAlter[nA][2] == SL2->L2_ITEM + SL2->L2_PRODUTO)
					lAchou    := .T.
					lContinua := .T.
				Else
					lContinua := .F.
				EndIf
			EndIf
		Next nA
		lAchou := .F.
	EndIf

    If lContinua
		If Empty(SL2->L2_LOJARES)
			cLojaRes	:= cLojaLocal
		Else
			cLojaRes	:= SL2->L2_LOJARES
		EndIf
		//Inclui a Loja na Chave de Pesquisa
		cQuebra := cLojaRes
		//Quebra por lista de presentes
		If SL2->L2_ENTREGA <> "2"
			cQuebra += Alltrim(SL2->L2_CODLPRE)
		Endif
		//Inclui o Tipo de Entrega
		If Empty(SL2->L2_ENTREGA)
			cQuebra += "2"
		Else
			cQuebra += SL2->L2_ENTREGA
		EndIf
		If (!Empty(SL2->L2_ENTREGA) .AND. SL2->L2_ENTREGA <> "2")
			cFdtEntr := DtoS(SL2->L2_FDTENTR)
		Else
			cFdtEntr := Space(8)
		EndIf
		If (!Empty(SL2->L2_ENTREGA) .AND. SL2->L2_ENTREGA <> "2")
			cFdtMont := DtoS(SL2->L2_FDTMONT)
		Else
			cFdtMont := Space(8)
		EndIf
		If !Empty(SL2->L2_ENTREGA) .AND. SL2->L2_ENTREGA <> "2"
			cTurno	:= SL2->L2_TURNO
		Else
			cTurno	:= ""
		EndIf
		IF !Empty(SL2->L2_CODCONT)
			cCodCont	:= SL2->L2_CODCONT
		Else
			If Empty(Alltrim(SL2->L2_CLIENT + SL2->L2_CLILOJA))
				cCodCont	:= Left(SL1->L1_CLIENTE,TamSX3("L2_CLIENT")[1]) + SL1->L1_LOJA
			Else
				cCodCont	:= SL2->L2_CLIENT + SL2->L2_CLILOJA
			EndIf
		Endif
		// Loja + Tipo de Entrega + Contato
		If cTpQuebra == "2"
	        cQuebra += cCodCont
			nPos := Ascan(aLojas, {|x| x[3] + x[12] + x[6] + x[8] == cQuebra})

		//Loja + Tipo de Entrega + Data Entrega
		ElseIf cTpQuebra == "3"
			//Inclui a Data de Entrega
			cQuebra	+= cFdtEntr
			nPos := Ascan(aLojas, {|x| x[3] + x[12] + x[6] + x[7] == cQuebra})

		//Loja + Tipo de Entrega + Contato + Data Entrega
		ElseIf cTpQuebra == "4"
			//Inclui a Data de Entrega + o Codigo do Contato
			cQuebra	+= cFdtEntr + cCodCont
			nPos	:= Ascan(aLojas, {|x| x[3] + x[12] + x[6] + x[7] + x[8] == cQuebra})

		//Loja + Tipo de Entrega + Data Montagem
		ElseIf cTpQuebra == "5"
			//Inclui a Data de Montagem
			cQuebra	+= cFdtMont
			nPos	:= Ascan(aLojas, {|x| x[3] + x[12] + x[6] + x[10] == cQuebra})

		//Loja + Tipo de Montagem + Contato + Data Montagem
		ElseIf cTpQuebra == "6"
			//Inclui a Data de Montagem + o Codigo do Contato
			cQuebra	+= cFdtMont + cCodCont
			nPos	:= Ascan(aLojas, {|x| x[3] + x[12] + x[6] + x[10] + x[8] == cQuebra})

		//Loja + Tipo de Entrega + Contato + Data de entrega + Data Montagem
		ElseIf cTpQuebra == "7"
			//Inclui Codigo do Contato + Data de entrega + Data de Montagem
			cQuebra	+= cFdtEntr + cFdtMont + cCodCont
			nPos	:= Ascan(aLojas, {|x| x[3] + x[12] + x[6] + x[7] + x[10] + x[8] == cQuebra})

		//Loja + Tipo de Entrega + Contato + Data Entrega + Turno
		ElseIf cTpQuebra == "8"
			//Inclui a Data de Entrega + o Codigo do Contato + Turno
			cQuebra	+= cFdtEntr + cCodCont + cTurno
			nPos	:= Ascan(aLojas, {|x| x[3] + x[12] + x[6] + x[7] + x[8] + x[11] == cQuebra})

		//Loja + Tipo de Entrega
		Else
			nPos	:= Ascan(aLojas, {|x| x[3] + x[12] + x[6] == cQuebra})
		EndIf

		//Posiciona na Loja da Reserva
		If !SLJ->(DbSeek(xFilial("SLJ") + cLojaRes))
			//Verificação Lista de Presentes. Se estiver vendendo um item da Lista de Presentes
			//sem a Identificação de Lojas Cadastrada (SLJ) a venda nao sera concluida
			If lLstPre .AND. !lJob
    			lVerLojLst := .T.
            EndIf
            
            If nSLJRecno > 0 //Reposiciona no registro do inicio caso nao encontre
            	SLJ->(DBGoto(nSLJRecno))
            EndIf
        EndIf

		If nPos == 0
			Aadd( aLojas,{	SL1->L1_FILIAL	,;											// 01- Filial do orcamento original
							SL1->L1_NUM		,;											// 02- Numero do orcamento original
							cLojaRes		,;											// 03- Codigo da loja da reserva (SLJ)
							SLJ->LJ_RPCFIL	,;											// 04- Codigo da filial da reserva
							{SL2->L2_ITEM}	,;											// 05- Array com os itens de cada loja (filial)
							IIF(Empty(SL2->L2_ENTREGA),"2",SL2->L2_ENTREGA)	,;			// 06- Tipo de Entrega
							cFdtEntr		,;											// 07- Data Entrega
							cCodCont		,;											// 08- Codigo do Contato
							SL2->L2_RESERVA	,;											// 09- Reserva
							cFdtMont		,;											// 10- Data Montagem
							cTurno			,;											// 11- Turno de Entrega
							IIf(SL2->L2_ENTREGA <> "2",Alltrim(SL2->L2_CODLPRE),""),;	// 12- Lista de Presente
							SLJ->LJ_RPCFIL })											// 13- Codigo da filial de entrega onde sera gerado o pedido e o orcamento filho
		Else
			If Len(aProdAlter) == 0
				Aadd(aLojas[nPos][5], SL2->L2_ITEM)
			EndIF
		EndIf

		If ( SL2->L2_ENTREGA $ "1|3" )  .OR. (SL2->L2_ENTREGA == "2"	.AND. IIf(!Empty(SLJ->LJ_RPCFIL), SLJ->LJ_RPCFIL <> xFilial("SL1"),.F.)) // Armazena o valor dos itens de reserva
			nValRes += SL2->L2_VLRITEM
		EndIf

		aSL2 := {}
		If nPos == 0
			nPos := Len(aLojas)
		EndIf
		aAdd( aSL2, { "L2_FILRES"	, aLojas[nPos][4] } )
		aAdd( aSL2, { "L2_RESERVA"	, SL2->L2_RESERVA} )

		//Release 11.5 - Chile - Guia de Despacho - F2CHI
		//Limpar L2_DOC e L2_SERIE dos itens do orcamento pai,
		//pois os dados da factura com os itens de venda em que o
		//tipo de entrega seja 3 serao atualizados no orcamento filho.
		If lCFolLocR5 .AND. cPaisLoc == "CHI"  .AND. (cTpGeraGdp $ GDP_PARCIAL + ";" + GDP_TOTAL)
			aAdd( aSL2, { "L2_DOC"	, "" } )
			aAdd( aSL2, { "L2_SERIE", "" } )
		EndIf

		If (lEmitNfce .Or. lIsPafNfce) .AND. !Empty(SL2->L2_ORIGEM)
			aAdd( aSL2, { "L2_ORIGEM", SL2->L2_ORIGEM} )
		EndIf

		If (lEmitNfce .Or. lIsPafNfce) .AND. !Empty(SL2->L2_MODBC)
			aAdd( aSL2, { "L2_MODBC", SL2->L2_MODBC} )
		EndIf

		If !Empty(SL2->L2_CODISS)
			aAdd( aSL2, { "L2_CODISS", SL2->L2_CODISS} )
		EndIf

		If (lEmitNfce .Or. lIsPafNfce) .AND. !Empty(SL2->L2_POSIPI)
			aAdd( aSL2, { "L2_POSIPI", SL2->L2_POSIPI} )
		EndIf

		Lj7GeraSL( "SL2", aSL2 )

	EndIf

	//Release 11.5 - Controle de Formularios - F2CHI
	//Verificar quais os tipos de entrega sao validos para impressao de comprovante de venda para cada pais localizado.
	//Paises: Chile/Colombia
	If lCFolLocR5 .AND. !lJob
		Do Case
		Case cPaisLoc == "COL"
			If SL2->L2_ENTREGA $ "1|3"
				lImpCNFLoc := .T.
			EndIf
		Case cPaisLoc == "CHI"
			If SL2->L2_ENTREGA ==  "1"
				lImpCNFLoc := .T.
			EndIf
		EndCase
	EndIf

	//Verificação Lista de Presentes. Se estiver vendendo um item da Lista de Presentes sem a 
	//Identificação de Lojas Cadastrada (SLJ) a venda nao sera concluida
	If lVerLojLst .AND. !lJob .AND. !Empty(SL2->L2_CODLPRE)
		lFecVenLst := .T.
	EndIf

	//Nos casos de PDV offline, faz o backup de cada registro, pois se houver algum erro,
	//o registro poderá ser recuperado através da função, pois em DBF não há Controle de Transação
	If lMVLJPDVPA
		Aadd( aBkpSL2, LjBkpReg("SL2") )
	EndIf

	SL2->( DbSkip() )
End

If lMVLJPDVPA
	Aadd(aBkpTable, {"SL2", aBkpSL2} )
EndIf

//Lista de Presentes
//Caso tenha encontrado algum produto que seja de Lista de Presentes e não tenha identificacao de lojas cadastrada.
//Exibe mensagem ao usuário e Finaliza operacao sem completar a Venda.
If lFecVenLst
	If !lAutoExC
		MsgStop(STR0159)
	Else
    	Conout(STR0159)
    	Help( " ", 1, "Help",, STR0159, 1, 0 )
 	Endif
    lLj7TudoOK := .F.
EndIf

If lLj7TudoOK
	Begin Sequence
		//Ponto de Entrada para geracao de quebras nos Orcamentos Filho
		If lLj7049 .AND. !lFtvdVer12
			aBkpLoja	:= aClone(aLojas)
			uLJPERet	:= U_LJ7049(aLojas)
			If ValType(uLJPERet) == "A"
				aLojas	:= aClone(uLJPERet)
			EndIf
		EndIf
	
		If lFTVD7049 .AND. lFtvdVer12
			aBkpLoja	:= aClone(aLojas)
			uLJPERet	:= U_FTVD7049(aLojas)
			If ValType(uLJPERet) == "A"
				aLojas	:= aClone(uLJPERet)
			EndIf
		EndIf
	
	Recover
		aLojas := aClone(aBkpLoja)
	End Sequence
	
	//Caso L1_DOCPED em branco
	If Len(aLojas) > 0
		If Empty(SL1->L1_DOCPED) .AND. lJob
			
			aAuxLoja := {}
			 
			For nX := 1 to Len(aLojas)
				If !Empty(aLojas[nX][9]) .AND. aLojas[nX][6] <> "2"
					lVendErro := .T.
				EndIf
				
				If lVendErro .And. aLojas[nX][6] == "2" .And. SL1->L1_VENDTEF == "N"
					aAdd(aAuxLoja,aLojas[nX])
				EndIf
			Next nX
	
			If lVendErro .AND. SL1->L1_VENDTEF == "N"
	
				Reclock( "SL1", .F. )
				REPLACE SL1->L1_STATUS 	WITH "T"
				SL1->( MsUnlock() )
	
				aBkpLoja := aClone(aAuxLoja)
	
				If Len(aBkpLoja) > 0
					aLojas := {}
					aLojas := aClone(aBkpLoja)
				EndIf
			EndIf
		EndIf
	EndIf


	// 3 - Recalcula impostos, descontos, rateios ,arredondamentos	
	If cPaisLoc == "BRA"
		//Executa o recalculo das tributacoes da venda (aqui serao utilizados os arrays aSL1 e aSL2
		Lj7RecTrib(	NIL		,	NIL,	nFrete	, NIL	,;
					lJob	,	NIL, 	NIL		, NIL	,;
					@nValRes,	NIL,	NIL		, aTaxJuros	)
	EndIf
		
	LjGrvLog(SL1->L1_NUM,"GERACAO DOS PEDIDOS LJRECTRIB ")
		
	//Trata os valores com reserva
	If nValRes > 0
		nFatorVen := Lj7FatRes(nValRes, SL1->L1_VLRLIQ,nFrete)[1]
		nFatorRes := Lj7FatRes(nValRes, SL1->L1_VLRLIQ,nFrete)[2]
	EndIf

	//Gera os arrays depois do recalculo dos valores (aqui sera utilizado o
	//array aSL4 e os aSL1 e aSL2 para gravacao do orcamento na loja onde originou o orcamento
	LjGrvLog(Nil,'Geração das tabelas filhas do pedido')
	For nX := 1 to Len(aLojas)
		//Marca se ultimo orcamento
		If nX == Len(aLojas)
			lLastOrc := .T.
		Else
			lLastOrc := .F.
		EndIf

		//Posiciona o orcamento no original
		DbSelectArea("SL1")
		SL1->(DbSetOrder(1))
		SL1->(DbSeek(aLojas[nX][1]+aLojas[nX][2]))

		//Gera os arrays (aSL1, aSL2 e aSL4) com os dados de cada orcamento
		aArquivos := Lj7GeraOrc(aLojas[nX][5]	, lJob		, aAuxaPgtos, aLojas[nX][6]	,;
								lAlterOrc		, nFatorVen	, nFatorRes	, lLastOrc		,;
								@nCredito		, aSL4Total )

		aAdd( aArqAux2, { aClone(aLojas[nX]), aArquivos } )
	
	Next nX
	LjGrvLog(Nil,'Final Geração das tabelas filhas do pedido')
EndIf

aRet := {lLj7TudoOK, aClone(aArqAux2)}

Return aRet

//----------------------------------------------------------
/*/{Protheus.doc} lj7ImpPed
Função responsável imprimir o comprovante nao fiscal quando venda
com item entrega

@type		function
@author		felipe.martinez
@version	P12.1.14
@since		02/03/2017
@return 	aRetCNF:[1] - Impresso com sucesso
					[2,1] - Numero do Documento
					[2,2] - Numero do PDV  
/*/
//----------------------------------------------------------
Static Function lj7ImpPed(	lTefOk	, lJob		, nFatorRes	, lImpCNFLoc	,;
							nOpc 	, cTxtNFis	)
Local aRetCNF		:= {.T., {"", ""}}					// Array com o retorno da funcao Lj7ImpCNF()
Local lAutoExC 		:= IsBlind()						// Verifica se a rotina sera executada via execauto ou nao
Local cImpFisc		:= LjGetStation( "LG_IMPFISC" )		// Retorna a impressora fiscal
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida


Default lTefOk		:= .F.
Default lJob		:= .F.
Default nFatorRes	:= 0
Default lImpCNFLoc	:= .F.
Default nOpc		:= 0

If lCFolLocR5
	//Paises: Chile/Colombia - Controle de Formularios - F2CHI 
	//Imprime comprovante de venda para as localizacoes mesmo sem a obrigacao de ter uma impressora fiscal configurada.
	If !lJob .And. aRetCNF[1] 
		aRetCNF := Lj7ImpCNF( lTefOk, nFatorRes )
		If lImpCNFLoc .And. !LjProfile(28)
			If !Lj7ImpLoc (NIL,aRetCNF,nOpc,lImpCNFLoc)
				If !lAutoExC
					Aviso( STR0007, STR0014, {STR0005} ) //"Atenção"###"Houve erros na impressão do comprovante de venda. VerIfique a impressora."###"Ok"
				Else
					Conout( STR0007 + " - " +STR0014 ) //"Atenção"###"Houve erros na impressão do comprovante de venda. VerIfique a impressora."###"Ok"
				Endif
				aRetCNF := {.F., {"", ""}}  
			EndIf
		EndIf
	EndIf

ElseIf !lJob .And. aRetCNF[1] .And. !Empty( cImpFisc ) 
	//Faz a impressao do cupom nao fiscal (comprovante da venda) e se houver impressora configurada
	If !lAutoExC
		LjMsgRun( STR0013,, {|| (aRetCNF := Lj7ImpCNF( lTefOk, nFatorRes , NIL		, NIL ,;
		 											  	NIL  , NIL		 , NIL		, NIL ,;
		 											  	NIL  , NIL		 , NIL		, NIL ,;
		 											  	NIL  , NIL		 , @cTxtNFis )) } ) //"Aguarde ... imprimindo o comprovante de venda ...."
	Else
		aRetCNF := Lj7ImpCNF( lTefOk, nFatorRes )
	EndIf

ElseIf 	lFtvdVer12
	//Gerar Pedido de Venda -  Valido somente p/ modulo SIGAFAT
	If aRetCNF[1] .AND. !lJob .AND. nModulo == 5
		If Type("lAutoExec") <> "L" .OR. !lAutoExec
			LjMsgRun( STR0142,, {|| (aRetCNF := Lj7ImpCNF( lTefOk )) } ) //"Aguarde ... gerando pedido de venda ...."
		Else
			aRetCNF := Lj7ImpCNF( lTefOk )
		EndIf
	EndIf
EndIf

Return aClone(aRetCNF)

//----------------------------------------------------------
/*/{Protheus.doc} Lj7AtuPed
Função responsável por atualizar informacoes do orcamento original 
da venda (pai).

@type		function
@author		felipe.martinez
@version	P12.1.14
@since		02/03/2017
@return 	Nil
/*/
//----------------------------------------------------------
Static Function Lj7AtuPed(	lJob		, aRetCNF	, cDocPed	, cSeriePed	,;
							cTpGeraGdp	, cDocPai	, cSeriePai	, lTefOk	,;
							aNSUVndTef	, lAvCred	, cLojaLocal, lTefManuPed)
Local lHVerao		:= SuperGetMv("MV_HVERAO",,.F.)					// Se o local fisico do servidor está em Horário de Verão(.F.->Não/.T.->Sim)
Local cHoraRMT		:= SuperGetMv("MV_HORARMT",,"2")
Local lECommerce	:= SuperGetMV("MV_LJECOMM",,.F.) .And. SL1->L1_ECFLAG == "1" // Tratamento para eCommerce
Local cNSUVndTef	:= ""
Local nX			:= 0
Local nPosDTEF		:= 0
Local nCont			:= 0
Local aArea2		:= {}
Local aAreaSM0		:= {}
Local aTimeUf		:= {}
Local aSL1			:= {}
Local aSL4			:= {}
Local aDTEFPend		:= {}											// Transacoes Pendentes Direcao
Local lIsDiscado	:= L010IsDirecao(L010GetGPAtivo())
Local lVerEmpres    := Lj950Acres(SM0->M0_CGC)				    	// Verifica as filiais da trabalharam com acrescimento separado
Local cL1NSUTEF		:= ""
Local cL4NSUTEF		:= ""
Local lTefMult		:= SuperGetMV("MV_TEFMULT", ,.F.)		// Identifica se o cliente utiliza múltiplas transacoes TEF

Default lJob		:= .F.
Default aRetCNF		:= {.F., {"", ""}}
Default cDocPed		:= ""
Default cSeriePed	:= ""
Default cTpGeraGdp	:= GDP_NO						              	// Informa como sera gerada Guia de Despacho a partir do pedido de venda.
Default cDocPai		:= ""
Default cSeriePai	:= ""
Default lTefOk		:= .F.
Default aNSUVndTef	:= {}
Default lAvCred		:= .F.
Default cLojaLocal	:= ""
Default lTefManuPed :=.F. 											// Verifica se utiliza TEF Manual e se será executado o cancelamento da venda qdo pedido.

If ValType(cHoraRMT) == "L"
	If cHoraRMT
		cHoraRMT := "1"
	Else
		cHoraRMT := "2"
	EndIf
Else
	If cHoraRMT == NIL
		cHoraRMT := "2"
	EndIf
EndIf

//Faz a gravacao do SL1
IF !lJob
	If cHoraRMT == "3" .And. cPaisLoc == "BRA" // Data de Emissao do pedido
		aArea2		:= GetArea()
		dbSelectArea("SM0")
		aAreaSM0	:= GetArea()
		dbSetOrder(1)
		If dbSeek(cEmpAnt+cFilAnt)
			aTimeUf	:= FwTimeUF(SM0->M0_ESTENT,,lHVerao)
		EndIf
		RestArea(aAreaSM0)
		RestArea(aArea2)
		aAdd( aSL1, { "L1_EMISNF", STOD(aTimeUf[1]) } )
	Else
		aAdd( aSL1, { "L1_EMISNF", dDatabase } )
	EndIf
	aAdd( aSL1, {"L1_NUMMOV", LJNumMov()} )					// Num do Mov para considerar no resumo de caixa
EndIf

aAdd( aSL1, {"L1_TIPO"		, "P"} )						// Indica que tem reserva
aAdd( aSL1, {"L1_RESERVA"	, "S"} )						// Indica que tem reserva
aAdd( aSL1, {"L1_OPERADO"	, IIf(!lJob,xNumCaixa(),SL1->L1_OPERADO)} )	// Operador
aAdd( aSL1, {"L1_PDV"		, aRetCNF[2][2]	} )				// Numero do PDV

If !Empty(cDocPed)
	aAdd( aSL1, {"L1_DOCPED"	, cDocPed } )					// Numero do cupom nao fiscal (pedido)
EndIf	

cDocPed := aRetCNF[2][1]

If  lECommerce
	aAdd( aSL1, {"L1_SERPED",  SL1->L1_SERPED} )  //Ja gravado anteriormente

ElseIf lCFolLocR5 .AND. !Empty(SuperGetMV("MV_LOJAPED"))
	//Paises: Chile/Colombia - Controle de Formularios
	//Obter numero do documento e serie informados no parametro MV_LOJAPED.
	// Numero do serie do cupom nao fiscal (pedido)
	aAdd( aSL1, {"L1_SERPED", If(Len(aRetCNF[2])==3 .AND. !Empty(aRetCNF[2]),aRetCNF[2][3],SuperGetMV("MV_LOJAPED"))} )
ElseIf !lJob
	aAdd( aSL1, {"L1_SERPED", If(Len(aRetCNF[2])==3,aRetCNF[2][3],LjGetStation("LG_SERIE"))} )	// Numero do serie do cupom nao fiscal (pedido)
	cSeriePed := If(Len(aRetCNF[2])==3,aRetCNF[2][3],LjGetStation("LG_SERIE"))
EndIf

If lJob
	aAdd( aSL1, {"L1_NUMFRT"	, SL1->L1_NUMFRT} )
	aAdd( aSL1, {"L1_SITUA"		, "FR"} )

	//Chile - Guia de Despacho - F2CHI
	//Quando o job estiver em execucao subindo a venda de um item com entrega do tipo 3 , guardar L1_DOC e L1_SERIE do orcamento
	//pai pois estes de dados serao utilizados na geracao do orcamento filho.
	If lCFolLocR5 .AND. cPaisLoc == "CHI" .AND. (cTpGeraGdp $ GDP_PARCIAL + ";" + GDP_TOTAL)
		cDocPai 	:= SL1->L1_DOC
		cSeriePai	:= SL1->L1_SERIE
		aAdd( aSL1, {"L1_DOC"		, ""} )
		aAdd( aSL1, {"L1_SERIE"		, ""} )
		aAdd( aSL1, {"L1_IMPRIME"	, "1N"} )
	EndIf
EndIf

//Limpamos os campos L1_DOC e L1_SERIE, pois quando uma venda com itens reservados era enviado a retaguarda, os campos L1_DOC
//e L1_DOCPED do orcamento pai estavam preenchidos, sendo que soh o campo L1_DOCPED deveria, ja que se trata de um CNF.
//Isso impactava na geracao do SPED, pois ele trazia vendas repetidas, pelo fato do L1_DOC aparecer em mais de uma venda.
If cPaisLoc == "BRA" .AND. !Empty( SL1->L1_DOCPED )
	aAdd( aSL1, {"L1_DOC"	, ""} )
	aAdd( aSL1, {"L1_SERIE"	, ""} )
EndIf

If lUsaTef .AND. lTefOk
	If cTipTef == TEF_CLISITEF
	
		//Efetua a alteracao das datas e conf. de ADM informadas durante o processamento do TEF
		LjTEFAceParc()


		//Gerando os dados do TEF para a tabela SL1
		aSL1 := LjTEFGeraSL(aSL1,"SL1")

	ElseIf cTipTef $ TEF_SEMCLIENT_DEDICADO + ";" + TEF_COMCLIENT_DEDICADO + ";" + TEF_DISCADO
		aAdd( aSL1, { "L1_VENDTEF","S"})
		aAdd( aSL1, { "L1_DATATEF",aTefDados[1][2]})
		aAdd( aSL1, { "L1_HORATEF",aTefDados[1][3]})
		aAdd( aSL1, { "L1_DOCTEF" ,aTefDados[1][4]})
		aAdd( aSL1, { "L1_AUTORIZ",aTefDados[1][5]})
		aAdd( aSL1, { "L1_INSTITU",aTefDados[1][8]})
		aAdd( aSL1, { "L1_DOCCANC",aTefDados[1][6]})
		aAdd( aSL1, { "L1_DATCANC",aTefDados[1][12]})
		aAdd( aSL1, { "L1_HORCANC",aTefDados[1][7]})
		aAdd( aSL1, { "L1_NSUTEF" ,aTefDados[1][9]})
		aAdd( aSL1, { "L1_TIPCART",aTefDados[1][10]})
		If !Empty(aTefDados[1][15])
			aAdd( aSL1, { "L1_FORMPG",aTefDados[1][15]})
		EndIf
		
		aAdd(aSL1,{"L1_TEFBAND"	, aTefDados[1][18]})
	EndIf
Else
	If Len(aNSUVndTef) > 0
		cNSUVndTef	:= aNSUVndTef[1][4]
		If !Empty(AllTrim(cNSUVndTef))
			cL1NSUTEF := cNSUVndTef
			aAdd( aSL1, { "L1_VENDTEF", "S"})
			aAdd( aSL1, { "L1_DOCTEF" , cNSUVndTef } )
			aAdd( aSL1, { "L1_NSUTEF" , cL1NSUTEF } )
			aAdd( aSL1, { "L1_DATATEF", Str(Year(dDataBase),4)+StrZero(Month(dDataBase),2)+StrZero(Day(dDataBase),2) } )
		Else
			LjGrvLog(Nil,"Atenção: Tela de NSU foi aberta porem não foi digitado um numero de transacao. SL1 será gravada sem dados de TEF Manual")
		EndIf
	EndIf
EndIf

If !lJob
	LjGrvLog( M->LQ_NUM ,'Gera SL1', aSL1)
EndIf

Lj7GeraSL( "SL1", aSL1, .F., .F. )

If !lJob
	LjGrvLog( M->LQ_NUM ,'Gera SL4')
EndIf

//Faz a gravacao do SL4
If cTipTEF == TEF_DISCADO  .AND. lIsDiscado
	aDTEFPend :=  LJLoadDTEF()
EndIf

For nX := 1 to Len( aPgtos )
	aAdd( aSL4, {} )
	aAdd( aSL4[nX], { "L4_FILIAL"	, xFilial("SL4") } )
	aAdd( aSL4[nX], { "L4_NUM"		, SL1->L1_NUM	} )
	aAdd( aSL4[nX], { "L4_DATA"		, aPgtos[nX][1] } )
	aAdd( aSL4[nX], { "L4_VALOR"	, aPgtos[nX][2] } )
	aAdd( aSL4[nX], { "L4_FORMA"	, aPgtos[nX][3] } )

	If !IsMoney(aPgtos[nX][3]) .AND. !lLayAway
		If Trim(aPgtos[nX][3]) == "CH"
			aAdd( aSL4[nX], { "L4_ADMINIS"	, aPgtos[nX][4][04] } )
			aAdd( aSL4[nX], { "L4_NUMCART"	, aPgtos[nX][4][07] } )
			aAdd( aSL4[nX], { "L4_AGENCIA"	, aPgtos[nX][4][05] } )
			aAdd( aSL4[nX], { "L4_CONTA"	, aPgtos[nX][4][06] } )
			aAdd( aSL4[nX], { "L4_RG"		, aPgtos[nX][4][09] } )
			aAdd( aSL4[nX], { "L4_TELEFON"	, aPgtos[nX][4][10] } )
			aAdd( aSL4[nX], { "L4_COMP"   	, aPgtos[nX][4][08] } )
			aAdd( aSL4[nX], { "L4_TERCEIR"	, aPgtos[nX][4][12] } )
			aAdd( aSL4[nX], { "L4_NOMECLI"	, aPgtos[nX][4][14] } )
		Else
			If Len(aPgtos[nX][4]) >= 5 .AND. cTipTEF <> TEF_DISCADO
				aAdd( aSL4[nX], { "L4_ADMINIS"	, aPgtos[nX][4][05] } )
				aAdd( aSL4[nX], { "L4_NUMCART"	, aPgtos[nX][4][04] } )
			EndIf
		EndIf
	EndIf

	//Grava o valor do acrescimo separado da parcela
	If lVerEmpres .OR. (SuperGetMV("MV_LJICMJR",,.F.) .AND. cPaisLoc == "BRA")
    	If Len(aPgtos[nX][4]) >= 13 .AND. ValType(aPgtos[nX][4][13]) == "N"
			aAdd( aSL4[nX], { "L4_ACRSFIN"	, aPgtos[nX][4][13] } )
		Endif
	Endif

	// ALTERACAO PARA GRAVACAO DOS DADOS DO TEF NO SL4
	aAdd( aSL4[nX], { "L4_VENDTEF","N" })

	If lUsaTef .AND. lTefOk
		If cTipTef == TEF_CLISITEF

			//³Gerando os dados do TEF para a tabela SL4
			aSL4 := LjTEFGeraSL( 	aSL4			, "SL4"	, Nil, aPgtos[nX, 3]	, ;
									aPgtos[nX, 8]	, Nil	, Nil, Nil				, ;
									Nil				, nX )

		ElseIf cTipTef $ TEF_SEMCLIENT_DEDICADO + ";" + TEF_COMCLIENT_DEDICADO + ";" + TEF_DISCADO

			If (nPos := Ascan( aTefMult,{|x| Ascan(x[10],StrZero(nX,2))>0 }) ) <> 0
				If Len( aTefMult[nPos][7] ) > 0
					aTefDados:=aClone(aTefMult[nPos][7])
					aAdd( aSL4[nX], { "L4_VENDTEF","S"})
					aAdd( aSL4[nX], { "L4_DATATEF",aTefDados[1][2]})
					aAdd( aSL4[nX], { "L4_HORATEF",aTefDados[1][3]})
					aAdd( aSL4[nX], { "L4_DOCTEF" ,aTefDados[1][4]})
					aAdd( aSL4[nX], { "L4_AUTORIZ",aTefDados[1][5]})
					aAdd( aSL4[nX], { "L4_INSTITU",aTefDados[1][8]})
					aAdd( aSL4[nX], { "L4_DOCCANC",aTefDados[1][6]})
					aAdd( aSL4[nX], { "L4_DATCANC",aTefDados[1][12]})
					aAdd( aSL4[nX], { "L4_HORCANC",aTefDados[1][7]})
					aAdd( aSL4[nX], { "L4_NSUTEF" ,aTefDados[1][9]})
					aAdd( aSL4[nX], { "L4_TIPCART",aTefDados[1][10]})
					If !Empty(aTefDados[1][15])
						aAdd( aSL4[nX], { "L4_FORMPG",aTefDados[1][15]})
					EndIf
				EndIf
			ElseIf cTipTEF == TEF_DISCADO  .AND. lIsDiscado  .AND.;
			 		Trim(aPgtos[nX][3]) $ _FORMATEF .AND. Len(aDTEFPend) > 12
			 		
				nPosDTEF := aScan(aDTEFPend, {|t| t[14] == aPgtos[nX, 8] })
				If nPosDTEF > 0  //5
					aAdd(aSL4[nX], { "L4_VENDTEF","S"})
					aAdd(aSL4[nX], { "L4_DATATEF",aDTEFPend[nPosDTEF][10]})
					aAdd(aSL4[nX], { "L4_HORATEF",aDTEFPend[nPosDTEF][11]})
					aAdd(aSL4[nX], { "L4_DOCTEF" ,aDTEFPend[nPosDTEF][13]})
					aAdd(aSL4[nX], { "L4_AUTORIZ",aDTEFPend[nPosDTEF][13]})
					aAdd(aSL4[nX], { "L4_NSUTEF" ,Right(aDTEFPend[nPosDTEF][7],6)})
				EndIf

			ElseIf cTipTEF == TEF_DISCADO .AND. Alltrim(aPgtos[nX][3]) $ _FORMATEF
				If lTefMult
					nPosTefDados := aScan(aTefDados,{|x|,Alltrim(x[20])== Alltrim(aPgtos[nX][3]) .AND. Alltrim(x[19]) == Alltrim(aPgtos[nX][8])})
					If Len(aTEFDados) >= 1 .AND. Len(aTEFDados[1]) >= 15
						aAdd( aSL4[nX], { "L4_VENDTEF","S"})
						aAdd( aSL4[nX], { "L4_DATATEF",aTefDados[nPosTefDados][2]})
						aAdd( aSL4[nX], { "L4_HORATEF",aTefDados[nPosTefDados][3]})
						aAdd( aSL4[nX], { "L4_AUTORIZ",aTefDados[nPosTefDados][5]})
						aAdd( aSL4[nX], { "L4_INSTITU",aTefDados[nPosTefDados][8]})
						aAdd( aSL4[nX], { "L4_DOCCANC",aTefDados[nPosTefDados][6]})
						aAdd( aSL4[nX], { "L4_DATCANC",aTefDados[nPosTefDados][12]})
						aAdd( aSL4[nX], { "L4_HORCANC",aTefDados[nPosTefDados][7]})
						If lIsDiscado
							aAdd( aSL4[nX], { "L4_NSUTEF" ,Right(aTefDados[nPosTefDados][9],6)})
							aAdd( aSL4[nX], { "L4_DOCTEF" ,aTefDados[nPosTefDados][5]})
						Else
							aAdd( aSL4[nX], { "L4_NSUTEF" ,aTefDados[nPosTefDados][9]})
							aAdd( aSL4[nX], { "L4_DOCTEF" ,aTefDados[nPosTefDados][4]})
						EndIf
						aAdd( aSL4[nX], { "L4_TIPCART",aTefDados[nPosTefDados][10]})
						If !Empty(aTefDados[1][15])
							aAdd( aSL4[nX], { "L4_FORMPG",aTefDados[nPosTefDados][20]})
						EndIf
						aAdd( aSL4[nX], { "L4_ADMINIS"	, aPgtos[nX][4][05] } )
					EndIf
				Else
					// Se estiver usando Pay&Go e MV_TEFMULT = .F. faz tratamento para preencher a array aSL4 a partir do aTefDados
					If Len(aTEFDados) >= 1 .AND. Len(aTEFDados[1]) >= 15
						aAdd( aSL4[nX], { "L4_VENDTEF","S"})
						aAdd( aSL4[nX], { "L4_DATATEF",alltrim(aTefDados[1][2])})
						aAdd( aSL4[nX], { "L4_HORATEF",alltrim(aTefDados[1][3])})
						aAdd( aSL4[nX], { "L4_AUTORIZ",alltrim(aTefDados[1][5])})
						aAdd( aSL4[nX], { "L4_INSTITU",alltrim(aTefDados[1][8])})
						aAdd( aSL4[nX], { "L4_DOCCANC",alltrim(aTefDados[1][6])})
						aAdd( aSL4[nX], { "L4_DATCANC",alltrim(aTefDados[1][12])})
						aAdd( aSL4[nX], { "L4_HORCANC",alltrim(aTefDados[1][7])})
	
						If lIsDiscado
							aAdd( aSL4[nX], { "L4_NSUTEF" ,alltrim(aTefDados[1][9])})
							aAdd( aSL4[nX], { "L4_DOCTEF" ,alltrim(aTefDados[1][5])})
						Else
							aAdd( aSL4[nX], { "L4_NSUTEF" ,alltrim(aTefDados[1][9])})
							aAdd( aSL4[nX], { "L4_DOCTEF" ,alltrim(aTefDados[1][4])})
						EndIf
						aAdd( aSL4[nX], { "L4_TIPCART",alltrim(aTefDados[1][12])})
						If !Empty(aTefDados[1][15])
							aAdd( aSL4[nX], { "L4_FORMPG",alltrim(aTefDados[1][20])})
						EndIf
						aAdd( aSL4[nX], { "L4_ADMINIS"	,aPgtos[nX][4][05] } )
					EndIf
				EndIf
			EndIf
		EndIf
	Else
		If AllTrim(aPgtos[nX][3]) $ _FORMATEF .And. Len(aNSUVndTef) > 0
			nY := Ascan(aNSUVndTef, {|x| AllTrim(x[1])+x[2] == AllTrim(aPgtos[nX][3])+aPgtos[nX][8]}) //Forma + ID
			cNSUVndTef := IIf( nY > 0 , aNSUVndTef[nY][4], "")
			If !Empty(AllTrim(cNSUVndTef))

				If (Alltrim( aPgtos[nX][3] ) $ _FORMATEF) .AND. cTipTef == TEF_CLISITEF .AND. lUsaTEF
				    // Chama a LjVerAdm para ajustar o array aPgtos na posicao referente ao Cod Adm Financeira
					LjVerAdm(.F.,.T.,lTefManuPed,nX,lTefManuPed)
				Endif

				cL4NSUTEF := cNSUVndTef
				aAdd( aSL4[nX], { "L4_VENDTEF", "S"})
				aAdd( aSL4[nX], { "L4_DOCTEF" , cNSUVndTef } )
				aAdd( aSL4[nX], { "L4_NSUTEF" , cL4NSUTEF } )
				aAdd( aSL4[nX], { "L4_DATATEF", Str(Year(dDataBase),4)+StrZero(Month(dDataBase),2)+StrZero(Day(dDataBase),2) } )
				aAdd( aSL4[nX], { "L4_ADMINIS", aPgtos[nX][4][05] } )
			Else
				LjGrvLog(Nil,"ATENCAO: NSU digitada não encontrada ou  " +;
							 "NSU não digitado (na tela). SL4 será gravada sem dados de TEF Manual")				
			EndIf
		EndIf
	EndIf
	
	If cPaisLoc <> "BRA"
	   aAdd( aSL4[nX], { "L4_MOEDA", aPgtos[nX][_MOEDA] } )
	EndIf
	//FIM DA ALTERACAO PARA GRAVACAO DOS DADOS DO TEF NO SL4
Next nX

nCont := 1
DbSelectArea("SL4")
SL4->(DbSetOrder(1)) //"L4_FILIAL+L4_NUM+L4_ORIGEM"
SL4->(DbSeek( xFilial("SL4") + SL1->L1_NUM ))
While !SL4->(Eof()) .AND. SL4->L4_FILIAL + SL4->L4_NUM == xFilial("SL4") + SL1->L1_NUM .AND. Empty( SL4->L4_ORIGEM )
	If nCont <= Len( aSL4 )
    	Lj7GeraSL( "SL4", aSL4[nCont] )
 	Else
 		RecLock("SL4",.F.)
 		SL4->(DbDelete())
 		SL4->(MsUnlock())
 	EndIf

	// Variavel que controla analise de credito para o pedido.
	If IsMoney(SL4->L4_FORMA) .OR. AllTrim(SL4->L4_FORMA) $ _FORMATEF
		lAvCred := .T. // Alteração temporária, pois verificamos que passando como falso está bloqueando o credito.
	EndIf

   	SL4->(DbSkip())
	nCont ++
End

For nX := nCont To Len( aSL4 )
	Lj7GeraSL( "SL4", aSL4[nCont], .T. )
Next nX

Return Nil

//----------------------------------------------------------
/*/{Protheus.doc} LJ7GrvFilh
Função responsável por gravar os orcamento filhos e gerar o 
pedido de venda

@type		function
@author		felipe.martinez
@version	P12.1.14
@since		02/03/2017
@return 	Nil
/*/
//----------------------------------------------------------
Static Function LJ7GrvFilh(	aArqAux2	, aArquivos	, lJob		, cTpGeraGdp,;
							cDocPai		, cSeriePai	, aRetCNF	, cImpRGer	,;
							lVendErro	, lAlterOrc	, cNumPai	, lAvCred	,;
							aOrcRetira	, aPedidos	, cLojaLocal, cDocPed	,;
							cSeriePed)
Local lRet			:= .T.
Local lSemFrete 	:= .F.			// Define se o item tem frete ou não
Local lItemNormal 	:= .F.          // Valida o item que não seja Reserva, garantia ou serviço
Local lItLstPresC	:= .F.			// Item de lista de presente de CREDITO
Local lExistVfe		:= .F.			// Verifica se cenario contempla VFE
Local lValidVfe		:= .T. 			// PE para validar se executa VFE
Local nX			:= 0
Local nI			:= 0
Local nY			:= 0
Local nPos			:= 0
Local nPos1			:= 0
Local nPos2			:= 0
Local nConta		:= 0
Local nPosCodProd   := 0			// Posicao do produto
Local nPosReserv    := 0   			// Posicao da reserva
Local nTamOrc		:= 0			// Tamanho do campo de orcamento (LQ_NUMORC)
Local nCont			:= 0 
Local aLojas		:= {}
Local aRelGer		:= {}
Local aRelGar		:= {}
Local aRet			:= {}
Local aAreaCDL		:= {} 			// Guarda a area atual
Local aSL2			:= {}
Local cCodProd      := ""			// Codigo do produto
Local cCodReserv  	:= ""           // Codigo da reserva
Local cRetRelG		:= ""			// Retorno do relatorio gerencial
Local cTipoLista	:= ""			// Tipo da lisya de presente
Local cCliente		:= "" 			// Codigo do Cliente
Local cLojaCli		:= "" 			// Loja do Cliente
Local cCliEnt		:= "" 			// Cliente de Entrega
Local cLojEnt		:= "" 			// Loja do Cliente de Entrega
Local cUFCli		:= ""
Local cUfCD			:= ""
Local cCodCdLocal	:= ""			// Codigo de Identificacao do CD Local
Local cFilLoc		:= "" 			// Loja em que foi feita a Reserva
Local cFilRES 		:= "" 			// Filial em que foi feita a Reserva
Local cSerOrc		:= ""			// Série do orçamento
Local lAutoExC 		:= IsBlind()
Local lGE		 	:= LjUP104OK() .And. SuperGetMv("MV_LJIMPGF",,.F.)	// Validação do Conceito Garantia Estendida
Local lCentroDL		:= SuperGetMv("MV_LJCDL",, .F.)						// Parametro de controle VFE
Local lCen1VFE	 	:= LjAnalisaLeg(69)[1] .And. SuperGetMv("MV_LJC1VFE", Nil, .F.)	//Especifico para Minas Gerais = Cenario 1 - Loja da Venda
Local lLJ7058		:= ExistBlock("LJ7058") // Se existe o PE LJ7058. Esse ponto de entrada tem como objetivo permitir que o cliente crie uma única OS para todo o pedido, evitando a quebra da OS pelo parâmetro MV_LJTPPED
Local lLjInTec    	:= SuperGetMV("MV_LJINTEC",,'2') == '1'			// Define se existe integracao com Field Service
Local cTipoGE		:= SuperGetMV("MV_LJTPGAR",,"GE")// Define se o Produto é GE
Local cTipoSF		:= SuperGetMV("MV_LJTPSF",,"SF") //	Define se o Produto é SF
Local lVldGESF		:= .T.							 //Variavel de controle:  existe GE ou  SF? 
Local lIntegDef		:= If(Type("lAutoExec") == "L", lAutoExec, .F.) .And. FWHasEAI("LOJA701",, .T., .T.) .AND. IIF( ExistFunc("Lj701GtInD") , Lj701GtInD(), IsInCallStack("LOJI701")) //Integracao via Mensagem Unica

Default aArqAux2	:= {}
Default aArquivos	:= {}
Default lJob		:= .F.
Default cTpGeraGdp	:= GDP_NO		// Informa como sera gerada Guia de Despacho a partir do pedido de venda.
Default cDocPai		:= ""
Default cSeriePai	:= ""
Default aRetCNF		:= {}
Default cImpRGer	:= ""
Default lVendErro	:= .F.
Default lAlterOrc	:= .F.
Default cNumPai		:= ""
Default lAvCred		:= .F.
Default aOrcRetira	:= {}
Default aPedidos	:= {}			// Array para geração do Pedido de venda
Default cLojaLocal	:= ""
Default cDocPed		:= ""
Default cSeriePed 	:= ""
//Faz a gravacao dos orcamentos nas filiais correspondentes
For nX := 1 To Len( aArqAux2 )
	aLojas := aClone(aArqAux2[nX][1])
	lSemFrete := .F.
	//Pega os arrays depois do recalculo
	aArquivos := aClone(aArqAux2[nX][2])
	//Atribui o desconto calculados no Orcamento
	nPos1 := Ascan(aArquivos[1],{|x| Alltrim(Upper(x[1])) == "L1_DESCONT"})
	nPos2 := Ascan(aArqAux2[nX][2][1],{|x| Alltrim(Upper(x[1])) == "L1_DESCONT"})
	aArquivos[1][nPos1][2] := aArqAux2[nX][2][1][nPos2][2]
	//Atribui o valor do frete calculado no Orcamento
	nPos1 := Ascan(aArquivos[1],{|x| Alltrim(Upper(x[1])) == "L1_FRETE"})
	nPos2 := Ascan(aArqAux2[nX][2][1],{|x| Alltrim(Upper(x[1])) == "L1_FRETE"})
	aArquivos[1][nPos1][2] = aArqAux2[nX][2][1][nPos2][2]
	//LIMPA INFORMACOES DO CAMPO L1_ORIGEM NO ORC. FILHO PARA INTEGRACOES
	nPos1 := Ascan(aArquivos[1],{|x| Alltrim(Upper(x[1])) == "L1_ORIGEM"})
	If Alltrim(aArquivos[1][nPos1][2]) == "N"
		aArquivos[1][nPos1][2] := ""
	Endif
	//DESPESA
	nPos1 := Ascan(aArquivos[1],{|x| Alltrim(Upper(x[1])) == "L1_DESPESA"})
	nPos2 := Ascan(aArqAux2[nX][2][1],{|x| Alltrim(Upper(x[1])) == "L1_DESPESA"})
	
	LjGrvLog(SL1->L1_NUM,"LOGFRET - filho despesa 1",aArquivos[1][nPos1][2])
	LjGrvLog(SL1->L1_NUM,"LOGFRET - filho despesa 2",aArqAux2[nX][2][1][nPos2][2])
	
	// Caso nao for job e nao for PDVPAF
	If !lJob .AND. !lMVLjPdvPa
		//Atribui o Valor Liquido, o Valor Bruto e o Valor ICMS calculado no Orcamento
		nPos1 := Ascan(aArquivos[1],{|x| Alltrim(Upper(x[1])) == "L1_VLRLIQ"})
		nPos2 := Ascan(aArqAux2[nX][2][1],{|x| Alltrim(Upper(x[1])) == "L1_VLRLIQ"})
		aArquivos[1][nPos1][2] := aArqAux2[nX][2][1][nPos2][2]

		nPos1 := Ascan(aArquivos[1],{|x| Alltrim(Upper(x[1])) == "L1_VALBRUT"})
		nPos2 := Ascan(aArqAux2[nX][2][1],{|x| Alltrim(Upper(x[1])) == "L1_VALBRUT"})
		aArquivos[1][nPos1][2] := aArqAux2[nX][2][1][nPos2][2]

		nPos1 := Ascan(aArquivos[1],{|x| Alltrim(Upper(x[1])) == "L1_VALICM"})
		nPos2 := Ascan(aArqAux2[nX][2][1],{|x| Alltrim(Upper(x[1])) == "L1_VALICM"})
		aArquivos[1][nPos1][2] := aArqAux2[nX][2][1][nPos2][2]
	EndIf
	For nConta = 1 to len(aArquivos[2])
        //Atribui o desconto calculados nos itens apos a proporcao
		nPos1 := Ascan(aArquivos[2][nConta],{|x| Alltrim(Upper(x[1])) == "L2_DESCPRO"})
		nPos2 := Ascan(aArqAux2[nX][2][2][nConta],{|x| Alltrim(Upper(x[1])) == "L2_DESCPRO"})
		aArquivos[2][nConta][nPos1][2] := aArqAux2[nX][2][2][nConta][nPos2][2]
		//Verifica se todos os itens da SL2 são GE ou SF, caso seja, a variavel lVldGESF retorna .T. e  ALTERA o L1_RESERVA pra " " apos a gravação da SL1
		if lVldGESF 
			cCodProd := aArquivos[2][nConta][Ascan(aArquivos[2][nConta],{|x| Alltrim(Upper(x[1])) == "L2_PRODUTO"})][2]			
			SB1-> ( DbSetOrder(1)) //B1_FILIAL+B1_COD                                                                                                                                             
			If SB1-> ( DbSeek(xFilial("SB1") + cCodProd) )					
				If  SB1->B1_TIPO == cTipoGE .OR. SB1->B1_TIPO == cTipoSF
					lVldGESF := .T.
				Else
					lVldGESF := .F.
				EndIf
			EndIf
		Endif
		
		//Atribui o Valor Unitario e o Valor Item calculados nos itens apos a proporcao
		If !lJob
			nPos1 := Ascan(aArquivos[2][nConta],{|x| Alltrim(Upper(x[1])) == "L2_VRUNIT"})
			nPos2 := Ascan(aArqAux2[nX][2][2][nConta],{|x| Alltrim(Upper(x[1])) == "L2_VRUNIT"})
			aArquivos[2][nConta][nPos1][2] := aArqAux2[nX][2][2][nConta][nPos2][2]

			nPos1 := Ascan(aArquivos[2][nConta],{|x| Alltrim(Upper(x[1])) == "L2_VLRITEM"})
			nPos2 := Ascan(aArqAux2[nX][2][2][nConta],{|x| Alltrim(Upper(x[1])) == "L2_VLRITEM"})
			aArquivos[2][nConta][nPos1][2] := aArqAux2[nX][2][2][nConta][nPos2][2]

			// Caso L2_ENTREGA não for do tipo ENTREGA, preenche lSemFrete como True
			nPos1 := Ascan(aArquivos[2][nConta],{|x| Alltrim(Upper(x[1])) == "L2_ENTREGA"})
			If aArquivos[2][nConta][nPos1][2] $ "1|2|4"
				lSemFrete  := .T.
			EndIf
           
            // Caso nao for job e nao for PDVPAF
			If !lMVLjPdvPa
				//Atribui a Base e Valor de ICMS e Frete calculados nos itens apos a proporcao
    			nPos1 := Ascan(aArquivos[2][nConta],{|x| Alltrim(Upper(x[1])) 		== "L2_BASEICM"})
				nPos2 := Ascan(aArqAux2[nX][2][2][nConta],{|x| Alltrim(Upper(x[1])) 	== "L2_BASEICM"})
				aArquivos[2][nConta][nPos1][2] = aArqAux2[nX][2][2][nConta][nPos2][2]

				nPos1 := Ascan(aArquivos[2][nConta],{|x| Alltrim(Upper(x[1])) 		== "L2_VALICM"})
				nPos2 := Ascan(aArqAux2[nX][2][2][nConta],{|x| Alltrim(Upper(x[1])) 	== "L2_VALICM"})
				aArquivos[2][nConta][nPos1][2] = aArqAux2[nX][2][2][nConta][nPos2][2]

				nPos1 := Ascan(aArquivos[2][nConta],{|x| Alltrim(Upper(x[1])) 		== "L2_VALFRE"})
             	nPos2 := Ascan(aArqAux2[nX][2][2][nConta],{|x| Alltrim(Upper(x[1])) 	== "L2_VALFRE"})
				aArquivos[2][nConta][nPos1][2] := aArqAux2[nX][2][2][nConta][nPos2][2]

          	EndIf
		EndIf

		//Release 11.5 - Chile - Guia de Despacho - F2CHI
		//Atualiza L1_DOC,L1_SERIE,L2_DOC e L2_SERIE do novo orcamento
		//que sera gerado.Estes dados atualizados indicam que sera gerada
		//a Factura para os itens de venda com entrega tipo 3 e que
		//os mesmos serao incluidos na Guia de Despacho pelo SIGAFAT
		If lCFolLocR5 .AND. lJob .AND. cPaisLoc == "CHI" .AND. cTpGeraGdp $ GDP_PARCIAL + ";" + GDP_TOTAL
			nPos1 := Ascan(aArquivos[2][nConta],{|x| Alltrim(Upper(x[1])) 	== "L2_ENTREGA"})
			If aArquivos[2][nConta][nPos1][2] <> "1"
				//SL2
				nPos2 := Ascan(aArquivos[2][nConta],{|x| Alltrim(Upper(x[1])) 	== "L2_DOC"})
			    aArquivos[2][nConta][nPos2][2] := cDocPai

			    nPos2 := Ascan(aArquivos[2][nConta],{|x| Alltrim(Upper(x[1])) 	== "L2_SERIE"})
			    aArquivos[2][nConta][nPos2][2] := cSeriePai

				//SL1
				nPos1 := aScan( aArquivos[1], {|x| Alltrim(Upper(x[1]))=="L1_DOC"} )
				aArquivos[1][nPos1][2] := cDocPai

				nPos1 := aScan( aArquivos[1], {|x| Alltrim(Upper(x[1]))=="L1_SERIE"} )
				aArquivos[1][nPos1][2] := cSeriePai
			Else
				//SL1
				nPos1 := aScan( aArquivos[1], {|x| Alltrim(Upper(x[1]))=="L1_DOC"} )
				aArquivos[1][nPos1][2] := ""

				nPos1 := aScan( aArquivos[1], {|x| Alltrim(Upper(x[1]))=="L1_SERIE"} )
				aArquivos[1][nPos1][2] := ""
			EndIf
		EndIf
		// Procura se tem itens de impressao que nao sejam garantia
		If SuperGetMv("MV_LJIMPGF",,.F.)
			nPosCodProd := Ascan(aArquivos[2][nConta],{|x| Alltrim(Upper(x[1])) == "L2_PRODUTO"})
			cCodProd    := aArquivos[2][nConta][nPosCodProd][2]

			nPosReserv := Ascan(aArquivos[2][nConta],{|x| Alltrim(Upper(x[1])) == "L2_ENTREGA"})
			cCodReserv := aArquivos[2][nConta][nPosReserv][2]

			If !(cCodReserv $ "3|4") .And. !(Posicione("SB1",1,xFilial("SB1")+cCodProd, "B1_TIPO") == SuperGetMV("MV_LJTPGAR",,"GE") ) //3=Entrega; 4=Retira Posterior c/ Nota
				lItemNormal := .T.
			EndIf
		Else
			lItemNormal := .T. //A venda possui itens de impressao fiscal
		EndIf
	Next nConta
	// Atualiza o L1_TPFRET para 'Sem Frete' caso o item não for do tipo ENTREGA
	nPos1 = Ascan(aArquivos[1],{|x| Alltrim(Upper(x[1])) == "L1_TPFRET"})
	If lSemFrete
		aArquivos[1][nPos1][2] := "S"	// Sem Frete
	EndIf
	//Ajustes para a tabela SL4	
	//- trecho importante para imprimir o TagCard na finalização de retira posterior em ambiente NFC-e
	aArquivos[3] := aClone(aArqAux2[nX][2][3])
    LjGrvLog(Nil,"Ajuste das tabelas de SL4 para a Reserva")
    nI	:= 1
	SL4->(DbSetOrder(1)) //L4_FILIAL + L4_NUM + L4_ORIGEM
	SL4->(DbSeek(aLojas[1] + aLojas[2]))
    While !SL4->(Eof()) .And. (SL4->(L4_FILIAL+L4_NUM) == aLojas[1] + aLojas[2]) .And. Empty(AllTrim(SL4->L4_ORIGEM))
    	nPos := aScan( aArquivos[3][nI], {|x| Alltrim(Upper(x[1])) == "L4_FORMA" } )
	    If AllTrim(aArquivos[3][nI][nPos][2]) $ _FORMATEF
    		aAdd( aArquivos[3][nI] ,{ "L4_VENDTEF"	, "S" } )
			aAdd( aArquivos[3][nI] ,{ "L4_DATATEF"	, SL4->L4_DATATEF	} )
			aAdd( aArquivos[3][nI], { "L4_HORATEF"	, SL4->L4_HORATEF	} )
			aAdd( aArquivos[3][nI], { "L4_DOCTEF"	, SL4->L4_DOCTEF	} )
			aAdd( aArquivos[3][nI], { "L4_AUTORIZ"	, SL4->L4_AUTORIZ	} )
			aAdd( aArquivos[3][nI], { "L4_INSTITU"	, SL4->L4_INSTITU	} )
			aAdd( aArquivos[3][nI], { "L4_NSUTEF"	, SL4->L4_NSUTEF	} )
			aAdd( aArquivos[3][nI], { "L4_TIPCART"	, SL4->L4_TIPCART	} )
			//Tipo de Parcelamento ("0" - Estabelecimento / "1" - Administradora) + Quantidade de Parcelas
			aAdd( aArquivos[3][nI], {"L4_PARCTEF"	, SL4->L4_PARCTEF	} )
			aAdd( aArquivos[3][nI], { "L4_FORMAID"	, SL4->L4_FORMAID	} )
			//Codigo da Bandeira que foi utilizada
			aAdd( aArquivos[3][nI], { "L4_BANDEIR"	, SL4->L4_BANDEIR	} )
			//Codigo da Rede que foi utilizada
			aAdd( aArquivos[3][nI], { "L4_REDEAUT"	, SL4->L4_REDEAUT	} )
			aAdd( aArquivos[3][nI], { "L4_NOMECLI"	, SL4->L4_NOMECLI	} )
    	EndIf

    	nPos := aScan( aArquivos[3][nI], {|x| Alltrim(Upper(x[1])) == "L4_OBS" } )
	    If nPos == 0
	    	aAdd( aArquivos[3][nI], { "L4_OBS", STR0018 + aRetCNF[2][1] + STR0019 + aRetCNF[2][2] } ) //"COO:"###" PDV:"
	    Else
	        aArquivos[3][nI][nPos][2] := STR0018 + aRetCNF[2][1] + STR0019 + aRetCNF[2][2] //"COO:"###" PDV:"
	    EndIf    	
    	
    	nI++
		SL4->(DbSkip())
    End
	LjGrvLog(Nil,"Fim dos ajuste das tabelas de SL4 para a Reserva")
	
	//Posiciona o orcamento no original
	SL1->( DbSeek( aLojas[1] + aLojas[2] ) )
	//Insere informação do TEF nos orçamentos filhos
	nPos1 := Ascan(aArquivos[1],{|x| Alltrim(Upper(x[1])) == "L1_VENDTEF"})
	If nPos1 == 0
		Aadd(aArquivos[1], {"L1_VENDTEF", SL1->L1_VENDTEF})
	Else
		aArquivos[1][nPos1][2] := SL1->L1_VENDTEF
	EndIf

	//Verifica se deve gerar um novo numero de Orcamento,
	//³ou se utiliza o numero gerado pela rotina de Reserva Off Line.
	If lAmbOff
		nPos := Ascan(aArquivos[01], {|x| AllTrim(x[01]) == "L1_NUM"})
		If nPos > 0
			lCriaOrc := Empty(aArquivos[01][nPos][02])
		Else
			lCriaOrc := .T.
		EndIf
	EndIf
	//Chama a funcao para gravar os arrays gerando SL1, SL2 e SL4
	If !lMVLJPDVPA
		LjGrvLog(Nil,"Filial SM0 - Antes da LJ7GrvOrc"		, SM0->M0_CODFIL)
		LjGrvLog(Nil,"Filial cFilAnt - Antes da LJ7GrvOrc"	, cFilAnt)
		aRet := LJ7GrvOrc(	aArquivos[1]	, aArquivos[2]	,	aArquivos[3], !lAutoExC	,;
							.T.			 	, aLojas[13]	, 	lJob		)
		LjGrvLog(Nil,"Filial SM0 - Depois da LJ7GrvOrc"		,SM0->M0_CODFIL)
		LjGrvLog(Nil,"Filial cFilAnt - Depois da LJ7GrvOrc"	,cFilAnt)

		If lVldGESF
			Reclock( "SL1", .F. )
			SL1->L1_RESERVA	:= " "
			SL1->( MsUnlock() )		
		Else
			lVldGESF := .T.	
		EndIf
				
		If !lJob .AND. lGE .AND. !lItemNormal
				aRelGer := LjxGetRGer()
				aRelGar := LjxGetRGar()

				If Len(aRelGer) > 0 .AND. Len(aRelGer) == Len(aRelGar)
					For nCont :=1 To Len(aRelGer)
						cRetRelG := chr(16) + &cImpRGer.(	aRelGer[nCont][1]	,aRelGer[nCont][2]	,aRelGer[nCont][3]	,aRelGer[nCont][4]		,;
				        									aRelGar[nCont][1]	,aRelGar[nCont][2]	,aRelGar[nCont][3]	,SA1->A1_NOME,nMoedaCor	)
					Next nCont
				EndIf
				aRelGer := {}
			 	aRelGar := {}
			 	//Zera variaveis estaticas
				LjxSetRGer( aRelGer )
				LjxSetRGar( aRelGar )
		EndIf

		If lVendErro .AND. aRet[1]
			Reclock( "SL1", .F. )
			REPLACE SL1->L1_STATUS 	WITH "D"
			SL1->( MsUnlock() )
		EndIf
		
		//Validar se os itens do orcamento nao sao de lista de presente do tipo CREDITO, que nao devem gerar
		//PEDIDO DE VENDA e/ou DOC. DE SAIDA.
		//(Apenas para processos JOB)
		lItLstPresC := .F.
		If !Empty(aLojas[12])
			cTipoLista := GetAdvfVal("ME1","ME1_TIPO",xFilial("ME1") + SL2->L2_CODLPRE,2)
			//Verificar se o tipo da lista eh de credito
			If !Empty(cTipoLista) .And. AllTrim(AllToChar(cTipoLista)) == "1"				
				lItLstPresC := .T.
				//Se for lista do tipo credito é gravado alguns campos para que a legenda fique correta.
				Lj7GeraSL( "SL1",{	{"L1_DOCPED"	,cDocPed	},;
									{"L1_SERIE"		,cSeriePed	},;
									{"L1_RESERVA"	,"S"		}}, .F., .F. )
			Endif
			ConOut(STR0157 + cValToChar(lItLstPresC)) //"Lista de presente de credito - "
		Endif

		//Faz a gravação do Pedido de Venda.
		If !lItLstPresC
			If !Empty(SL2->L2_RESERVA)
				DbSelectArea("SC0")
				SC0->(dbSetOrder(1)) //"C0_FILIAL+C0_NUM+C0_PRODUTO+C0_LOCAL"
				If SC0->(DbSeek(aLojas[4]+SL2->L2_RESERVA))
				    cFilRES := SC0->C0_FILRES
		    		cFilLoc := SC0->C0_LOCAL
		   	    Endif
	        Endif

			If (aLojas[6] == "3" .Or. aLojas[6] == "4") .AND. aRet[1] .AND. !(lMVLJPDVPA)	//3=Entrega; 4=Retira Posterior c/ Nota

				//Tratamento VFE - Verifica se funcionalidade esta habilitada
	       		If lCentroDL
	       			//Inicializa Flags VFE
					lExistVfe := .F. //Verifica se cenario contempla VFE
			   		lValidVfe := .T. //PE para validar se executa VFE

	       			//Ponto de Entrada para verificar se gera VFE
				    If ExistBlock("LJ7096")
				    	lValidVfe := ExecBlock("LJ7096",.F., .F., {aArquivos, aLojas})

				    	//Tratamento para retorno do PE LJ7096
				    	If ValType(lValidVfe) <> "L"
				    		lValidVfe := .F.
				    	EndIf
				    EndIf

	       			If lValidVfe
		       			//Inicializa variaveis VFE
						cCliente  	:= SL1->L1_CLIENTE 	//Codigo do Cliente
						cLojaCli	:= SL1->L1_LOJA 	//Loja do Cliente
						cCliEnt   	:= SL2->L2_CLIENT	//Cliente de Entrega
						cLojEnt		:= SL2->L2_CLILOJA	//Loja do Cliente de Entrega
						//Se cliente de Entrega nao informado, assume cliente da venda
						If Empty(cCliEnt) .Or. Empty(cLojEnt)
							cCliEnt := cCliente
							cLojEnt := cLojaCli
						EndIf
						//Busca Estado do CD Matriz para verificar se VFE
						SLJ->(dbSetOrder(1)) //"LJ_FILIAL+LJ_CODIGO"
						SLJ->(dbSeek(xFilial("SLJ")))
						//Posiciona na Identificacao de Loja do CD Matriz
						While SLJ->(!Eof()) .And. SLJ->LJ_FILIAL == xFilial("SLJ")
							If AllTrim(SLJ->LJ_RPCEMP) == AllTrim(cEmpAnt) .And.;
								AllTrim(SLJ->LJ_RPCFIL) == AllTrim(aLojas[4]) .And. SLJ->LJ_TPCD == "0" //CD Matriz
								cUfCD := SLJ->LJ_ESTADO
								Exit
							EndIf
							SLJ->(dbSkip())
						EndDo

						SA1->(dbSetOrder(1)) //"A1_FILIAL+A1_COD+A1_LOJA"
						If SA1->(DbSeek(xFilial("SA1") + cCliEnt + cLojEnt))
							cUFCli := IIF(!Empty(SA1->A1_ESTE), SA1->A1_ESTE, SA1->A1_EST)

							//Se Estado do CD diferente do Estado do Cliente, entao Venda Fora do Estado
							If !Empty(cUfCD) .And. cUfCD <> cUFCli
								//Se a Loja da Venda Cenario 1, verifica se cliente tambem Cenario 1
								If lCen1VFE
									//Verifica cenario de venda VFE para o cliente
									lCen1VFE := LjAnalisaLeg(69, cUFCli)[1] .And. SuperGetMv("MV_LJC1VFE", Nil, .F.) //Especifico para Minas Gerais = Cenario 1 - Cliente
								EndIf

								SLJ->(dbSetOrder(3)) //"LJ_FILIAL+LJ_RPCEMP+LJ_RPCFIL"
								//Posiciona na Identificacao da Loja da Venda
								cCodCdLocal := "" //Inicializa Codigo de Identificacao do CD Local
								If SLJ->(dbSeek(xFilial("SLJ") + cEmpAnt + cFilAnt))
									cCodCdLocal := SLJ->LJ_CDLOCAL
								EndIf

								SLJ->(dbSetOrder(1))//"LJ_FILIAL+LJ_CODIGO"
								//Verifica se existe CD Local especifico para a Loja
								If !Empty(cCodCdLocal) .And. SLJ->(dbSeek(xFilial("SLJ") + cCodCdLocal)) .And. SLJ->LJ_ESTADO == cUFCli
									lExistVfe := .T. //Marca ocorrencia de VFE
									cCliente  := SLJ->LJ_CLIENTE
									cLojaCli  := SLJ->LJ_LOJCLI

								Else//Busca CD Local para as Lojas do Estado
									//Necessario para alterar o cliente apontando para o CD Loja
									SLJ->(dbSeek(xFilial("SLJ")))
									//Busca Identificacao de Loja do CD Local
									While SLJ->(!Eof()) .And. SLJ->LJ_FILIAL == xFilial("SLJ")
									   If SLJ->LJ_ESTADO == cUFCli .And. SLJ->LJ_TPCD == "1" //CD Local
											lExistVfe := .T. //Marca ocorrencia de VFE
											cCliente  := SLJ->LJ_CLIENTE
											cLojaCli  := SLJ->LJ_LOJCLI
											Exit
									   EndIf
									   SLJ->(dbSkip())
									EndDo
								EndIf
							EndIf
						EndIf
					EndIf
	         	EndIf
				aAdd(aPedidos,{	aClone(aArquivos[1]), aClone(aArquivos[2])	, aLojas[13], aRet[2]	,;
								lJob				, lAlterOrc				, cFilLoc	, aLojas[4]	,;
								cCliente			, cLojaCli				, lExistVfe	, cNumPai	,;
								lAvCred				, lCen1VFE				, cFilRes	})
			EndIf
    	EndIf

		//Gera número de DAV para orçamento que possui item Retira Posterior
		//aLojas[6]: 1-Retira Posterior, 2-Retira, 3-Entrega
		If aLojas[6] == "1" .AND. aRet[1] .AND. !lMVLJPDVPA .And. LjNfPafEcf(SM0->M0_CGC) 
			aSequencia	:= {}
			nTamOrc		:= TamSX3("LQ_NUMORC")[1]
		    If SuperGetMv("MV_LJPRVEN",,.T.)
		    	cSerOrc := SuperGetMv("MV_LJSERPRE",,"PRE")
		    Else
		    	cSerOrc := SuperGetMv("MV_LJSERDAV",,"DAV")
		    EndIf
	    	LjxDNota(	cSerOrc		, 1				, .T.	, 1		,;
	    			 	@aSequencia	, Space(nTamOrc), Nil	, 1		,;
	    			 	999			, .F.			, ""	, Nil	,;
	    			 	nTamOrc		, .T.			)
			If Len(aSequencia) > 0 .And. Reclock( "SL1", .F. )
				REPLACE SL1->L1_NUMORC	WITH aSequencia[1][2]
				REPLACE SL1->L1_SERIE	WITH ""
				SL1->( MsUnlock() )
			EndIf
		EndIf

		//Gera a ordem de serviço desse orçamento.
		If !lLJ7058 .And. lLjInTec .And. Lj7HasDtEM()
			Lj7CriaEntrMont(aLojas[5], cNumPai)
		EndIf

		If aRet[1]
			aSL2 := {}
			DbSelectArea("SL2")
			SL2->(DbSetOrder(1)) // filial + num + item + produto
			For nY := 1 to Len( aLojas[5] )
				If SL2->(DbSeek( xFilial("SL2") + cNumPai + aLojas[5][nY] ))
					aAdd( aSL2, { "L2_ORCRES", aRet[2] 		} )
					aAdd( aSL2, { "L2_FILRES", aLojas[4]	} )
					
					//Integracao armazena bases dos impostos
					If lIntegDef
						nBasePis  += SL2->L2_BASEPIS
						nBaseCofi += SL2->L2_BASECOF
						nBaseCsll += SL2->L2_BASCSLL
						nBaseIrrf += SL2->L2_BASIRRF
					EndIf
					
					Lj7GeraSL( "SL2", aSL2 )
				EndIf
			Next nY

			//Ponto de controle para gerar arquivo de Log, para monitorar a impressao de cupons fiscais indevidos
			If ((aLojas[3] == cLojaLocal .AND. (aLojas[6] == "2" .OR. Empty(aLojas[6]))) .OR. ;
				(aLojas[3] == cLojaLocal .AND. If(SL2->(ColumnPos("L2_ENTREGA"))>0,(aLojas[6] == "3"),.T.) .AND. (SuperGetMV("MV_LJFINEN",,.F.))))  .AND. lItemNormal
				If !lMVLJPDVPA .And. aLojas[1] == aLojas[4] 
	 				aAdd( aOrcRetira, aRet[2] )
	 			ElseIf lMVLJPDVPA
					aAdd( aOrcRetira, cNumPai )
	 			EndIf
			ElseIf lMVLJPDVPA .And. ((aLojas[6] == "2" .Or. Empty(aLojas[6])) .Or. aLojas[6] == "1")
		 			aAdd( aOrcRetira, cNumPai )
			EndIf
		Else
			lRet := .F.
			Exit
		EndIf
	Else
		aAdd( aOrcRetira, cNumPai )
	EndIf
Next nX

Return lRet

//----------------------------------------------------------
/*/{Protheus.doc} LJ7GPedVen
Função responsável por gerar o pedido de venda

@param		aPedidos = Array com os pedidos a serem gerados
@type		function
@author		felipe.martinez
@version	P12.1.14
@since		08/03/2017
@return 	lRet = .T.-> Gerado com suesso / .F.-> Não gerados
/*/
//----------------------------------------------------------
Static Function LJ7GPedVen(aPedidos)
Local lRet 			:= .T.
Local lCen1VFE		:= .F.
Local lJob			:= .F.
Local lExistVfe		:= .F.							// Verifica se cenario contempla VFE
Local lAlterOrc		:= .F.
Local lAvCred		:= .F.
Local aRetEnt		:= {}
Local aAreaCDL		:= {}
Local aSl1			:= {}
Local aSl2			:= {}
Local cCliente		:= ""
Local cLojaCli		:= ""
Local cNumPai		:= ""
Local cFilResC0		:= ""
Local cFilLoc		:= ""
Local cFilFilho		:= ""
Local cNumFilho		:= ""
Local cFilReserv	:= ""
Local nI			:= 1
Local lCentroDL		:= SuperGetMv("MV_LJCDL",, .F.)	// Parametro de controle VFE

Default aPedidos	:= {}

For nI := 1 To Len(aPedidos)
	lExistVfe	:= .F.
	lCen1VFE	:= .F.
	aSl1		:= aClone(aPedidos[nI][1])
	aSl2		:= aClone(aPedidos[nI][2])
	cFilFilho	:= aPedidos[nI][3]
	cNumFilho	:= aPedidos[nI][4]
	lJob		:= aPedidos[nI][5]
	lAlterOrc	:= aPedidos[nI][6]
	cFilLoc		:= aPedidos[nI][7]
	cFilReserv	:= aPedidos[nI][8]
	cCliente	:= aPedidos[nI][9]
	cLojaCli	:= aPedidos[nI][10]
	cNumPai		:= aPedidos[nI][12]
	lAvCred		:= aPedidos[nI][13]
	cFilResC0	:= aPedidos[nI][15]
	If lCentroDL //Tratamento VFE - Verifica se funcionalidade esta habilitada
		lExistVfe	:= aPedidos[nI][11]
		lCen1VFE	:= aPedidos[nI][14]
	EndIf

	LjGrvLog(cNumPai,"Realizando a geracao dos pedidos para o orcamento:'" + cFilFilho + "/" + cNumFilho + "'")
	aRetEnt := Lj7GeraEnt(	aSl1	, aSl2		, cFilFilho	, cNumFilho	,;
							lJob 	, lAlterOrc	, cFilLoc	, cFilReserv,;
							cCliente, cLojaCli	, lExistVfe	, cNumPai	,;
							lAvCred	)
	lRet := aRetEnt[1]
	If lRet
		//Gera Pedidos de Vendas VFE
		If lCentroDL .And. lExistVfe
			aAreaCDL:= GetArea() //Guarda a area atual
			If lCen1VFE //Especifico para Minas Gerais = Cenario 1
		  		//Simples Faturamento
		 		LJ7GerPedVFE("1",aSl1,aSl2,cFilReserv, cFilResC0, cFilLoc)
				//Remessa Entrega Futura
				LJ7GerPedVFE("2",aSl1,aSl2,cFilReserv, cFilResC0, cFilLoc)
				//Remessa por Conta e Ordem de Estabelecimento Showroom
				LJ7GerPedVFE("3",aSl1,aSl2,cFilReserv, cFilResC0, cFilLoc)
				//Transferencia Simbolica
				LJ7GerPedVFE("4",aSl1,aSl2,cFilReserv, cFilResC0, cFilLoc)
			Else
				//Demais estados = Cenario 2
		 	  	LJ7GerPedVFE("5",aSl1,aSl2,cFilReserv, cFilResC0, cFilLoc)
		 	Endif
			RestArea(aAreaCDL)
		EndIf
		LjGrvLog(cNumPai,"Pedido de venda gerado com sucesso para o orcamento: " + aRetEnt[2])
	Else
		LjGrvLog(cNumPai,"Problemas ao gerar o pedido de venda")
		Exit
	EndIf
Next nI

Return lRet


//----------------------------------------------------------
/*/{Protheus.doc} LJ7GrvReti
Função responsável por gravar orcamentos filhos Retira

@param		aPedidos = Array com os pedidos a serem gerados
@type		function
@author		rafael.pessoa
@version	P12.1.16
@since		08/03/2017
@return 	lRet = Gravou com sucesso
/*/
//----------------------------------------------------------
Static Function LJ7GrvReti( aOrcRetira 	, lJob 		 , lEmiteNF    		,cNumPai   	,;
							aDadosCF	, nHandle 	 , lTemTEFPend 		,nFatorRes 	,;
							nFatorVen   , lTefOk     , lDscCupTef  		,lTefAbort 	,;
							nValRes     , aAreaL1Pai , aAreaL1Filhos  	,cTpGeraGdp ,;
							cEspDoc     , cDocFo     , aArquivos   		,aDocReti	,; 
							lCartao )
							
							
Local lRet 			:= .T.
Local nX 			:= 0
Local lCalcIPI      := .T.		// Verifica se calcula valor de IPI
Local cTpFrete 		:= "" 		// Tipo do Frete
Local nDescOrc		:= 0 		// Desconto do Orcamento
Local nCont			:= 0		// Contador utilizado contagem do SL2
Local lErroNFCe		:= .F.		// Sinaliza erro ao transmitir a NFC-e
Local cTes			:= ""		// Codigo da Tes no Array
Local lAcresFin 	:= SL2->(ColumnPos("L2_VALACRS")) > 0
//As variáveis lEmitNfce - alimentada pela rotina LjEmitNFCe, lFtvdVer12 - alimentada pela rotina - LjFTVD() e cNomeProg - alimentada pela variável  lFtvdVer12  tiveram seu escopo alterado para variáveis locais, pois o cliente pode mudar de modulo para o SigaFAT através do SIGAADV e essas variáveis mudam o seu valor conforme o módulo
Local lFtvdVer12	:= LjFTVD()	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local cNomeProg	:= Iif(lFtvdVer12,"FATA701","LOJA701")	//Nome da Rotina
Local lEmitNfce	:= LjEmitNFCe()		// Sinaliza se utiliza NFC-e

Default	aOrcRetira 	:= {}
Default	lJob		:= .F.
Default	lEmiteNF	:= .F.
Default	cNumPai		:= ""
Default	aDadosCF 	:= {}
Default	nHandle		:= -1
Default	lTemTEFPend	:= .F.
Default	nFatorRes	:= 1
Default	nFatorVen	:= 1
Default	lTefOk		:= .T. 
Default	lDscCupTef	:= .F.
Default	lTefAbort	:= .F. 
Default	nValRes		:= 0
Default	aAreaL1Pai 	:= {}
Default	aAreaL1Filhos := {} 
Default	cTpGeraGdp	:= GDP_NO 	
Default	cEspDoc		:= ""    
Default	cDocFo		:= ""     
Default	aArquivos 	:= {}
Default	aDocReti 	:= {}
Default lCartao		:= .F.

If Len( aOrcRetira ) > 0
	For nX := 1 to Len( aOrcRetira )
		DbSelectArea("SL1")
		SL1->(DbSetOrder(1))
		If SL1->(DbSeek( xFilial("SL1") + aOrcRetira[nX] )) .And. IIf (lJob, !Empty( SL1->L1_DOC ), Empty( SL1->L1_DOC ) .And. IIF( !(lMVLJPDVPA), Empty( SL1->L1_DOCPED ),.T.))
				If MaFisFound("NF")
					MaFisEnd()
				EndIf
				If !lJob
				   lCalcIPI    := Ascan(aPosCpoDet,{|x| Alltrim(Upper(x[1])) == "LR_VALIPI"})	 > 0
				EndIf
				cTpFrete := Lj7TpFrete(SL1->L1_CLIENTE,SL1->L1_LOJA)
				cTpFrete	:= IIf( Empty(cTpFrete) .And. SL1->L1_TPFRET == "S" , "S", cTpFrete)

				MaFisIni( SL1->L1_CLIENTE	, SL1->L1_LOJA	, "C" 		, "S"		,;
				          Nil				, Nil			, Nil 		, .F.		,;
				          "SB1"				, cNomeProg		, Nil 		, Nil		,;
				          Nil				, Nil			, Nil 		, Nil 		,;
						  NIL			  	, NIL			, lEmiteNF	, lCalcIPI 	,;
						  NIL             	, NIL        	, NIL 		, NIL		,;
						  NIL             	, cTpFrete )

				IF ExistFunc("LjSatMxFis")
					LjSatMxFis()
				EndIf

				DbSelectArea( "SL2" )
				SL2->(DbSetOrder(1))
				SL2->(DbSeek( xFilial("SL1") + aOrcRetira[nX] ))

				//Inicializa a variavel que acumula o desconto
				nDescOrc := 0
				If lFtvdVer12
					nCont	 := 0
				EndIf
				
				nVlrAcrsFi := 0 // Zero o Valor do Acrescimo para somatoria ser adicionado por item

				While !SL2->(Eof()) .AND. xFilial("SL1") + aOrcRetira[nX] == SL2->L2_FILIAL + SL2->L2_NUM
					If lAcresFin 
						nVlrAcrsFi += SL2->L2_VALACRS
					EndIf
					
					If !lFtvdVer12
						If MaFisFound("NF")
							MaFisAdd( SL2->L2_PRODUTO	,;	// Produto
									  SL2->L2_TES   	,;	// Tes
									  SL2->L2_QUANT 	,;	// Quantidade
									  SL2->L2_PRCTAB	,;	// Preco unitario
									  SL2->L2_VALDESC	,;	// Valor do desconto
									  ""				,; 	// Numero da NF original
									  ""				,; 	// Serie da NF original
									   0				,;	// Recno da NF original
									   0				,; 	// Valor do frete do item
									   0				,; 	// Valor da despesa do item
									   0				,; 	// Valor do seguro do item
									   0				,;  // Valor do frete autonomo
									   SL2->L2_VALDESC	,;  // Valor da mercadoria
									   0 				)	// Valor da embalagem
							nDescOrc += SL2->L2_DESCPRO
						EndIf

						DbSelectArea( "SL2" )
						SL2->(DbSkip())

					ElseIf lFtvdVer12

						nCont	+= 1
						If MaFisFound("NF")
							SB1->(DbSetOrder(1))
							SB1->(DbSeek(xFilial("SB1")+SL2->L2_PRODUTO))

							SF4->(DbSetOrder(1))
							SF4->(DbSeek(xFilial("SF4")+SL2->L2_TES))

							MaFisIniLoad(nCont, ;
										{SL2->L2_PRODUTO,;	//IT_PRODUTO
										SL2->L2_TES,; 		//IT_TES
										Alltrim(MaSBCampo("CODISS")),; 	//IT_CODISS
										SL2->L2_QUANT,;		//IT_QUANT
										"",; 				//IT_NFORI
										"",; 				//IT_SERIORI
										SB1->(RecNo()),;	//IT_RECNOSB1
										SF4->(RecNo()),;	//IT_RECNOSF4
										0  }) 				//IT_RECORI

							MaFisLoad("IT_VALMERC"	,SL2->L2_VLRITEM,nCont)
							MaFisLoad("IT_PRCUNI"	,SL2->L2_PRCTAB	,nCont)
							MaFisLoad("IT_DESCONTO"	,SL2->L2_VALDESC,nCont)
							MaFisLoad("IT_FRETE"	,0,nCont)
							MaFisLoad("IT_SEGURO"	,0,nCont)
							MaFisLoad("IT_DESPESA"	,0,nCont)

							MaFisRecal("",nCont)

							MaFisEndLoad(nCont,2)
							nDescOrc += SL2->L2_DESCPRO
						EndIf
						DbSelectArea( "SL2" )
						SL2->(DbSkip())

					EndIf
				End

				If SL1->L1_TPFRET $ "FC"  // CIF FOB
					MaFisAlt( "NF_FRETE"	, SL1->L1_FRETE )
					MaFisAlt( "NF_SEGURO"	, SL1->L1_SEGURO )
					MaFisAlt( "NF_DESPESA"	, SL1->L1_DESPESA )
				EndIf

			DbSelectArea( "SL1" )

			LjGrvLog(cNumPai,"VAI GRAVAR E TRANSMITIR O FILHO "+SL1->L1_NUM)

			If lJob
				lRet := LjGrvTudo( .F. ,NIL,NIL,NIL,;
                   					NIL,NIL,NIL,NIL,;
                   					NIL,NIL,NIL,NIL,;
                   					NIL,NIL,NIL,NIL,;
                   					NIL,NIL,NIL,.T. )
			Else
				lRet := LJ7GrvVenda( 	.F.										, !lMVLJPDVPA	, aDadosCF	, nHandle	,;
										IIf(lFtvdVer12 .OR. lEmiteNF,.T.,Nil)	, NIL			, NIL		, @lTemTefPend,;
										NIL										, nDescOrc		, ""      	, lJob		,;
										nVlrAcrsFi								, NIL			, NIL     	, NIL		,;
										Nil 									, nFatorRes 	, nFatorVen , lTefOk	,;
										Nil 									, NIL			, NIL    	, NIL		,;
										@lDscCupTef								, Nil			, Nil		, Nil		,;
										@lErroNFCe								, lTefAbort		, Nil		, Nil		,;
										nValRes									, Nil			, Nil		, lCartao )

				If (lEmitNFCe .Or. lIsPafNfce) .AND. lErroNFCe
					lRet := .F.
				EndIf
			EndIf
			LjGrvLog(cNumPai,"RETORNO DO FILHO RETIRA "+SL1->L1_NUM, lRet)
			aDocReti := { SL1->L1_DOC , SL1->L1_SERIE , SL1->L1_PDV , SL1->L1_OPERADO , LJGetStation("LG_LOGTEF") }
		EndIf
	Next nX
Else
	
	//Gera SE5 para o troco pela função AtuaTroco (LOCXFUN) quando
	//venda com apenas Itens-Pedido ou apenas Itens-Retira Posterior
	If cPaisLoc == "BRA" .AND. SuperGetMV( "MV_LJTROCO", ,.F. )
		RestArea(aAreaL1Pai)
		If SL1->( ColumnPos("L1_TROCO1") ) > 0
			AtuaTroco( 	SL1->L1_TROCO1	, 1				, 2					, SL1->L1_CLIENTE, ;
						SL1->L1_LOJA	, /*aTitulo*/	, SL1->L1_OPERADO )
		EndIf
		RestArea(aAreaL1Filhos)
	EndIf
	
EndIf
	    
Return lRet	    
 	    
	    
//----------------------------------------------------------
/*/{Protheus.doc} Lj7AtuNum
Função responsável por atualizar Numeracao nos orcamentos Pai e Filhos 

@type		function
@author		rafael.pessoa
@version	P12.1.16
@since		02/03/2017
@return 	Nil
/*/
//----------------------------------------------------------
Static Function Lj7AtuNum(	lJob 		, aRetCNF , cDocPed , cSeriePed ,;
							aOrcRetira	, aPedidos	)

Local nX			:= 0
Local aSL1			:= {}
Local lECommerce	:= SuperGetMV("MV_LJECOMM",,.F.) .And. SL1->L1_ECFLAG == "1" // Tratamento para eCommerce

Default lJob		:= .F.
Default aRetCNF		:= {.F., {"", ""}}
Default cDocPed		:= ""
Default cSeriePed	:= ""
Default aOrcRetira	:= {}
Default aPedidos	:= {}

cDocPed := aRetCNF[2][1]

aAdd( aSL1, {"L1_DOCPED"	, cDocPed } )					// Numero do cupom nao fiscal (pedido)


// Numero do serie do cupom nao fiscal (pedido)
If  lECommerce
	cSeriePed :=   SL1->L1_SERPED  //Ja gravado anteriormente
ElseIf lCFolLocR5 .AND. !Empty(SuperGetMV("MV_LOJAPED"))
	// Chile/Colombia - Controle de Formularios obtem numero serie do MV_LOJAPED	
	cSeriePed := If(Len(aRetCNF[2])==3 .AND. !Empty(aRetCNF[2]),aRetCNF[2][3],SuperGetMV("MV_LOJAPED"))
ElseIf !lJob
    cSeriePed := If(Len(aRetCNF[2])==3,aRetCNF[2][3],LjGetStation("LG_SERIE")) 
EndIf

If !Empty(cSeriePed)
	aAdd( aSL1, {"L1_SERPED",  cSeriePed } )
EndIf	  

If Len(aSL1) > 0
	Lj7GeraSL( "SL1", aSL1, .F., .F. )
EndIf	

//Atualiza Orcamentos Retira
For nX := 1 to Len( aOrcRetira )

	DbSelectArea("SL4")
	SL4->(DbSetOrder(1)) //"L4_FILIAL+L4_NUM+L4_ORIGEM"
	If SL4->(DbSeek( xFilial("SL4") + aOrcRetira[nX] ))
		While !SL4->(Eof()) .AND. (SL4->L4_FILIAL + SL4->L4_NUM ) == (xFilial("SL4") + aOrcRetira[nX] )
	
			RecLock("SL4",.F.)
			SL4->L4_OBS := STR0018 + cDocPed + STR0019 + cSeriePed //"COO:"###" PDV:"
			SL4->(MSUNLOCK())
		   	SL4->(DbSkip())
	
		End
	EndIf

Next nX

//Atualiza Pedidos
For nX := 1 to Len( aPedidos )

	DbSelectArea("SL4")
	SL4->(DbSetOrder(1)) //"L4_FILIAL+L4_NUM+L4_ORIGEM"
	If SL4->(DbSeek( xFilial("SL4") + aPedidos[nX][4] ))
		While !SL4->(Eof()) .AND. (SL4->L4_FILIAL + SL4->L4_NUM ) == (xFilial("SL4") + aPedidos[nX][4] )

			RecLock("SL4",.F.)
			SL4->L4_OBS := STR0018 + cDocPed + STR0019 + cSeriePed //"COO:"###" PDV:"
			SL4->(MSUNLOCK())
		   	SL4->(DbSkip())
	
		End
	EndIf

Next nX

Return Nil


//----------------------------------------------------------
/*/{Protheus.doc} Lj7EstPed
Função responsável por estornar gravacoes realizadas pela funcao LJ7Pedido em casos de erro 

@type		function
@author		rafael.pessoa
@version	P12.1.16
@since		02/03/2017
@return 	Nil
/*/
//----------------------------------------------------------
Static Function Lj7EstPed(	cNumOrcPai , lJob , aOrcRetira	, aPedidos	, ; 
							lTefOk 	   )

Local nX		 := 0
Local aAreaL1	 := SL1->(GetArea())											// Pega a Area posicionada no Orcamento do SL1
Local aAreaL2	 := SL2->(GetArea())											// Pega a Area posicionada no Orcamento do SL2
Local aAreaL4	 := SL4->(GetArea())											// Pega a Area posicionada no Orcamento do SL4
Local aOrcDel    := {}

Default cNumOrcPai	:= ""
Default lJob		:= .F.
Default aOrcRetira	:= {}
Default aPedidos	:= {}
Default lTefOk		:= .F.

LjGrvLog(cNumOrcPai,"Busca o orcamento pai para estorno",xFilial("SL1"))
DbSelectArea("SL1")
SL1->(DbSetOrder(1)) //"L1_FILIAL+L1_NUM"
If SL1->(DbSeek( xFilial("SL1") + cNumOrcPai ))

	If RecLock("SL1",.F.)

		SL1->L1_EMISNF 		:= StoD("  /  /  ")
		SL1->L1_NUMMOV 		:= ""	
		SL1->L1_TIPO 		:= ""
		SL1->L1_RESERVA 	:= ""	
		SL1->L1_OPERADO 	:= ""
		SL1->L1_DOCPED 		:= ""	
		SL1->L1_SERPED 		:= ""
		
		If lTefOk
			SL1->L1_VENDTEF 		:= ""	
			SL1->L1_DATATEF 		:= ""	
			SL1->L1_HORATEF 		:= ""
			SL1->L1_DOCTEF 			:= ""
			SL1->L1_AUTORIZ 		:= ""
			SL1->L1_INSTITU 		:= ""
			SL1->L1_DOCCANC 		:= ""
			SL1->L1_DATCANC 		:= ""
			SL1->L1_HORCANC 		:= ""
			SL1->L1_NSUTEF 			:= ""
			SL1->L1_TIPCART 		:= ""
		EndIf
	
		SL1->(MSUNLOCK())
	
	EndIf	
	
EndIf	

DbSelectArea("SL4")
SL4->(DbSetOrder(1)) //"L4_FILIAL+L4_NUM+L4_ORIGEM"
If SL4->(DbSeek( xFilial("SL4") + cNumOrcPai ))
	While !SL4->(Eof()) .AND. (SL4->L4_FILIAL + SL4->L4_NUM ) == (xFilial("SL4") + cNumOrcPai )

		RecLock("SL4",.F.)

		SL4->L4_ADMINIS 		:= ""
		SL4->L4_NUMCART 		:= ""
		SL4->L4_AGENCIA 		:= ""
		SL4->L4_CONTA 			:= ""	
		SL4->L4_RG		 		:= ""
		SL4->L4_TELEFON 		:= ""
		SL4->L4_COMP    		:= ""
		SL4->L4_TERCEIR 		:= .F.
		SL4->L4_NOMECLI 		:= ""
		SL4->L4_VENDTEF 		:= ""
		SL4->L4_DATATEF 		:= ""
		SL4->L4_HORATEF 		:= ""
		SL4->L4_DOCTEF  		:= ""
		SL4->L4_AUTORIZ 		:= ""
		SL4->L4_INSTITU 		:= ""
		SL4->L4_DOCCANC 		:= ""
		SL4->L4_DATCANC 		:= ""
		SL4->L4_HORCANC 		:= ""
		SL4->L4_NSUTEF  		:= ""
		SL4->L4_TIPCART 		:= ""
		SL4->L4_FORMPG 			:= ""
				
		SL4->(MSUNLOCK())
	   	SL4->(DbSkip())

	End
EndIf

//Exclui Orcamentos Retira
LjGrvLog(cNumOrcPai,"Orcamentos filhos RETIRA ",aOrcRetira)
If Len(aOrcRetira) > 0
	For nX := 1 to Len( aOrcRetira )
		AADD(aOrcDel,{ xFilial("SL1") , aOrcRetira[nX] })
	Next nX
	Lj7DelOrc(aOrcDel)
EndIf	

//Exclui orcamentos Pedidos
LjGrvLog(cNumOrcPai,"Orcamentos filhos FILHOS ",aPedidos)
If Len(aPedidos) > 0
	For nX := 1 to Len( aPedidos )
		AADD(aOrcDel,{ aPedidos[nX][3] , aPedidos[nX][4] })
	Next nX
	Lj7DelOrc(aOrcDel)
EndIf	

RestArea(aAreaL1)
RestArea(aAreaL2)
RestArea(aAreaL4)

Return Nil


//----------------------------------------------------------
/*/{Protheus.doc} Lj7DelOrc
Função responsável por excluir orcamentos para estorno de transação da LJ7Pedido em casos de erro 
@author		rafael.pessoa
@since		12/05/2017
@return 	Nil
/*/
//----------------------------------------------------------
Static Function Lj7DelOrc( aOrcs )

Local nX		:= 0
Local aAreaL1	:= SL1->(GetArea())											// Pega a Area posicionada no Orcamento do SL1
Local aAreaL2	:= SL2->(GetArea())											// Pega a Area posicionada no Orcamento do SL2
Local aAreaL4	:= SL4->(GetArea())											// Pega a Area posicionada no Orcamento do SL4
Local nRecL1 	:= SL1->(Recno())											// Guarda recno da SL1

Default aOrcs	:= {}

LjGrvLog("Lj7DelOrc","Orcamentos para exclusão ",aOrcs)

If Len(aOrcs) > 0
	For nX := 1 to Len( aOrcs )
		DbSelectArea("SL1")
		SL1->(DbSetOrder(1)) //"L1_FILIAL+L1_NUM"
		If SL1->(DbSeek( aOrcs[nX][1] + aOrcs[nX][2] ))
				
			//Verifica se houve geracao de nota em casos de queda do sistema para realizar exclusão			
			DbSelectArea("SF2")
			SF2->(DbSetOrder(1))//F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA+F2_FORMUL+F2_TIPO
			If SF2->(DbSeek(aOrcs[nX][1]+ SL1->L1_DOC + SL1->L1_SERIE))
				MafisSave()
				MafisEnd()
				LJ140Exc( "SL1", nRecL1, 2 ,,,,,,,,.T.)
				MafisRestore()
			Endif
			
			While !SL1->(Eof()) .AND. (SL1->L1_FILIAL + SL1->L1_NUM ) == ( aOrcs[nX][1] + aOrcs[nX][2] )
				RecLock("SL1",.F.)
				SL1->(DbDelete())
				SL1->(MSUNLOCK())
			   	SL1->(DbSkip())
			End
		EndIf
	
		DbSelectArea("SL2")
		SL2->(DbSetOrder(1)) //"L2_FILIAL+L2_NUM"
		If SL2->(DbSeek( aOrcs[nX][1] + aOrcs[nX][2] ))
			While !SL2->(Eof()) .AND. (SL2->L2_FILIAL + SL2->L2_NUM ) == ( aOrcs[nX][1] + aOrcs[nX][2] )
				RecLock("SL2",.F.)
				SL2->(DbDelete())
				SL2->(MSUNLOCK())
			   	SL2->(DbSkip())
			End
		EndIf
	
		DbSelectArea("SL4")
		SL4->(DbSetOrder(1)) //"L4_FILIAL+L4_NUM+L4_ORIGEM"
		If SL4->(DbSeek( aOrcs[nX][1] + aOrcs[nX][2] ))
			While !SL4->(Eof()) .AND. (SL4->L4_FILIAL + SL4->L4_NUM ) == ( aOrcs[nX][1] + aOrcs[nX][2] )
				RecLock("SL4",.F.)
				SL4->(DbDelete())
				SL4->(MSUNLOCK())
			   	SL4->(DbSkip())
			End
		EndIf
	Next nX
EndIf	


RestArea(aAreaL1)
RestArea(aAreaL2)
RestArea(aAreaL4)

Return Nil

//----------------------------------------------------------
/*/{Protheus.doc} LJ7OrcPen
Função responsável por verificar os orcamentos pendentes de processamento

@type		static function
@author		alessandrosantos
@version	P12.1.16
@since		19/06/2017
@return 	aRet -> Orcamentos pendentes de processamento da filial
/*/
//----------------------------------------------------------
Static Function LJ7OrcPen()

Local aRet	 	:= {}
Local cWhere 	:= "" //Condicao da query
Local cAliasTmp	:= GetNextAlias() //Alias Temporario

//Condicional query	
cWhere := "% "
cWhere += " L1_FILIAL = " + "'" + xFilial("SL1") + "'"
cWhere += " AND L1_SITUA = 'RX'"
cWhere += " AND SL1.D_E_L_E_T_ = ''"			
cWhere += " %"
			
//Executa a query
BeginSql alias cAliasTmp
	SELECT 
		L1_NUM 		
	FROM %table:SL1% SL1							
		WHERE %exp:cWhere%		   			
EndSql	

(cAliasTmp)->(dbGoTop())

//Busca Orcamentos em aberto
While (cAliasTmp)->(!EOF())	 
	aAdd(aRet, (cAliasTmp)->L1_NUM)	
	(cAliasTmp)->(dbSkip())	
EndDo

//Fecha arquivo temporario			
If (Select(cAliasTmp) > 0)
	(cAliasTmp)->(dbCloseArea())
EndIf

Return aRet


//----------------------------------------------------------
/*/{Protheus.doc} Lj7RecupPed
Função responsável por remontar o array aPedidos para recuperação 
@author		rafael.pessoa
@since		09/06/2017
@return 	aRet - Retorna array de pedidos formatado no Padrao
/*/
//----------------------------------------------------------
Function Lj7RecupPed( cNumPai , nAuxNcc , aAuxNcc , nNccAux)

Local nX		:= 0
Local nY		:= 0
Local aAreaL1	:= SL1->(GetArea())						// Pega a Area posicionada no Orcamento do SL1
Local aAreaL2	:= SL2->(GetArea())						// Pega a Area posicionada no Orcamento do SL2
Local aAreaL4	:= SL4->(GetArea())						// Pega a Area posicionada no Orcamento do SL4
Local aOrcPed   := {}	
Local aSL1		:= {}									
Local aSL2		:= {}
Local aRet		:= {}		
Local cFiltro := ""																 

Default cNumPai	:= ""
Default nAuxNcc	:= 0
Default aAuxNcc	:= {}
Default nNccAux	:= 0

LjGrvLog("Lj7RecupPed","Recupera Pedidos")

//Busca orcamentos filhos através da SL1 pois os registros ja foram excluidos.
cFiltro :=  "L1_FILRES = '" + SL1->L1_FILIAL + "' .AND. " + ;
			"L1_ORCRES = '" + cNumPai   	 + "'  "

DbSelectArea("SL1")
SL1->(dbSetFilter({|| &cFiltro},cFiltro)) 
SL1->(dbGoTop()) 
While SL1->(!Eof()) 
	DbSelectArea("SL2")
	SL2->( DbSetOrder(1) )	//L2_FILIAL+L2_NUM+L2_ITEM+L2_PRODUTO
	SL2->( DbGoTop())
	If SL2->( DbSeek(SL1->L1_FILIAL+SL1->L1_NUM) )
		While SL2->(!EOF()) .AND. (SL2->L2_FILIAL+SL2->L2_NUM == SL1->L1_FILIAL+SL1->L1_NUM)
			If !Empty(SL2->L2_ENTREGA) .And. SL2->L2_ENTREGA <> "2"
				If aScan(aOrcPed ,{ |x| x[1] == SL2->L2_FILRES + SL2->L2_NUM } ) == 0
					Aadd(aOrcPed, {SL2->L2_FILRES + SL2->L2_NUM ,SL2->L2_FILRES , SL2->L2_NUM} )
				EndIf
			EndIf
			SL2->(DbSkip())
		Enddo
	Endif
	SL1->(DbSkip())
Enddo

SL1->(dbClearFilter()) 

For nX := 1 To Len(aOrcPed)

	DbSelectArea("SL1")
	SL1->( DbSetOrder(1) )	//L1_FILIAL+L1_NUM
	If SL1->( DbSeek(aOrcPed[nX][1]) )
	
		For nY := 1 to FCount()
			aAdd( aSL1, { Trim(FieldName(nY)), FieldGet(nY) } )
		Next nY
		
		DbSelectArea("SL2")
		SL2->( DbSetOrder(1) )	//L2_FILIAL+L2_NUM+L2_ITEM+L2_PRODUTO
		If SL2->( DbSeek(aOrcPed[nX][1]) )
			While !EOF() .AND. (SL2->L2_FILIAL+SL2->L2_NUM == aOrcPed[nX][1])
					
				aAdd( aSL2, {} )
				For nY := 1 to FCount()
					aAdd( aSL2[Len(aSL2)], { FieldName(nY), FieldGet(nY) } )
				Next nY
				SL2->( DbSkip() )
			End	
		EndIf
		
		aAdd(aRet			,{	aClone(aSL1) 		, aClone(aSL2)			, aOrcPed[nX][2]		, aOrcPed[nX][3]	,;
			 					.T.					, .F.					, aOrcPed[nX][2]    	, aOrcPed[nX][2]	,;
								 ""	 				, ""					, .F.					, cNumPai			,;
			 					.T.					, .F.					, aOrcPed[nX][2]							})
		
	EndIf	

Next nX

//Recupera NCCs 
DbSelectArea("MDJ")
MDJ->(DbSetOrder(3))//MDJ->MDJ_FILIAL + MDJ->MDJ_NUMORC
If MDJ->(DbSeek(xFIlial("MDJ") + cNumPai ))
	nAuxNcc	:= MDJ->MDJ_NCCUSA	
	nNccAux	:= MDJ->MDJ_NCCGER
	
	DbSelectArea("MDK")
	MDK->( DbSetOrder(2) )	//MDK_FILIAL + MDK_NUMORC
	If MDK->(DbSeek(MDJ->MDJ_FILIAL + MDJ->MDJ_NUMORC))
		While MDK->MDK_FILIAL + MDK->MDK_NUMORC == MDJ->MDJ_FILIAL + MDJ->MDJ_NUMORC
			AAdd( aAuxNcc ,	{ 	.T.					, MDK->MDK_SALDO 	, MDK->MDK_TITULO	, MDK->MDK_DTNCC		,;
	  			  				MDK->MDK_NUMREC		, MDK->MDK_SALDO 	, MDK->MDK_MVMOED	, MDK->MDK_MOEDA  		,;
	  			  				MDK->MDK_PREFIX		, MDK->MDK_PARCEL	, MDK->MDK_TIPO   } )
	  		MDK->(DbSkip())	  				
		End
	EndIf	
	
EndIf

RestArea(aAreaL1)
RestArea(aAreaL2)
RestArea(aAreaL4)

Return aRet

//------------------------------------------------
/*/{Protheus.doc} LJTntTefD
Funcao que permite passar um TEF discado novamente 
ou cancelar todas as transações já confirmadas.
@type function
@author  michael.gabriel
@version P11.8
@since   22/08/2017
@return	 lTEFOk
/*/
//------------------------------------------------
Static Function LJTntTefD(aReb, lSemRede)

Local lTentar	:= .F.
Local lTEFOk	:= .F.
Local aTEFPend	:= {}

Default aReb	:= {}
Default lSemRede:= .F.

//Faz a leitura do arquivo TEFPEND.TEMP localizado na pasta do smartclient
aTEFPend := LJLoadDTEF()
If aScan(aTEFPend, {|x| x[8]=="CONFIRMADA"}) > 0
	lTentar := .T.
EndIf

While lTentar

	lTentar := MsgYesNo("Tentar passar o cartão novamente?" + CRLF + "Se Não, as transações já aprovadas serão canceladas.")

	If lTentar
		lTEFOk := Loja010T(  "V"	, Nil  	, aReb	, Nil  		,;
							Nil		, Nil	, Nil	, Nil		,;
							Nil		, Nil	, Nil	, @lSemRede	,;
							Nil		, Nil	, Nil 	, Nil		,;
							Nil		, Nil	, Nil	, Nil		,;
							lTentar	)
		If !lTEFOk
			//desfaz a ultima operacao PENDENTE
			LOJA010T("F","N")
		EndIf
		//se a transacao TEF foi bem sucedida (lTEFOk = TRUE), sai do loop
		lTentar := !lTEFOk
	Else
		Loja010T("X",,,,,,,,,,,,,,,,,,,,.T./*existe Trn confirmada*/)
	EndIf
EndDo

Return lTEFOk

//------------------------------------------------
/*/{Protheus.doc} lj7ImpGe
Função responsavel por alimentar as variaveis do item de garantia e o item garantido,  impressão do Termo de garantia e imprimir o relatorio não fiscal da venda com garantia
@type Static Function
@author  Lucas Novais
@version P12.1.17
@since   08/06/2018
@return	 
/*/
//------------------------------------------------
Static Function Lj7ImpGe(nVlrGar,nFatorGar,aProdGar,nValRes,nFatorVen,nFatorRes,lImpReserva,lMvLjImpGf,cMvLjTGar,lVAssConc,lEmiteNF)

Local nTmVlrItem	:= GetSX3Cache("L2_VLRITEM", "X3_TAMANHO")  //Variavel que armazena o tamanho do campo L2_VLRITEM
Local cVlrItem := ""											//Armazena o Valor a ser impresso no termo de garantia 
Local lFiscal := .F.											//Indica se é o intem fiscal (Garantido), ou não fiscal (Garantia)

If Type("nDecimais") == "U"
	nDecimais := MsDecimais(1)
EndIf

nVlrGar 	:= 0
nFatorGar 	:= 0

DbSelectArea("SL2")
SL2->( DbSetOrder(1) )
SL2->( DbSeek(xFilial("SL2") + SL1->L1_NUM) )

// Procura os itens de Garantia, guarda os valores e add no array
While SL2->( !Eof() ) .AND. ( SL2->L2_FILIAL + SL2->L2_NUM == xFilial("SL2") + SL1->L1_NUM ) .AND. !Empty(SL2->L2_ITEMGAR)
	
	If !Empty(SL2->L2_GARANT)
	 	lFiscal := .T. 
	ElseIf Posicione("SB1",1,xFilial("SB1")+SL2->L2_PRODUTO, "B1_TIPO") == cMvLjTGar
		nVlrGar += SL2->L2_VLRITEM
		AAdd( aProdGar,{SL2->L2_PRODUTO, SL2->L2_GARANT, SL2->L2_VLRITEM} )
	EndIf

	If ExistFunc("LjNFCeGE") .AND. lEmiteNF
		cVlrItem := Str( a410Arred(SL2->L2_VRUNIT * SL2->L2_QUANT, "L2_VLRITEM"), nTmVlrItem,nDecimais )
		LjNFCeGE( IIF(lFiscal, 1, 2), {SL2->L2_PRODUTO, SL2->L2_DESCRI, cVlrItem, SL2->L2_NSERIE, IIF(lFiscal,SL2->L2_GARANT,Nil)} )
	Endif 

	lFiscal := .F.
	SL2->( DbSkip() )
EndDo

// Caso tenha garantia, realiza o recalculo dos fatores de venda e reserva
If Len(aProdGar) > 0 .AND. lMvLjImpGf 

	If !lImpReserva

		nValRes 	+= nVlrGar
		nFatorGar 	:= Lj7FatRes(nVlrGar, SL1->L1_VLRLIQ + SL1->L1_DESCONT)[2]

		nFatorVen := Lj7FatRes(nValRes, SL1->L1_VLRLIQ + SL1->L1_DESCONT)[1]
		nFatorRes := Lj7FatRes(nValRes, SL1->L1_VLRLIQ + SL1->L1_DESCONT)[2]

		// nao chamara o comprovante nao fiscal aqui porque cancelara o cupom fiscal
		// iniciado na importacao do orcamento concomitante, primeiro terminara o cupom fiscal
		// e depois imprimira o comprovante nao fiscal
		If !lVAssConc .OR. lEmiteNF
			LjMsgRun( STR0013,, {|| Lj7ImpCNF( Nil, nFatorGar , Nil, 	Nil,;
											Nil  , Nil		 , 1   , aProdGar ) } )    //"Aguarde ... imprimindo o comprovante de venda ...."
		EndIf
	Else

		nFatorVen := Lj7FatRes(nVlrGar, SL1->L1_VLRLIQ + SL1->L1_DESCONT)[1]
		nFatorRes := Lj7FatRes(nVlrGar, SL1->L1_VLRLIQ + SL1->L1_DESCONT)[2]

	EndIf

EndIf

Return

